{
	"$schema": "http://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
	"contentVersion": "1.0.0.0",
	"parameters": {
		"factoryName": {
			"type": "string",
			"metadata": "Data Factory name",
			"defaultValue": "4837-df"
		}
	},
	"variables": {
		"factoryId": "[concat('Microsoft.DataFactory/factories/', parameters('factoryName'))]"
	},
	"resources": [
		{
			"name": "[concat(parameters('factoryName'), '/pl_api_policy')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Target Policy Lookup",
						"type": "Lookup",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "AzurePostgreSqlSource",
								"query": {
									"value": "@concat( 'SELECT * FROM POLICY where policy_id BETWEEN ',string(pipeline().parameters.lb) ,' and ',string(pipeline().parameters.hb))",
									"type": "Expression"
								},
								"partitionOption": "None"
							},
							"dataset": {
								"referenceName": "ds_stage_policy",
								"type": "DatasetReference",
								"parameters": {}
							},
							"firstRowOnly": false
						}
					},
					{
						"name": "Iterate Policy JSON",
						"type": "ForEach",
						"dependsOn": [
							{
								"activity": "Set access token",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@activity('Target Policy Lookup').output.value",
								"type": "Expression"
							},
							"isSequential": false,
							"batchCount": 50,
							"activities": [
								{
									"name": "Create Policy",
									"type": "WebActivity",
									"dependsOn": [],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"method": "POST",
										"headers": {
											"Authorization": {
												"value": "Bearer @{variables('access_token')}",
												"type": "Expression"
											},
											"Content-Type": "application/json"
										},
										"url": {
											"value": "@{pipeline().globalParameters.baseURL}/policyadmin-api/initiateRenewal/v1/renewal",
											"type": "Expression"
										},
										"connectVia": {
											"referenceName": "integrationRuntime2-selfhosted",
											"type": "IntegrationRuntimeReference"
										},
										"body": {
											"value": "@json(replace(concat('{\"messageInformation\": {\n        \"businessPurposeTypeCode\": \"RWL\",\n        \"trackingNumber\": \"ed5c2e08-7714-446c-84d1-0f67a7964593\",\n        \"messageStatus\": {\n            \"statusCode\": 200,\n            \"statusDescription\": \"Policy created \",\n            \"successStatusCode\": \"200\"\n        },\n        \"userInfo\": {\n            \"userName\": \"policyadmin\"\n        },\n        \"userJourneyType\": \"empty\"\n    },\n    \"policy\": dynamicData,\n    \"renewalOf\":\"', string(item().policy_number),'\",\n    \"sourcePolicyEffectiveDate\": \"2023-12-02\",\n    \"sourcePolicyExpirationDate\": \"2023-12-31\",\n    \"typeCode\": \"MANUAL\",\n    \"renewalTriggerInDays\": 60 }'), 'dynamicData' , string(item().json_data)))",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Update Succeed Policy in Tracker",
									"type": "Lookup",
									"dependsOn": [
										{
											"activity": "Create Policy",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"source": {
											"type": "AzurePostgreSqlSource",
											"query": {
												"value": "insert into policy_tracker(policy_id, policy_number, bpa_tracking_number, status, bpa_tenant_id, response_description) \nvalues(@{string(item().policy_id)},'@{string(item().policy_number)}', '@{activity('Create Policy').output.messageInformation.trackingNumber}','@{activity('Create Policy').output.messageInformation.messageStatus.statusCode}', '@{activity('Create Policy').output.messageInformation.userInfo.tenantId}', '@{activity('Create Policy').output.messageInformation.messageStatus.statusDescription}');\n\nselect * from policy_tracker limit 1",
												"type": "Expression"
											},
											"partitionOption": "None"
										},
										"dataset": {
											"referenceName": "ds_stage_policytracker",
											"type": "DatasetReference",
											"parameters": {}
										}
									}
								},
								{
									"name": "Update Failed Policy in Tracker",
									"type": "Lookup",
									"dependsOn": [
										{
											"activity": "Create Policy",
											"dependencyConditions": [
												"Failed"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"source": {
											"type": "AzurePostgreSqlSource",
											"query": {
												"value": "insert into policy_tracker(policy_id, policy_number, bpa_tracking_number, status, response_description) \nvalues(@{string(item().policy_id)},'@{string(item().policy_number)}', '@{activity('Create Policy').output.messageInformation.trackingNumber}','@{activity('Create Policy').output.messageInformation.messageStatus.statusCode}', '@{activity('Create Policy').output.messageInformation.messageStatus.errors}');\n\nselect * from policy_tracker limit 1",
												"type": "Expression"
											},
											"partitionOption": "None"
										},
										"dataset": {
											"referenceName": "ds_stage_policytracker",
											"type": "DatasetReference",
											"parameters": {}
										}
									}
								},
								{
									"name": "Lookup1",
									"type": "Lookup",
									"dependsOn": [
										{
											"activity": "Update Failed Policy in Tracker",
											"dependencyConditions": [
												"Failed"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"source": {
											"type": "AzurePostgreSqlSource",
											"query": {
												"value": "insert into policy_tracker(policy_id, policy_number, status, response_description) \nvalues(@{string(item().policy_id)},'@{string(item().policy_number)}','400', '@{activity('Create Policy').output.messageInformation}');\n\nselect * from policy_tracker limit 1",
												"type": "Expression"
											},
											"partitionOption": "None"
										},
										"dataset": {
											"referenceName": "ds_stage_policytracker",
											"type": "DatasetReference",
											"parameters": {}
										}
									}
								}
							]
						}
					},
					{
						"name": "Get token",
						"type": "WebActivity",
						"dependsOn": [
							{
								"activity": "Target Policy Lookup",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"method": "POST",
							"headers": {
								"Content-Type": "application/x-www-form-urlencoded"
							},
							"url": {
								"value": "@{pipeline().globalParameters.baseURL}/auth/realms/ecm/protocol/openid-connect/token",
								"type": "Expression"
							},
							"connectVia": {
								"referenceName": "integrationRuntime2-selfhosted",
								"type": "IntegrationRuntimeReference"
							},
							"body": {
								"value": "grant_type=client_credentials&client_id=@{pipeline().globalParameters.client_id}&client_secret=@{pipeline().globalParameters.client_secret}",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Set access token",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "Get token",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "access_token",
							"value": {
								"value": "@{activity('Get token').output.access_token}",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Stop Refreshing Token",
						"type": "SetVariable",
						"state": "Inactive",
						"onInactiveMarkAs": "Succeeded",
						"dependsOn": [
							{
								"activity": "Iterate Policy JSON",
								"dependencyConditions": [
									"Completed"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "continueLoop",
							"value": true
						}
					},
					{
						"name": "Refresh token",
						"type": "Until",
						"state": "Inactive",
						"onInactiveMarkAs": "Succeeded",
						"dependsOn": [
							{
								"activity": "Set access token",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"expression": {
								"value": "@variables('continueLoop')",
								"type": "Expression"
							},
							"activities": [
								{
									"name": "Get new token",
									"type": "WebActivity",
									"dependsOn": [
										{
											"activity": "Wait",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"method": "POST",
										"headers": {
											"Content-Type": "application/x-www-form-urlencoded"
										},
										"url": {
											"value": "@{pipeline().globalParameters.baseURL}/auth/realms/ecm/protocol/openid-connect/token\n",
											"type": "Expression"
										},
										"body": {
											"value": "grant_type=client_credentials&client_id=@{pipeline().globalParameters.client_id}&client_secret=@{pipeline().globalParameters.client_secret}",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Wait",
									"type": "Wait",
									"dependsOn": [],
									"userProperties": [],
									"typeProperties": {
										"waitTimeInSeconds": 1
									}
								},
								{
									"name": "Set new token",
									"type": "SetVariable",
									"dependsOn": [
										{
											"activity": "Get new token",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "access_token",
										"value": {
											"value": "@{activity('Get new token').output.access_token}",
											"type": "Expression"
										}
									}
								}
							],
							"timeout": "0.12:00:00"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"lb": {
						"type": "int",
						"defaultValue": 1
					},
					"hb": {
						"type": "int",
						"defaultValue": 4
					}
				},
				"variables": {
					"access_token": {
						"type": "String"
					},
					"continueLoop": {
						"type": "Boolean",
						"defaultValue": false
					},
					"lowerBound": {
						"type": "Integer"
					},
					"higherBound": {
						"type": "Integer"
					},
					"round": {
						"type": "Integer"
					}
				},
				"folder": {
					"name": "Target Data Movement"
				},
				"annotations": []
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_quote_premium')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Policy Lookup",
						"type": "Lookup",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "AzurePostgreSqlSource",
								"query": {
									"value": "@concat( 'select policy_id, policy_number from policy_tracker where status= ''', '200',  ''' and policy_id BETWEEN ',string(pipeline().parameters.lb) ,' and ',string(pipeline().parameters.hb))",
									"type": "Expression"
								},
								"partitionOption": "None"
							},
							"dataset": {
								"referenceName": "joinTablePostgres",
								"type": "DatasetReference",
								"parameters": {}
							},
							"firstRowOnly": false
						}
					},
					{
						"name": "Get token",
						"type": "WebActivity",
						"dependsOn": [
							{
								"activity": "Policy Lookup",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"method": "POST",
							"headers": {
								"Content-Type": "application/x-www-form-urlencoded"
							},
							"url": {
								"value": "@{pipeline().globalParameters.baseURL}/auth/realms/ecm/protocol/openid-connect/token\n",
								"type": "Expression"
							},
							"body": {
								"value": "grant_type=client_credentials&client_id=@{pipeline().globalParameters.client_id}&client_secret=@{pipeline().globalParameters.client_secret}",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Iterate QuoteInfo JSON",
						"type": "ForEach",
						"dependsOn": [
							{
								"activity": "Get token",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@activity('Policy Lookup').output.value",
								"type": "Expression"
							},
							"isSequential": false,
							"batchCount": 50,
							"activities": [
								{
									"name": "Search Policy By RenewalOf",
									"type": "WebActivity",
									"dependsOn": [],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"method": "POST",
										"headers": {
											"Authorization": {
												"value": "Bearer @{activity('Get token').output.access_token}",
												"type": "Expression"
											},
											"Content-Type": "application/json"
										},
										"url": {
											"value": "@{pipeline().globalParameters.baseURL}/policyadmin-api/searchPolicyInformation/v1/policy",
											"type": "Expression"
										},
										"body": {
											"value": "@json(replace('{\"searchParams\":\"renewalOf:dynamicData\"}', 'dynamicData' , string(item().policy_number)))",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Lookup2",
									"type": "Lookup",
									"dependsOn": [
										{
											"activity": "Search Policy By RenewalOf",
											"dependencyConditions": [
												"Failed"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"source": {
											"type": "AzurePostgreSqlSource",
											"query": {
												"value": "INSERT INTO quote_info (policy_id, status, api_stage, response)\nVALUES (@{string(item().policy_id)}, 'failed', 'Search Policy By RenewalOf', '@{activity('Search Policy By RenewalOf').output.messageInformation}');\n\nselect * from quote_info limit 1;\n",
												"type": "Expression"
											},
											"partitionOption": "None"
										},
										"dataset": {
											"referenceName": "ds_target_quoteInfo",
											"type": "DatasetReference",
											"parameters": {}
										}
									}
								},
								{
									"name": "SearchQuote",
									"type": "WebActivity",
									"dependsOn": [
										{
											"activity": "Search Policy By RenewalOf",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"method": "POST",
										"headers": {
											"Authorization": {
												"value": "Bearer @{activity('Get token').output.access_token}",
												"type": "Expression"
											},
											"Content-Type": "application/json"
										},
										"url": {
											"value": "@{pipeline().globalParameters.baseURL}/policyadmin-api/searchQuote/v1/quote",
											"type": "Expression"
										},
										"body": {
											"value": "@json(replace('{\"searchParams\":\"referenceNumber:*dynamicData*\"}', 'dynamicData' , activity('Search Policy By RenewalOf').output.policy[0].referenceNumber))",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Retrieve QuoteInfo",
									"type": "WebActivity",
									"dependsOn": [
										{
											"activity": "SearchQuote",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"method": "GET",
										"headers": {
											"Authorization": {
												"value": "Bearer @{activity('Get token').output.access_token}",
												"type": "Expression"
											},
											"Content-Type": "application/json"
										},
										"url": {
											"value": "@{pipeline().globalParameters.baseURL}/policyadmin-api/retrieveQuoteInformation/v1/quote/@{activity('SearchQuote').output.quote[0].quoteNumber}?identifierType=number",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Lookup3",
									"type": "Lookup",
									"dependsOn": [
										{
											"activity": "SearchQuote",
											"dependencyConditions": [
												"Failed"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"source": {
											"type": "AzurePostgreSqlSource",
											"query": {
												"value": "INSERT INTO quote_info (policy_id, policy_reference, status, api_stage, response)\nVALUES (@{string(item().policy_id)}, '@{activity('Search Policy By RenewalOf').output.policy[0].referenceNumber}', 'failed', 'Search Quote', '@{activity('SearchQuote').output.messageInformation}');\n\nselect * from quote_info limit 1;",
												"type": "Expression"
											},
											"partitionOption": "None"
										},
										"dataset": {
											"referenceName": "ds_target_quoteInfo",
											"type": "DatasetReference",
											"parameters": {}
										}
									}
								},
								{
									"name": "Lookup4",
									"type": "Lookup",
									"dependsOn": [
										{
											"activity": "Retrieve QuoteInfo",
											"dependencyConditions": [
												"Failed"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"source": {
											"type": "AzurePostgreSqlSource",
											"query": {
												"value": "INSERT INTO quote_info (policy_id, policy_reference, quote_number, status, api_stage, response)\nVALUES (@{string(item().policy_id)}, '@{activity('Search Policy By RenewalOf').output.policy[0].referenceNumber}', '@{activity('SearchQuote').output.quote[0].quoteNumber}','failed', 'Retrieve QuoteInfo', '@{activity('Retrieve QuoteInfo').output.messageInformation}');\n\nselect * from quote_info limit 1;",
												"type": "Expression"
											},
											"partitionOption": "None"
										},
										"dataset": {
											"referenceName": "ds_target_quoteInfo",
											"type": "DatasetReference",
											"parameters": {}
										}
									}
								},
								{
									"name": "Lookup5",
									"type": "Lookup",
									"dependsOn": [
										{
											"activity": "Calculate Premium",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"source": {
											"type": "AzurePostgreSqlSource",
											"query": {
												"value": "INSERT INTO quote_info (policy_id, policy_number, policy_reference, quote_number, status, api_stage, quote, response)\nVALUES (@{string(item().policy_id)}, '@{string(item().policy_number)}', '@{activity('Search Policy By RenewalOf').output.policy[0].referenceNumber}', '@{activity('SearchQuote').output.quote[0].quoteNumber}','success', 'Calculate Premium', '@{replace(string(activity('Retrieve QuoteInfo').output.quote), '''', '')}', '@{replace(string(activity('Calculate Premium').output.riskDetail), '''', '')}');\n\nselect * from quote_info limit 1;\n\n",
												"type": "Expression"
											},
											"partitionOption": "None"
										},
										"dataset": {
											"referenceName": "ds_target_quoteInfo",
											"type": "DatasetReference",
											"parameters": {}
										}
									}
								},
								{
									"name": "Calculate Premium",
									"type": "WebActivity",
									"dependsOn": [
										{
											"activity": "Retrieve QuoteInfo",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"method": "POST",
										"headers": {
											"Authorization": {
												"value": "Bearer @{activity('Get token').output.access_token}",
												"type": "Expression"
											},
											"Content-Type": "application/json"
										},
										"url": {
											"value": "@{pipeline().globalParameters.baseURL}/policyadmin-api/calculateRatedValues/v1/quote/@{activity('SearchQuote').output.quote[0].quoteNumber}",
											"type": "Expression"
										},
										"body": {
											"value": "@json(replace('{\"messageInformation\":{\"sender\":\"adfclient\",\"userInfo\":{\"partyDetails\":[{\"partyCode\":\"\",\"partyRole\":\"\"}],\"userName\":\"Viswa\"},\"businessPurposeTypeCode\":\"xyz\",\"trackingNumber\":\"09cbf4b4-2b59-f42c-3ce2-e8c34e737398\"},\"quote\":dynamicData', 'dynamicData' , string(activity('Retrieve QuoteInfo').output.quote)))",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Lookup6",
									"type": "Lookup",
									"dependsOn": [
										{
											"activity": "Calculate Premium",
											"dependencyConditions": [
												"Failed"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"source": {
											"type": "AzurePostgreSqlSource",
											"query": {
												"value": "INSERT INTO quote_info (policy_id, policy_number, policy_reference, quote_number, status, api_stage, quote, response)\nVALUES (@{string(item().policy_id)}, '@{string(item().policy_number)}', '@{activity('Search Policy By RenewalOf').output.policy[0].referenceNumber}', '@{activity('SearchQuote').output.quote[0].quoteNumber}','failed', 'Calculate Premium', '@{activity('Retrieve QuoteInfo').output.quote}', '@{replace(string(activity('Calculate Premium').output.messageInformation), '''', '')}');\n\nselect * from quote_info limit 1;",
												"type": "Expression"
											},
											"partitionOption": "None"
										},
										"dataset": {
											"referenceName": "ds_target_quoteInfo",
											"type": "DatasetReference",
											"parameters": {}
										}
									}
								}
							]
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"lb": {
						"type": "int",
						"defaultValue": 617
					},
					"hb": {
						"type": "int",
						"defaultValue": 617
					}
				},
				"folder": {
					"name": "utility/rating"
				},
				"annotations": []
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_rater_report_deprecated')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "QuoteInfo Lookup",
						"type": "Lookup",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "AzurePostgreSqlSource",
								"query": {
									"value": "@concat( 'select policy_number , quote_number, quote, policy_id from quote_info where policy_id BETWEEN ',string(pipeline().parameters.lb) ,' and ',string(pipeline().parameters.hb))",
									"type": "Expression"
								},
								"partitionOption": "None"
							},
							"dataset": {
								"referenceName": "ds_target_quoteInfo",
								"type": "DatasetReference",
								"parameters": {}
							},
							"firstRowOnly": false
						}
					},
					{
						"name": "Iterate QuoteInfo JSON",
						"type": "ForEach",
						"dependsOn": [
							{
								"activity": "Get token",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@activity('QuoteInfo Lookup').output.value",
								"type": "Expression"
							},
							"isSequential": false,
							"batchCount": 50,
							"activities": [
								{
									"name": "Calculate Premium",
									"type": "WebActivity",
									"dependsOn": [],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"method": "POST",
										"headers": {
											"Authorization": {
												"value": "Bearer @{activity('Get token').output.access_token}",
												"type": "Expression"
											},
											"Content-Type": "application/json"
										},
										"url": {
											"value": "@{pipeline().globalParameters.baseURL}/policyadmin-api/calculateRatedValues/v1/quote/item().quote_number",
											"type": "Expression"
										},
										"body": {
											"value": "@json(replace('{\"messageInformation\":{\"sender\":\"adfclient\",\"userInfo\":{\"partyDetails\":[{\"partyCode\":\"\",\"partyRole\":\"\"}],\"userName\":\"Viswa\"},\"businessPurposeTypeCode\":\"xyz\",\"trackingNumber\":\"09cbf4b4-2b59-f42c-3ce2-e8c34e737398\"},\"quote\":dynamicData', 'dynamicData' , string(item().quote)))",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Lookup1",
									"type": "Lookup",
									"dependsOn": [
										{
											"activity": "Calculate Premium",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"source": {
											"type": "AzurePostgreSqlSource",
											"query": {
												"value": "update quote_info set status='success', response='@{activity('Calculate Premium').output.riskDetail}' where policy_id=@{string(item().policy_id)};\n\nselect * from quote_info limit 1;",
												"type": "Expression"
											},
											"partitionOption": "None"
										},
										"dataset": {
											"referenceName": "ds_target_quoteInfo",
											"type": "DatasetReference",
											"parameters": {}
										}
									}
								},
								{
									"name": "Lookup2",
									"type": "Lookup",
									"dependsOn": [
										{
											"activity": "Calculate Premium",
											"dependencyConditions": [
												"Failed"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"source": {
											"type": "AzurePostgreSqlSource",
											"query": {
												"value": "update quote_info set status='failed', response='@{activity('Calculate Premium').output.messageInformation}' where policy_id=@{string(item().policy_id)};\n\nselect * from quote_info limit 1;",
												"type": "Expression"
											},
											"partitionOption": "None"
										},
										"dataset": {
											"referenceName": "ds_target_quoteInfo",
											"type": "DatasetReference",
											"parameters": {}
										}
									}
								}
							]
						}
					},
					{
						"name": "Get token",
						"type": "WebActivity",
						"dependsOn": [
							{
								"activity": "QuoteInfo Lookup",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"method": "POST",
							"headers": {
								"Content-Type": "application/x-www-form-urlencoded"
							},
							"url": {
								"value": "@{pipeline().globalParameters.baseURL}/auth/realms/ecm/protocol/openid-connect/token\n",
								"type": "Expression"
							},
							"body": {
								"value": "grant_type=client_credentials&client_id=@{pipeline().globalParameters.client_id}&client_secret=@{pipeline().globalParameters.client_secret}",
								"type": "Expression"
							}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"lb": {
						"type": "int"
					},
					"hb": {
						"type": "int"
					}
				},
				"variables": {
					"policy_id": {
						"type": "String"
					}
				},
				"folder": {
					"name": "utility"
				},
				"annotations": []
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_CFA_coverages_meta')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Target Stage Data Flows/cfa"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "dsCFA",
								"type": "DatasetReference"
							},
							"name": "source1"
						},
						{
							"dataset": {
								"referenceName": "ECMBPA_COV_MAP",
								"type": "DatasetReference"
							},
							"name": "source2"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ECMBPA_COV_MAP",
								"type": "DatasetReference"
							},
							"name": "sink1"
						},
						{
							"name": "sink2"
						}
					],
					"transformations": [
						{
							"name": "derivedColumn1"
						},
						{
							"name": "surrogateKey1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          SI_NO as string,",
						"          id as string,",
						"          COVERAGE_CODE as string,",
						"          COV_SEQ as string,",
						"          COVERAGE_CODE_DES as string,",
						"          COVERAGES as string,",
						"          BPA_COVERAGE_CODES as string,",
						"          BPA_SECTION_CODE as string,",
						"          BPA_SEC_NAME as string,",
						"          BPA_COVERAGES as string,",
						"          {BPA Coverage Groups} as string,",
						"          {BPA Coverage Type} as string,",
						"          BPA_PRODUCT_CODE as string,",
						"          SOURCE_PRODUCT_CODE as string,",
						"          coverage_level as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> source1",
						"source(output(",
						"          id as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select coalesce(MAX(id),0) as id from public.ecm_bpa_cov_mapping',",
						"     format: 'query') ~> source2",
						"surrogateKey1 derive(id = sink2#outputs()[1].id+pkey,",
						"          SI_NO = sink2#outputs()[1].id+pkey,",
						"          bpa_coverage_type = {BPA Coverage Type},",
						"          bpa_coverage_group = {BPA Coverage Groups},",
						"          bpa_coverage_level = coverage_level) ~> derivedColumn1",
						"source1 keyGenerate(output(pkey as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> surrogateKey1",
						"derivedColumn1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          COV_SEQ as string,",
						"          BPA_SECTION_CODE as string,",
						"          COVERAGE_CODE as string,",
						"          COVERAGE_CODE_DES as string,",
						"          BPA_COVERAGE_CODES as string,",
						"          BPA_COVERAGES as string,",
						"          COVERAGES as string,",
						"          BPA_PRODUCT_CODE as string,",
						"          SI_NO as string,",
						"          id as long,",
						"          BPA_SEC_NAME as string,",
						"          SOURCE_PRODUCT_CODE as string,",
						"          bpa_coverage_group as string,",
						"          bpa_coverage_level as string,",
						"          bpa_coverage_type as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink1",
						"source2 sink(validateSchema: false,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     store: 'cache',",
						"     format: 'inline',",
						"     output: false,",
						"     saveOrder: 1) ~> sink2"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_addDeductible_to_policy_level_coverage')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Target Stage Data Flows/deductibles"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_stage_coverage",
								"type": "DatasetReference"
							},
							"name": "targetCoverage"
						},
						{
							"dataset": {
								"referenceName": "ds_stage_deductible",
								"type": "DatasetReference"
							},
							"name": "osDeductibleLimit"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_stage_coverage",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "join1"
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "derivedColumn2"
						},
						{
							"name": "AlterRow1"
						},
						{
							"name": "filter1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          coverage_id as integer,",
						"          policy_id as integer,",
						"          json_data as string,",
						"          coverage_code as string,",
						"          risk_id as long,",
						"          location_id as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select * from coverage where risk_id is null\\n',",
						"     format: 'query') ~> targetCoverage",
						"source(output(",
						"          deductible_id as integer,",
						"          coverage_id as integer,",
						"          json_data as string,",
						"          risk_id as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> osDeductibleLimit",
						"filter1, derivedColumn1 join(targetCoverage@coverage_id == osDeductibleLimit@coverage_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"osDeductibleLimit derive(deductibleJson = json_data) ~> derivedColumn1",
						"join1 derive(json_data = replace(targetCoverage@json_data, '\"deductible\":[]',concat( '\"deductible\":', deductibleJson))) ~> derivedColumn2",
						"derivedColumn2 alterRow(updateIf(!isNull(targetCoverage@coverage_id))) ~> AlterRow1",
						"targetCoverage filter(isNull (risk_id)) ~> filter1",
						"AlterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          coverage_id as integer,",
						"          policy_id as integer,",
						"          json_data as string,",
						"          coverage_code as string,",
						"          risk_id as long,",
						"          location_id as long",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['policy_id','coverage_id'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink1"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_addDeductible_to_risk_level_coverage')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Target Stage Data Flows/deductibles"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_stage_coverage",
								"type": "DatasetReference"
							},
							"name": "targetCoverage"
						},
						{
							"dataset": {
								"referenceName": "ds_stage_deductible",
								"type": "DatasetReference"
							},
							"name": "osTargetDeductible"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_stage_coverage",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "join1"
						},
						{
							"name": "derivedColumn2"
						},
						{
							"name": "AlterRow1"
						},
						{
							"name": "updatedDeductiblejson"
						},
						{
							"name": "filter1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          coverage_id as integer,",
						"          policy_id as integer,",
						"          json_data as string,",
						"          coverage_code as string,",
						"          risk_id as long,",
						"          location_id as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> targetCoverage",
						"source(output(",
						"          deductible_id as integer,",
						"          coverage_id as integer,",
						"          json_data as string,",
						"          risk_id as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> osTargetDeductible",
						"filter1, updatedDeductiblejson join(targetCoverage@coverage_id == osTargetDeductible@coverage_id",
						"     && targetCoverage@risk_id == osTargetDeductible@risk_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"join1 derive(json_data = replace(targetCoverage@json_data, '\"deductible\":[]',concat( '\"deductible\":', deductibleJson))) ~> derivedColumn2",
						"derivedColumn2 alterRow(updateIf(!isNull(targetCoverage@coverage_id))) ~> AlterRow1",
						"osTargetDeductible derive(deductibleJson = json_data) ~> updatedDeductiblejson",
						"targetCoverage filter(!isNull (risk_id)) ~> filter1",
						"AlterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          coverage_id as integer,",
						"          policy_id as integer,",
						"          json_data as string,",
						"          coverage_code as string,",
						"          risk_id as long,",
						"          location_id as long",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['policy_id','coverage_id','risk_id'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink1"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_addLimit_to_policy_level_coverage')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Target Stage Data Flows/limits"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_stage_coverage",
								"type": "DatasetReference"
							},
							"name": "targetCoverage"
						},
						{
							"dataset": {
								"referenceName": "ds_stage_limit",
								"type": "DatasetReference"
							},
							"name": "osTargeLimit"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_stage_coverage",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "join1"
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "derivedColumn2"
						},
						{
							"name": "AlterRow1"
						},
						{
							"name": "filter1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          coverage_id as integer,",
						"          policy_id as integer,",
						"          json_data as string,",
						"          coverage_code as string,",
						"          risk_id as long,",
						"          location_id as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select * from coverage where risk_id is null\\n',",
						"     format: 'query') ~> targetCoverage",
						"source(output(",
						"          limit_id as integer,",
						"          coverage_id as integer,",
						"          json_data as string,",
						"          risk_id as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> osTargeLimit",
						"filter1, derivedColumn1 join(targetCoverage@coverage_id == osTargeLimit@coverage_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"osTargeLimit derive(limitJson = json_data) ~> derivedColumn1",
						"join1 derive(json_data = replace(targetCoverage@json_data, '\"limit\":[]',concat( '\"limit\":', limitJson))) ~> derivedColumn2",
						"derivedColumn2 alterRow(updateIf(!isNull(targetCoverage@coverage_id))) ~> AlterRow1",
						"targetCoverage filter(isNull (risk_id)) ~> filter1",
						"AlterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          coverage_id as integer,",
						"          policy_id as integer,",
						"          json_data as string,",
						"          coverage_code as string,",
						"          risk_id as long,",
						"          location_id as long",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['policy_id','coverage_id'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink1"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_addLimit_to_risk_level_coverage')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Target Stage Data Flows/limits"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_stage_coverage",
								"type": "DatasetReference"
							},
							"name": "targetCoverage"
						},
						{
							"dataset": {
								"referenceName": "ds_stage_limit",
								"type": "DatasetReference"
							},
							"name": "osTargeLimit"
						},
						{
							"dataset": {
								"referenceName": "ds_stage_deductible",
								"type": "DatasetReference"
							},
							"name": "osTargetDeductible"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_stage_coverage",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "join1"
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "derivedColumn2"
						},
						{
							"name": "AlterRow1"
						},
						{
							"name": "updatedDeductiblejson"
						},
						{
							"name": "filter1"
						},
						{
							"name": "derivedColumn3"
						},
						{
							"name": "filter2"
						}
					],
					"scriptLines": [
						"parameters{",
						"     policyPrefix as string ('CFA')",
						"}",
						"source(output(",
						"          coverage_id as integer,",
						"          policy_id as integer,",
						"          json_data as string,",
						"          coverage_code as string,",
						"          risk_id as long,",
						"          location_id as long,",
						"          policy_number as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select cov.coverage_id     ,cov.policy_id     ,cov.json_data,     cov.coverage_code,     cov.risk_id,cov.location_id,p.policy_number\\n from coverage cov join policy p on cov.policy_id = p.policy_id ',",
						"     format: 'query') ~> targetCoverage",
						"source(output(",
						"          limit_id as integer,",
						"          coverage_id as integer,",
						"          json_data as string,",
						"          risk_id as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select * from cov_limit',",
						"     format: 'query') ~> osTargeLimit",
						"source(output(",
						"          deductible_id as integer,",
						"          coverage_id as integer,",
						"          json_data as string,",
						"          risk_id as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> osTargetDeductible",
						"filter1, derivedColumn1 join(targetCoverage@coverage_id == osTargeLimit@coverage_id",
						"     && targetCoverage@risk_id == osTargeLimit@risk_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"osTargeLimit derive(limitJson = json_data) ~> derivedColumn1",
						"join1 derive(json_data = replace(targetCoverage@json_data, '\"limit\":[]',concat( '\"limit\":', limitJson))) ~> derivedColumn2",
						"derivedColumn2 alterRow(updateIf(!isNull(targetCoverage@coverage_id))) ~> AlterRow1",
						"osTargetDeductible derive(deductibleJson = json_data) ~> updatedDeductiblejson",
						"filter2 filter(!isNull (risk_id)) ~> filter1",
						"targetCoverage derive(policyPrefixTemp = substring(policy_number, 1, 3)) ~> derivedColumn3",
						"derivedColumn3 filter(policyPrefixTemp == $policyPrefix) ~> filter2",
						"AlterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          coverage_id as integer,",
						"          policy_id as integer,",
						"          json_data as string,",
						"          coverage_code as string,",
						"          risk_id as long,",
						"          location_id as long",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['policy_id','coverage_id','risk_id'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink1"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_addSec000')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Stage Target Data Flows"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "targetSection",
								"type": "DatasetReference"
							},
							"name": "source1"
						},
						{
							"dataset": {
								"referenceName": "ds_stage_location",
								"type": "DatasetReference"
							},
							"name": "targetLocation"
						},
						{
							"dataset": {
								"referenceName": "ds_stage_risk",
								"type": "DatasetReference"
							},
							"name": "targetRisk"
						},
						{
							"dataset": {
								"referenceName": "targetSection",
								"type": "DatasetReference"
							},
							"name": "source2"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policy",
								"type": "DatasetReference"
							},
							"name": "stgPolicy"
						},
						{
							"dataset": {
								"referenceName": "ds_stage_coverage",
								"type": "DatasetReference"
							},
							"name": "sec000Coverages"
						},
						{
							"dataset": {
								"referenceName": "ECMBPA_COV_MAP",
								"type": "DatasetReference"
							},
							"name": "osBpaCovMap"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "targetSection",
								"type": "DatasetReference"
							},
							"name": "targetSection"
						},
						{
							"name": "sink2"
						}
					],
					"transformations": [
						{
							"name": "flowlet1",
							"flowlet": {
								"referenceName": "df_update_stage_policyWithSection1",
								"type": "DataFlowReference",
								"parameters": {}
							}
						},
						{
							"name": "join1"
						},
						{
							"name": "derivedColumn5"
						},
						{
							"name": "targetRiskDerived"
						},
						{
							"name": "select1"
						},
						{
							"name": "aggregate2"
						},
						{
							"name": "lookup1"
						},
						{
							"name": "derivedColumn7"
						},
						{
							"name": "surrogateKey1"
						},
						{
							"name": "select3"
						},
						{
							"name": "filter1"
						},
						{
							"name": "select4"
						},
						{
							"name": "derivedColumn8"
						},
						{
							"name": "derivedColumn9"
						},
						{
							"name": "policyState"
						},
						{
							"name": "lookup2"
						},
						{
							"name": "derivedColumn10"
						},
						{
							"name": "AlterRow1"
						},
						{
							"name": "sec00CovDervied"
						},
						{
							"name": "select5"
						},
						{
							"name": "join2"
						},
						{
							"name": "aggregate3"
						},
						{
							"name": "derivedColumn11"
						},
						{
							"name": "derivedColumn12"
						},
						{
							"name": "derivedColumn13"
						},
						{
							"name": "byPolicyLevel"
						},
						{
							"name": "join3"
						},
						{
							"name": "derivedColumn14"
						}
					],
					"scriptLines": [
						"parameters{",
						"     policyPrefix as string ('CFA')",
						"}",
						"source(output(",
						"          section_id as integer,",
						"          policy_id as integer,",
						"          coverage_id as integer,",
						"          location_id as integer,",
						"          limit_id as integer,",
						"          deductible_id as integer,",
						"          insurableobject_id as integer,",
						"          json_data as string,",
						"          extendedattributes as string,",
						"          section_code as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select * from bpa_section ',",
						"     format: 'query') ~> source1",
						"source(output(",
						"          location_id as integer,",
						"          policy_id as integer,",
						"          address_id as integer,",
						"          json_data as string,",
						"          extendedattributes as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select * from location ',",
						"     format: 'query') ~> targetLocation",
						"source(output(",
						"          risk_id as integer,",
						"          policy_id as integer,",
						"          json_data as string,",
						"          location_id as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select * from risk ',",
						"     format: 'query') ~> targetRisk",
						"source(output(",
						"          section_id as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select MAX(section_id) as section_id from bpa_section',",
						"     format: 'query') ~> source2",
						"source(output(",
						"          POLICY_ID as long,",
						"          POLICY_VID as long,",
						"          REINSURANCE_DAC as string,",
						"          PREVIOUS_INSURANCE_NO_REMARKS as string,",
						"          AGENCY_ID as long,",
						"          AGENCY_OVID as long,",
						"          PRODUCER_ID as long,",
						"          PRODUCER_OVID as long,",
						"          PRODUCER_CONTACT_ID as long,",
						"          PRODUCER_CONTACT_OVID as long,",
						"          POLICY_NUMBER as string,",
						"          ENTITY_TYPE as string,",
						"          ENTITY_STATUS as string,",
						"          IS_RENEWAL_YN as string,",
						"          REVISION_NUMBER as integer,",
						"          PRODUCT_ID as long,",
						"          PRODUCT_OVID as long,",
						"          POLICY_EFFECTIVE_DATE as timestamp,",
						"          POLICY_EXPIRATION_DATE as timestamp,",
						"          NON_RENEWAL_CODE as string,",
						"          POLICY_RENEWED_YN as string,",
						"          CANCELLATION_DATE as timestamp,",
						"          IS_RENEWABLE_YN as string,",
						"          PREVIOUS_INSURANCE_NO_REASON as string,",
						"          POLICY_STATUS as string,",
						"          CANCEL_REASON_CODE as string,",
						"          CANCEL_REASON_DESCRIPTION as string,",
						"          CANCEL_METHOD as string,",
						"          CANCEL_METHOD_DESC as string,",
						"          LOSE_REASON_CODE as string,",
						"          LOSE_REASON_DESC as string,",
						"          DECLINATION_REASON_CODE as string,",
						"          DECLINATION_REASON_DESC as string,",
						"          NOT_WRITTEN_REASON_CODE as string,",
						"          NOT_WRITTEN_REASON_DESC as string,",
						"          POLICY_STATE_CODE as string,",
						"          PROGRAM_ID as long,",
						"          PROGRAM_OVID as long,",
						"          BILLING_TYPE_CODE as string,",
						"          UNDERWRITING_COMPANY_ID as long,",
						"          UNDERWRITING_COMPANY_OVID as long,",
						"          SUBMISSION_ID as long,",
						"          PREVIOUS_INSURANCE_YN as string,",
						"          LEGACY_POLICY_NUMBER as string,",
						"          STATE as string,",
						"          POLICY_POLICY as integer,",
						"          PAYMENT_PLAN as string,",
						"          APPLICATION_RECEIVED_DATE as timestamp,",
						"          INCEPTION_DATE as timestamp,",
						"          BILL_TYPE as string,",
						"          FORMS_LANGUAGE as string,",
						"          BASE_CURRENCY as string,",
						"          INVOICE_CURRENCY as string,",
						"          PREVIOUS_POLICY_ID as long,",
						"          PREVIOUS_POLICY_OVID as long,",
						"          REVISED_FROM_POLICY_ID as long,",
						"          REVISED_FROM_POLICY_OVID as long,",
						"          OPERATING_COMPANY_ID as long,",
						"          OPERATING_COMPANY_OVID as long,",
						"          CONVERTED_FROM_ID as long,",
						"          CONVERTED_FROM_OVID as long,",
						"          INSTALLMENT_RENEWAL as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> stgPolicy",
						"source(output(",
						"          coverage_id as integer,",
						"          policy_id as integer,",
						"          json_data as string,",
						"          coverage_code as string,",
						"          risk_id as long,",
						"          location_id as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select * from coverage ',",
						"     format: 'query') ~> sec000Coverages",
						"source(output(",
						"          COV_SEQ as string,",
						"          BPA_SECTION_CODE as string,",
						"          COVERAGE_CODE as string,",
						"          COVERAGE_CODE_DES as string,",
						"          BPA_COVERAGE_CODES as string,",
						"          BPA_COVERAGES as string,",
						"          COVERAGES as string,",
						"          BPA_PRODUCT_CODE as string,",
						"          SI_NO as string,",
						"          id as long,",
						"          BPA_SEC_NAME as string,",
						"          SOURCE_PRODUCT_CODE as string,",
						"          bpa_coverage_group as string,",
						"          bpa_coverage_level as string,",
						"          bpa_coverage_type as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> osBpaCovMap",
						"derivedColumn7 compose(mapColumn(",
						"          json = json_data,",
						"          id = policy_id,",
						"          sec_id = section_id,",
						"          sec_code = section_code_000,",
						"          filteredSection",
						"     ),",
						"     composition: 'df_update_stage_policyWithSection1') ~> flowlet1@(output1)",
						"derivedColumn5, targetRiskDerived join(targetLocation@policy_id == targetRisk@policy_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"targetLocation derive(locationJson = unescape(json_data,'json')) ~> derivedColumn5",
						"targetRisk derive(riskJson = unescape(json_data,'json')) ~> targetRiskDerived",
						"join1 select(mapColumn(",
						"          policy_id = targetLocation@policy_id,",
						"          locationJson,",
						"          riskJson",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"select1 aggregate(groupBy(policy_id),",
						"     locationJson = distinct(collect(locationJson)),",
						"          riskJson = distinct(collect(riskJson))) ~> aggregate2",
						"lookup2, aggregate2 lookup(source1@policy_id == aggregate2@policy_id,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lookup1",
						"derivedColumn14 derive(json_data = toString(section_json),",
						"          section_id = iif( isNull(sectionId), pkey + sink2#outputs()[1].section_id,sectionId),",
						"          section_code_000 = 'SEC000') ~> derivedColumn7",
						"derivedColumn12 keyGenerate(output(pkey as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> surrogateKey1",
						"join2 select(mapColumn(",
						"          policy_id = source1@policy_id,",
						"          section_code,",
						"          locationJson,",
						"          riskJson,",
						"          POLICY_STATE_CODE,",
						"          POLICY_NUMBER,",
						"          covJson,",
						"          section_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select3",
						"lookup1 filter(!isNull(aggregate2@policy_id)) ~> filter1",
						"flowlet1@output1 select(mapColumn(",
						"          policy_id = id,",
						"          section_code = sec_code,",
						"          json_data = finalJson,",
						"          section_id = sec_id,",
						"          filteredSection",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select4",
						"select4 derive(json_data = replace(json_data, '\"[', '[')) ~> derivedColumn8",
						"derivedColumn8 derive(json_data = replace(json_data, ']\"', ']')) ~> derivedColumn9",
						"stgPolicy select(mapColumn(",
						"          POLICY_ID,",
						"          POLICY_VID,",
						"          POLICY_NUMBER,",
						"          POLICY_STATE_CODE",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> policyState",
						"source1, policyState lookup(source1@policy_id == policyState@POLICY_ID,",
						"     multiple: false,",
						"     pickup: 'first',",
						"     asc(policyState@POLICY_ID, true),",
						"     broadcast: 'auto')~> lookup2",
						"select3 derive(extendedAttributes = @(name='externalPolicyNumber',",
						"          value=POLICY_NUMBER)) ~> derivedColumn10",
						"derivedColumn9 alterRow(insertIf(isNull(filteredSection)),",
						"     updateIf(!isNull(filteredSection))) ~> AlterRow1",
						"join3 derive(covJson = json_data) ~> sec00CovDervied",
						"sec00CovDervied select(mapColumn(",
						"          policy_id,",
						"          covJson",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select5",
						"filter1, select5 join(source1@policy_id == select5@policy_id,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join2",
						"derivedColumn10 aggregate(groupBy(policy_id,",
						"          POLICY_STATE_CODE,",
						"          riskJson,",
						"          locationJson,",
						"          POLICY_NUMBER,",
						"          covJson,",
						"          extendedAttributes),",
						"     seccode_with_sec_id = collect(concat(section_code,'-',toString(section_id)))) ~> aggregate3",
						"aggregate3 derive(filteredSection = find(seccode_with_sec_id, startsWith(#item, 'SEC000'))) ~> derivedColumn11",
						"derivedColumn11 derive(sectionId = toLong(split(filteredSection,'-')[2]),",
						"          section_code = split(filteredSection,'-')[1]) ~> derivedColumn12",
						"sec000Coverages derive(coverageLine = split(coverage_code, '-')[4],",
						"          coverageSeq = split(coverage_code, '-')[5]) ~> derivedColumn13",
						"osBpaCovMap filter((bpa_coverage_level == 'P' && BPA_PRODUCT_CODE == $policyPrefix && BPA_SECTION_CODE == 'SEC000')) ~> byPolicyLevel",
						"derivedColumn13, byPolicyLevel join(coverageLine == osBpaCovMap@COVERAGE_CODE",
						"     && coverageSeq == COV_SEQ,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join3",
						"surrogateKey1 derive(section_json = @(lineOfBusinessCode='EQMR',",
						"          coverTypeCode='SEC000',",
						"          primaryRatingState=POLICY_STATE_CODE,",
						"          coverage=iif(isNull(covJson),array(),array(covJson)),",
						"          insurableObject=riskJson,",
						"          location=locationJson,",
						"          extendedAttributes=array(extendedAttributes))) ~> derivedColumn14",
						"AlterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          section_id as integer,",
						"          policy_id as integer,",
						"          coverage_id as integer,",
						"          location_id as integer,",
						"          limit_id as integer,",
						"          deductible_id as integer,",
						"          insurableobject_id as integer,",
						"          json_data as string,",
						"          extendedattributes as string,",
						"          section_code as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['policy_id','section_id'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> targetSection",
						"source2 sink(validateSchema: false,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     store: 'cache',",
						"     format: 'inline',",
						"     output: false,",
						"     saveOrder: 1) ~> sink2"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_bpa_cfa_limits')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Target Stage Data Flows/cfa"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "bpa_CFA_product_json",
								"type": "DatasetReference"
							},
							"name": "source2"
						},
						{
							"dataset": {
								"referenceName": "ds_BPA_limit",
								"type": "DatasetReference"
							},
							"name": "pkey"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_BPA_limit",
								"type": "DatasetReference"
							},
							"name": "limitMeta"
						},
						{
							"name": "nextPkey"
						}
					],
					"transformations": [
						{
							"name": "flatten1"
						},
						{
							"name": "derivedColumn3"
						},
						{
							"name": "select2"
						},
						{
							"name": "surrogateKey1"
						},
						{
							"name": "flatten3"
						},
						{
							"name": "derivedColumn4"
						}
					],
					"scriptLines": [
						"source(output(",
						"          BroadLine as string,",
						"          Sections as (Code as string, CoverageGroups as (CoverageLevel as string, Coverages as (Code as string, CoverageType as string, Deductible as (DeductibleValues as (ValueCode as string, ValueText as string)[], DefaultValue as string, InputType as string, Name as string, TypeCode as string, ValueType as string)[], Description as string, DisplayName as string, IsDefault as boolean, IsMandatory as boolean, Level as string, Limit as (DefaultValue as string, InputType as string, LimitValues as (ValueCode as string, ValueText as string)[], Max as double, Min as double, Name as string, PercentageOf as string, TypeCode as string, ValueType as string)[], SequenceNumber as short)[], DisplayName as string, GroupCode as string, IsMandatory as boolean, SequenceNumber as short)[], DisplayName as string, IsMandatory as boolean, IsPrimary as boolean, IsSharedCarrier as boolean, LOB as string, SequenceNumber as short)[]",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     documentForm: 'singleDocument') ~> source2",
						"source(output(",
						"          limit_id as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: ('select COALESCE(MAX(limit_id),0) as limit_id from bpa_limit_detail'),",
						"     format: 'query') ~> pkey",
						"source2 foldDown(unroll(Sections.CoverageGroups, Sections),",
						"     mapColumn(",
						"          BroadLine,",
						"          CoverageGroups = Sections.CoverageGroups,",
						"          Coverages = Sections.CoverageGroups.Coverages,",
						"          covGrpName = Sections.CoverageGroups.DisplayName,",
						"          GroupCode = Sections.CoverageGroups.GroupCode,",
						"          Code = Sections.Code",
						"     ),",
						"     skipDuplicateMapInputs: false,",
						"     skipDuplicateMapOutputs: false) ~> flatten1",
						"flatten3 derive(secCode = secCode,",
						"          limitName = Limit.Name,",
						"          limitTypeCode = Limit.TypeCode,",
						"          limitValueType = Limit.ValueType) ~> derivedColumn3",
						"derivedColumn3 select(mapColumn(",
						"          coverageCode = CoverageCode,",
						"          secCode,",
						"          limitName,",
						"          limitTypeCode,",
						"          limitValueType,",
						"          coverage_group_code = groupCode",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select2",
						"select2 keyGenerate(output(pkey as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> surrogateKey1",
						"flatten1 foldDown(unroll(Coverages.Limit, Coverages),",
						"     mapColumn(",
						"          BroadLine,",
						"          CoverageCode = Coverages.Code,",
						"          Limit = Coverages.Limit,",
						"          secCode = Code,",
						"          coverageName = Coverages.DisplayName,",
						"          covGrpName,",
						"          groupCode = GroupCode",
						"     ),",
						"     skipDuplicateMapInputs: false,",
						"     skipDuplicateMapOutputs: false) ~> flatten3",
						"surrogateKey1 derive(limit_id = nextPkey#outputs()[1].limit_id + pkey) ~> derivedColumn4",
						"derivedColumn4 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          limit_id as long,",
						"          coverageCode as string,",
						"          secCode as string,",
						"          limitValueType as string,",
						"          limitTypeCode as string,",
						"          limitName as string,",
						"          coverage_group_code as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> limitMeta",
						"pkey sink(validateSchema: false,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     store: 'cache',",
						"     format: 'inline',",
						"     output: false,",
						"     saveOrder: 1) ~> nextPkey"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_bpa_product_Ref')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Target Stage Data Flows"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "bpa_emp_product",
								"type": "DatasetReference"
							},
							"name": "source2"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_BPA_limit",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "flatten1"
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "select1"
						},
						{
							"name": "flatten2"
						},
						{
							"name": "derivedColumn2"
						},
						{
							"name": "derivedColumn3"
						},
						{
							"name": "select2"
						},
						{
							"name": "surrogateKey1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          BroadLine as string,",
						"          Sections as (Code as string, DisplayName as string, Description as string, LOB as string, SequenceNumber as integer, IsPrimary as boolean, IsMandatory as boolean, Coverages as (Code as string, DisplayName as string, CoverageType as string, Limit as (TypeCode as string, Min as double, Max as integer, ValueType as string, InputType as string, Name as string)[], Level as string, IsMandatory as boolean, IsDefault as boolean)[], IsSharedCarrier as boolean)[]",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     documentForm: 'singleDocument') ~> source2",
						"source2 foldDown(unroll(Sections.Coverages.Limit, Sections.Coverages),",
						"     mapColumn(",
						"          BroadLine,",
						"          Coverages = Sections.Coverages",
						"     ),",
						"     skipDuplicateMapInputs: false,",
						"     skipDuplicateMapOutputs: false) ~> flatten1",
						"flatten1 derive(derviedCoverages = Coverages) ~> derivedColumn1",
						"derivedColumn1 select(mapColumn(",
						"          coverageCode = derviedCoverages.Code,",
						"          CoverageLimits = derviedCoverages.Limit",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"select1 foldDown(unroll(CoverageLimits, CoverageLimits),",
						"     mapColumn(",
						"          coverageCode,",
						"          CoverageLimits",
						"     ),",
						"     skipDuplicateMapInputs: false,",
						"     skipDuplicateMapOutputs: false) ~> flatten2",
						"flatten2 derive(CoverageLimits = CoverageLimits) ~> derivedColumn2",
						"derivedColumn2 derive(secCode = coverageCode,",
						"          limitName = CoverageLimits.Name,",
						"          limitTypeCode = CoverageLimits.TypeCode,",
						"          limitValueType = CoverageLimits.ValueType) ~> derivedColumn3",
						"derivedColumn3 select(mapColumn(",
						"          coverageCode,",
						"          secCode,",
						"          limitName,",
						"          limitTypeCode,",
						"          limitValueType",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select2",
						"select2 keyGenerate(output(limit_id as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> surrogateKey1",
						"surrogateKey1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          limit_id as long,",
						"          coverageCode as string,",
						"          secCode as string,",
						"          limitValueType as string,",
						"          limitTypeCode as string,",
						"          limitName as string,",
						"          coverage_group_code as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink1"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_clientPartToBlank')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Target Stage Data Flows"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_stage_policy",
								"type": "DatasetReference"
							},
							"name": "policy"
						},
						{
							"dataset": {
								"referenceName": "insuredDetails",
								"type": "DatasetReference"
							},
							"name": "ecmInsured"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_stage_policy",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "AlterRow1"
						},
						{
							"name": "join1"
						},
						{
							"name": "derivedColumn2"
						},
						{
							"name": "derivedColumn3"
						},
						{
							"name": "select1"
						},
						{
							"name": "insuredSelect"
						},
						{
							"name": "derivedColumn4"
						},
						{
							"name": "derivedColumn5"
						}
					],
					"scriptLines": [
						"source(output(",
						"          policy_id as integer,",
						"          policy_number as string,",
						"          json_data as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> policy",
						"source(output(",
						"          PolicyPrefix as string,",
						"          Policy as string,",
						"          Policy_Sequence as string,",
						"          RowStatus as string,",
						"          EffectiveDate as timestamp,",
						"          ExpirationDate as timestamp,",
						"          LocationNumber as string,",
						"          LocationUnitNumber as string,",
						"          InsuredNumber as integer,",
						"          InsuredType as string,",
						"          InsuredSubType as string,",
						"          LinkToApplicant as string,",
						"          FirstName as string,",
						"          MiddleName as string,",
						"          LastName as string,",
						"          NameSuffix as string,",
						"          CorporateName as string,",
						"          DBACode as string,",
						"          AlternateName as string,",
						"          MailingAddress1 as string,",
						"          MailingAddress2 as string,",
						"          MailingCity as string,",
						"          MailingState as string,",
						"          MailingZipCode as string,",
						"          MailingCountryCode as string,",
						"          DOB as date,",
						"          Relationship as string,",
						"          ExcludedDate as date,",
						"          ActiveMilitary as string,",
						"          SubTypeOther as string,",
						"          ID as integer,",
						"          DataSource as string,",
						"          DW_InsertDate as date",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> ecmInsured",
						"select1 alterRow(updateIf(!isNull(policy_id))) ~> AlterRow1",
						"policy, insuredSelect join(policy_number == Policy,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"derivedColumn5 derive(json_data = replace(json_data, '\"clientParticipant\":[]', concat('\"clientParticipant\":',toString(clientArray)))) ~> derivedColumn2",
						"join1 derive(clientParticipant = @(party=@(name=@(givenName=replace(trim(CorporateName),'\"',''),",
						"          surname=replace(trim(CorporateName),'\"','')),",
						"          partyTypeCode='person',",
						"          person=@(name=@(givenName=replace(trim(CorporateName),'\"',''),",
						"          surname=replace(trim(CorporateName),'\"','')))),",
						"          subRoleCode='primaryInsured',",
						"          roleCode='insured')) ~> derivedColumn3",
						"derivedColumn4 select(mapColumn(",
						"          policy_id,",
						"          policy_number,",
						"          json_data",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"ecmInsured select(mapColumn(",
						"          PolicyPrefix,",
						"          Policy,",
						"          FirstName,",
						"          MiddleName,",
						"          LastName,",
						"          NameSuffix,",
						"          CorporateName,",
						"          AlternateName",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> insuredSelect",
						"derivedColumn2 derive(json_data = replace(json_data, '2023-12-12', '2023-12-12')) ~> derivedColumn4",
						"derivedColumn3 derive(clientArray = array(clientParticipant)) ~> derivedColumn5",
						"AlterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          policy_id as integer,",
						"          policy_number as string,",
						"          json_data as string",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['policy_id'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink1"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_ratefilingClientReport')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Target Stage Data Flows"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_target_rater_report",
								"type": "DatasetReference"
							},
							"name": "insReport"
						},
						{
							"dataset": {
								"referenceName": "ECMBPA_COV_MAP",
								"type": "DatasetReference"
							},
							"name": "source1"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRisk",
								"type": "DatasetReference"
							},
							"name": "source2"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policy",
								"type": "DatasetReference"
							},
							"name": "source3"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_target_rater_report",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "filter1"
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "join1"
						},
						{
							"name": "join2"
						},
						{
							"name": "join3"
						},
						{
							"name": "select1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          source_policy_number as string,",
						"          bpa_policy_ref as string,",
						"          transaction_type as string,",
						"          source_coverage_code as string,",
						"          target_coverage_code as string,",
						"          source_insurable_object as string,",
						"          source_premium as string,",
						"          bpa_premium as string,",
						"          product_code as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: '\\nselect qf.policy_number source_policy_number,qf.policy_reference as bpa_policy_ref,rp.transaction_type,\\nrp.source_coverage_code ,rp.target_coverage_code,rp.source_insurable_object,rp.source_premium,rp.target_premium as bpa_premium,rp.product_code\\nfrom quote_info qf join  rating_report rp on rp.source_policy_number=qf.policy_number',",
						"     format: 'query') ~> insReport",
						"source(output(",
						"          COV_SEQ as string,",
						"          BPA_SECTION_CODE as string,",
						"          COVERAGE_CODE as string,",
						"          COVERAGE_CODE_DES as string,",
						"          BPA_COVERAGE_CODES as string,",
						"          BPA_COVERAGES as string,",
						"          COVERAGES as string,",
						"          BPA_PRODUCT_CODE as string,",
						"          SI_NO as string,",
						"          id as long,",
						"          BPA_SEC_NAME as string,",
						"          SOURCE_PRODUCT_CODE as string,",
						"          bpa_coverage_group as string,",
						"          bpa_coverage_level as string,",
						"          bpa_coverage_type as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> source1",
						"source(output(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_NUMBER as string,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          RISK_IS_ACTIVE_YN as string,",
						"          RISK_EFF_DATE as timestamp,",
						"          RISK_EXP_DATE as timestamp,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> source2",
						"source(output(",
						"          POLICY_ID as long,",
						"          POLICY_VID as long,",
						"          REINSURANCE_DAC as string,",
						"          PREVIOUS_INSURANCE_NO_REMARKS as string,",
						"          AGENCY_ID as long,",
						"          AGENCY_OVID as long,",
						"          PRODUCER_ID as long,",
						"          PRODUCER_OVID as long,",
						"          PRODUCER_CONTACT_ID as long,",
						"          PRODUCER_CONTACT_OVID as long,",
						"          POLICY_NUMBER as string,",
						"          ENTITY_TYPE as string,",
						"          ENTITY_STATUS as string,",
						"          IS_RENEWAL_YN as string,",
						"          REVISION_NUMBER as integer,",
						"          PRODUCT_ID as long,",
						"          PRODUCT_OVID as long,",
						"          POLICY_EFFECTIVE_DATE as timestamp,",
						"          POLICY_EXPIRATION_DATE as timestamp,",
						"          NON_RENEWAL_CODE as string,",
						"          POLICY_RENEWED_YN as string,",
						"          CANCELLATION_DATE as timestamp,",
						"          IS_RENEWABLE_YN as string,",
						"          PREVIOUS_INSURANCE_NO_REASON as string,",
						"          POLICY_STATUS as string,",
						"          CANCEL_REASON_CODE as string,",
						"          CANCEL_REASON_DESCRIPTION as string,",
						"          CANCEL_METHOD as string,",
						"          CANCEL_METHOD_DESC as string,",
						"          LOSE_REASON_CODE as string,",
						"          LOSE_REASON_DESC as string,",
						"          DECLINATION_REASON_CODE as string,",
						"          DECLINATION_REASON_DESC as string,",
						"          NOT_WRITTEN_REASON_CODE as string,",
						"          NOT_WRITTEN_REASON_DESC as string,",
						"          POLICY_STATE_CODE as string,",
						"          PROGRAM_ID as long,",
						"          PROGRAM_OVID as long,",
						"          BILLING_TYPE_CODE as string,",
						"          UNDERWRITING_COMPANY_ID as long,",
						"          UNDERWRITING_COMPANY_OVID as long,",
						"          SUBMISSION_ID as long,",
						"          PREVIOUS_INSURANCE_YN as string,",
						"          LEGACY_POLICY_NUMBER as string,",
						"          STATE as string,",
						"          POLICY_POLICY as integer,",
						"          PAYMENT_PLAN as string,",
						"          APPLICATION_RECEIVED_DATE as timestamp,",
						"          INCEPTION_DATE as timestamp,",
						"          BILL_TYPE as string,",
						"          FORMS_LANGUAGE as string,",
						"          BASE_CURRENCY as string,",
						"          INVOICE_CURRENCY as string,",
						"          PREVIOUS_POLICY_ID as long,",
						"          PREVIOUS_POLICY_OVID as long,",
						"          REVISED_FROM_POLICY_ID as long,",
						"          REVISED_FROM_POLICY_OVID as long,",
						"          OPERATING_COMPANY_ID as long,",
						"          OPERATING_COMPANY_OVID as long,",
						"          CONVERTED_FROM_ID as long,",
						"          CONVERTED_FROM_OVID as long,",
						"          INSTALLMENT_RENEWAL as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> source3",
						"source1 filter(SOURCE_PRODUCT_CODE == 'EMP') ~> filter1",
						"filter1 derive(COVERAGE_CODE = split(COVERAGE_CODE, '0')[2]+'-'+COV_SEQ) ~> derivedColumn1",
						"insReport, derivedColumn1 join(source_coverage_code == COVERAGE_CODE,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"source2, source3 join(source2@POLICY_ID == source3@POLICY_ID,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join2",
						"join1, join2 join(source_policy_number == POLICY_NUMBER",
						"     && source_insurable_object == toString(RISK_ID),",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join3",
						"join3 select(mapColumn(",
						"          source_policy_number,",
						"          bpa_policy_ref,",
						"          transaction_type,",
						"          COVERAGES,",
						"          RISK_NUMBER,",
						"          source_coverage_code,",
						"          target_coverage_code,",
						"          source_insurable_object,",
						"          source_premium,",
						"          bpa_premium,",
						"          product_code,",
						"          COV_SEQ,",
						"          BPA_SECTION_CODE,",
						"          COVERAGE_CODE,",
						"          COVERAGE_CODE_DES,",
						"          BPA_COVERAGE_CODES,",
						"          BPA_COVERAGES,",
						"          BPA_PRODUCT_CODE,",
						"          BPA_SEC_NAME,",
						"          RISK_TYPE_CD",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"select1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          source_policy_number as string,",
						"          stage_policy_number as string,",
						"          target_policy_number as string,",
						"          transaction_type as string,",
						"          source_coverage_code as string,",
						"          target_coverage_code as string,",
						"          source_insurable_object as string,",
						"          target_insurable_object as string,",
						"          target_section as string,",
						"          source_premium as string,",
						"          target_premium as string,",
						"          batch_id as integer,",
						"          bpa_tenant_id as string,",
						"          product_code as string,",
						"          created_at as timestamp,",
						"          updated_at as timestamp,",
						"          horse_breed as string,",
						"          horse_sex as string,",
						"          use as string,",
						"          age_in_years as string,",
						"          year_born as string,",
						"          purchase_date as string,",
						"          purchase_price as string,",
						"          requested_limit as string,",
						"          location_state as string,",
						"          target_section_name as string,",
						"          target_coverage_name as string,",
						"          source_coverage_name as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink1"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_source_POL_TX_Deductible')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Source Stage Data Flows/txnDataFlow"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_txnBridge",
								"type": "DatasetReference"
							},
							"name": "StagingTxnBridge"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_polTxn",
								"type": "DatasetReference"
							},
							"name": "stgPolTxn"
						},
						{
							"dataset": {
								"referenceName": "ds_source_FactCoverageDeductible",
								"type": "DatasetReference"
							},
							"name": "fcp"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policy",
								"type": "DatasetReference"
							},
							"name": "polPolicy"
						},
						{
							"dataset": {
								"referenceName": "ds_source_POL_TX_LIMIT_DED_OPT",
								"type": "DatasetReference"
							},
							"name": "PolTxnLimitDedMaxId"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_source_POL_TX_LIMIT_DED_OPT",
								"type": "DatasetReference"
							},
							"name": "PolTxLimitDedOptLimit2"
						},
						{
							"name": "polTxnLDCache"
						}
					],
					"transformations": [
						{
							"name": "flowlet3",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "ded1"
						},
						{
							"name": "derivedColumn2"
						},
						{
							"name": "select1"
						},
						{
							"name": "select2"
						},
						{
							"name": "derivedColumn4"
						},
						{
							"name": "filter1"
						},
						{
							"name": "surrogateKey1"
						},
						{
							"name": "join1"
						},
						{
							"name": "derivedColumn5"
						},
						{
							"name": "join2"
						},
						{
							"name": "distinctRows"
						}
					],
					"scriptLines": [
						"parameters{",
						"     policyPrefix as string,",
						"     policies as string[]",
						"}",
						"source(output(",
						"          TX_BRIDGE_ID as long,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          RISK_ID as long,",
						"          RISK_OVID as long,",
						"          COVERAGE_ID as long,",
						"          COVERAGE_VID as long,",
						"          TX_ID as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select distinct TX_BRIDGE_ID,POLICY_ID,POLICY_OVID,RISK_ID,RISK_OVID,COVERAGE_ID,COVERAGE_VID,TX_ID from POL_TX_BRIDGE',",
						"     format: 'query') ~> StagingTxnBridge",
						"source(output(",
						"          TX_ID as long,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          TX_CODE as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select distinct TX_ID,POLICY_ID,POLICY_OVID,TX_CODE from POL_TX  ',",
						"     format: 'query') ~> stgPolTxn",
						"source(output(",
						"          Policy as string,",
						"          Policy_Sequence as string,",
						"          PolicyPrefix as string,",
						"          ARICCoverageCode as string,",
						"          ARICCoverageDescription as string,",
						"          CoverageDescription as string,",
						"          CoverageInternalCode as string,",
						"          LocationState as string,",
						"          ARICLOB as string,",
						"          LocationNumber as string,",
						"          LocationUnitNumber as string,",
						"          ARICCoverageSequence as integer,",
						"          CoveragePart as string,",
						"          CoverageAddDate as timestamp,",
						"          DESDSC as string,",
						"          DEDESC as string,",
						"          DeductibleCode as string,",
						"          DeductibleAmount1Type as string,",
						"          DeductibleAmount1 as decimal(7,0),",
						"          DeductibleAmount2Type as string,",
						"          DeductibleAmount2 as decimal(7,0)",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from [Fact_Coverage_Deductible] where PolicyPrefix='{$policyPrefix}'\"  +iif(size($policies) >0&& size($policies) ==1&&$policies[1] =='','','and policy in ('+dropLeft(toString(reduce($policies, \"'\", #acc + \",'\" + #item +\"'\", #result)), 2)+')')),",
						"     format: 'query') ~> fcp",
						"source(output(",
						"          POLICY_ID as long,",
						"          POLICY_VID as long,",
						"          REINSURANCE_DAC as string,",
						"          PREVIOUS_INSURANCE_NO_REMARKS as string,",
						"          AGENCY_ID as long,",
						"          AGENCY_OVID as long,",
						"          PRODUCER_ID as long,",
						"          PRODUCER_OVID as long,",
						"          PRODUCER_CONTACT_ID as long,",
						"          PRODUCER_CONTACT_OVID as long,",
						"          POLICY_NUMBER as string,",
						"          ENTITY_TYPE as string,",
						"          ENTITY_STATUS as string,",
						"          IS_RENEWAL_YN as string,",
						"          REVISION_NUMBER as integer,",
						"          PRODUCT_ID as long,",
						"          PRODUCT_OVID as long,",
						"          POLICY_EFFECTIVE_DATE as timestamp,",
						"          POLICY_EXPIRATION_DATE as timestamp,",
						"          NON_RENEWAL_CODE as string,",
						"          POLICY_RENEWED_YN as string,",
						"          CANCELLATION_DATE as timestamp,",
						"          IS_RENEWABLE_YN as string,",
						"          PREVIOUS_INSURANCE_NO_REASON as string,",
						"          POLICY_STATUS as string,",
						"          CANCEL_REASON_CODE as string,",
						"          CANCEL_REASON_DESCRIPTION as string,",
						"          CANCEL_METHOD as string,",
						"          CANCEL_METHOD_DESC as string,",
						"          LOSE_REASON_CODE as string,",
						"          LOSE_REASON_DESC as string,",
						"          DECLINATION_REASON_CODE as string,",
						"          DECLINATION_REASON_DESC as string,",
						"          NOT_WRITTEN_REASON_CODE as string,",
						"          NOT_WRITTEN_REASON_DESC as string,",
						"          POLICY_STATE_CODE as string,",
						"          PROGRAM_ID as long,",
						"          PROGRAM_OVID as long,",
						"          BILLING_TYPE_CODE as string,",
						"          UNDERWRITING_COMPANY_ID as long,",
						"          UNDERWRITING_COMPANY_OVID as long,",
						"          SUBMISSION_ID as long,",
						"          PREVIOUS_INSURANCE_YN as string,",
						"          LEGACY_POLICY_NUMBER as string,",
						"          STATE as string,",
						"          POLICY_POLICY as integer,",
						"          PAYMENT_PLAN as string,",
						"          APPLICATION_RECEIVED_DATE as timestamp,",
						"          INCEPTION_DATE as timestamp,",
						"          BILL_TYPE as string,",
						"          FORMS_LANGUAGE as string,",
						"          BASE_CURRENCY as string,",
						"          INVOICE_CURRENCY as string,",
						"          PREVIOUS_POLICY_ID as long,",
						"          PREVIOUS_POLICY_OVID as long,",
						"          REVISED_FROM_POLICY_ID as long,",
						"          REVISED_FROM_POLICY_OVID as long,",
						"          OPERATING_COMPANY_ID as long,",
						"          OPERATING_COMPANY_OVID as long,",
						"          CONVERTED_FROM_ID as long,",
						"          CONVERTED_FROM_OVID as long,",
						"          INSTALLMENT_RENEWAL as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select * from POL_POLICY ',",
						"     format: 'query') ~> polPolicy",
						"source(output(",
						"          limit_id as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select MAX (TX_LIMIT_DED_OPT_ID)  as limit_id  from POL_TX_LIMIT_DED_OPT',",
						"     format: 'query') ~> PolTxnLimitDedMaxId",
						"derivedColumn4 compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet3@(output1)",
						"distinctRows derive(TX_ID = TX_ID,",
						"          RISK_ID = RISK_ID,",
						"          TX_BRIDGE_ID = TX_BRIDGE_ID,",
						"          RISK_OVID = RISK_OVID,",
						"          POLICY_ID = POLICY_ID,",
						"          POLICY_OVID = POLICY_OVID,",
						"          COVERAGE_ID = COVERAGE_ID,",
						"          COVERAGE_OVID = COVERAGE_VID) ~> ded1",
						"join1 derive(Policy_Sequence_tx = split(TX_CODE,'-')[1],",
						"          LocationNumber_tx = split(TX_CODE,'-')[2],",
						"          LocationUnitNumber_tx = split(TX_CODE,'-')[3],",
						"          ARICGroupCode_tx = split(TX_CODE,'-')[4],",
						"          PrimaryPremiumStateCode_tx = split(TX_CODE,'-')[5],",
						"          ARICLOB_tx = split(TX_CODE,'-')[6],",
						"          ARICCoverageCode_tx = split(TX_CODE,'-')[7],",
						"          ARICCoverageSequence_tx = split(TX_CODE,'-')[8]) ~> derivedColumn2",
						"derivedColumn2 select(mapColumn(",
						"          TX_BRIDGE_ID,",
						"          POLICY_ID = StagingTxnBridge@POLICY_ID,",
						"          POLICY_OVID = StagingTxnBridge@POLICY_OVID,",
						"          TX_ID = StagingTxnBridge@TX_ID,",
						"          RISK_ID,",
						"          RISK_OVID,",
						"          COVERAGE_ID,",
						"          COVERAGE_VID,",
						"          TX_ID = stgPolTxn@TX_ID,",
						"          POLICY_ID = stgPolTxn@POLICY_ID,",
						"          POLICY_OVID = stgPolTxn@POLICY_OVID,",
						"          TX_CODE,",
						"          Policy_Sequence_tx,",
						"          LocationNumber_tx,",
						"          LocationUnitNumber_tx,",
						"          ARICGroupCode_tx,",
						"          PrimaryPremiumStateCode_tx,",
						"          ARICLOB_tx,",
						"          ARICCoverageCode_tx,",
						"          ARICCoverageSequence_tx",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"fcp select(mapColumn(",
						"          Policy,",
						"          Policy_Sequence,",
						"          PolicyPrefix,",
						"          ARICCoverageCode,",
						"          ARICCoverageDescription,",
						"          CoverageDescription,",
						"          CoverageInternalCode,",
						"          LocationState,",
						"          ARICLOB,",
						"          LocationNumber,",
						"          LocationUnitNumber,",
						"          ARICCoverageSequence,",
						"          CoveragePart,",
						"          CoverageAddDate,",
						"          DESDSC,",
						"          DEDESC,",
						"          DeductibleCode,",
						"          DeductibleAmount1Type,",
						"          DeductibleAmount1,",
						"          DeductibleAmount2Type,",
						"          DeductibleAmount2",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select2",
						"surrogateKey1 derive(LIMIT_DED_OPT_TYPE_ID = 1,",
						"          LDO_CODE = DeductibleCode,",
						"          LDO_VALUE = DeductibleAmount1,",
						"          LDO_TXT = DEDESC,",
						"          TX_LIMIT_DED_OPT_ID = pkey + polTxnLDCache#outputs()[1].limit_id,",
						"          LDO_FLAG = 'D') ~> derivedColumn4",
						"join2 filter(!isNull(Policy)) ~> filter1",
						"ded1 keyGenerate(output(pkey as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> surrogateKey1",
						"StagingTxnBridge, stgPolTxn join(StagingTxnBridge@TX_ID == stgPolTxn@TX_ID,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"PolTxnLimitDedMaxId derive(limit_id = iifNull(limit_id, 0, limit_id)) ~> derivedColumn5",
						"select1, select2 join(Policy_Sequence_tx == Policy_Sequence",
						"     && LocationNumber_tx == LocationNumber",
						"     && LocationUnitNumber_tx == LocationUnitNumber",
						"     && ARICLOB_tx == ARICLOB",
						"     && ARICCoverageCode_tx == ARICCoverageCode",
						"     && ARICCoverageSequence_tx == toString(ARICCoverageSequence),",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join2",
						"filter1 aggregate(groupBy(TX_BRIDGE_ID),",
						"     each(match(name!='TX_BRIDGE_ID'), $$ = first($$))) ~> distinctRows",
						"flowlet3@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          TX_LIMIT_DED_OPT_ID as long,",
						"          TX_ID as long,",
						"          LOCATION_ID as long,",
						"          LOCATION_OVID as long,",
						"          SECTION_ID as long,",
						"          SECTION_OVID as long,",
						"          TX_BRIDGE_ID as long,",
						"          RISK_ID as long,",
						"          RISK_OVID as long,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          LIMIT_DED_OPT_TYPE_ID as long,",
						"          LDO_FLAG as string,",
						"          LDO_CODE as string,",
						"          LIMIT_OCCURRENCE_FLAG as string,",
						"          LDO_VALUE as long,",
						"          LDO_VALUE_CCY_CODE as string,",
						"          LDO_PERCENTAGE as decimal(6,4),",
						"          LDO_TEXT as string,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          DATA_HASH as binary,",
						"          SOURCE_KEY as string,",
						"          COVERAGE_ID as long,",
						"          COVERAGE_OVID as long",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> PolTxLimitDedOptLimit2",
						"derivedColumn5 sink(validateSchema: false,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     store: 'cache',",
						"     format: 'inline',",
						"     output: false,",
						"     saveOrder: 1) ~> polTxnLDCache"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_source_POL_TX_LIMIT1')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Source Stage Data Flows/txnDataFlow"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_txnBridge",
								"type": "DatasetReference"
							},
							"name": "StagingTxnBridge"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_polTxn",
								"type": "DatasetReference"
							},
							"name": "stgPolTxn"
						},
						{
							"dataset": {
								"referenceName": "ds_source_Fact_Coverage_Premium",
								"type": "DatasetReference"
							},
							"name": "fcp"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policy",
								"type": "DatasetReference"
							},
							"name": "polPolicy"
						},
						{
							"dataset": {
								"referenceName": "ds_source_POL_TX_LIMIT_DED_OPT",
								"type": "DatasetReference"
							},
							"name": "source1"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_source_POL_TX_LIMIT_DED_OPT",
								"type": "DatasetReference"
							},
							"name": "PolTxLimitDedOptLimit2"
						},
						{
							"name": "limitKeyCache"
						}
					],
					"transformations": [
						{
							"name": "flowlet3",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "limit1"
						},
						{
							"name": "lookup2"
						},
						{
							"name": "derivedColumn2"
						},
						{
							"name": "select1"
						},
						{
							"name": "select2"
						},
						{
							"name": "derivedColumn4"
						},
						{
							"name": "select3"
						},
						{
							"name": "derivedColumn5"
						},
						{
							"name": "surrogateKey1"
						},
						{
							"name": "filter1"
						},
						{
							"name": "join1"
						},
						{
							"name": "join2"
						}
					],
					"scriptLines": [
						"parameters{",
						"     policyPrefix as string,",
						"     policies as string[]",
						"}",
						"source(output(",
						"          TX_BRIDGE_ID as long,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          RISK_ID as long,",
						"          RISK_OVID as long,",
						"          COVERAGE_ID as long,",
						"          COVERAGE_VID as long,",
						"          TX_ID as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select distinct TX_BRIDGE_ID,POLICY_ID,POLICY_OVID,RISK_ID,RISK_OVID,COVERAGE_ID,COVERAGE_VID,TX_ID from POL_TX_BRIDGE\\n',",
						"     format: 'query') ~> StagingTxnBridge",
						"source(output(",
						"          TX_ID as long,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          TX_CODE as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select distinct TX_ID,POLICY_ID,POLICY_OVID,TX_CODE from POL_TX ',",
						"     format: 'query') ~> stgPolTxn",
						"source(output(",
						"          Policy as string,",
						"          Policy_Sequence as string,",
						"          PolicyPrefix as string,",
						"          ARICLOB as string,",
						"          ARICGroupCode as string,",
						"          Description as string,",
						"          Product as string,",
						"          ARICCoverageCode as string,",
						"          ARICCoverageDescription as string,",
						"          PrimaryPremiumStateCode as string,",
						"          LocationNumber as string,",
						"          LocationUnitNumber as string,",
						"          ARICCoverageSequence as integer,",
						"          CoveragePart as string,",
						"          CoverageAddDate as timestamp,",
						"          CoverageDescription as string,",
						"          Limit1 as decimal(38,0),",
						"          Limit2 as decimal(38,0),",
						"          PremiumAmount as decimal(38,2)",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from Fact_Coverage_Premium where PolicyPrefix='{$policyPrefix}'\"),",
						"     format: 'query') ~> fcp",
						"source(output(",
						"          POLICY_ID as long,",
						"          POLICY_VID as long,",
						"          REINSURANCE_DAC as string,",
						"          PREVIOUS_INSURANCE_NO_REMARKS as string,",
						"          AGENCY_ID as long,",
						"          AGENCY_OVID as long,",
						"          PRODUCER_ID as long,",
						"          PRODUCER_OVID as long,",
						"          PRODUCER_CONTACT_ID as long,",
						"          PRODUCER_CONTACT_OVID as long,",
						"          POLICY_NUMBER as string,",
						"          ENTITY_TYPE as string,",
						"          ENTITY_STATUS as string,",
						"          IS_RENEWAL_YN as string,",
						"          REVISION_NUMBER as integer,",
						"          PRODUCT_ID as long,",
						"          PRODUCT_OVID as long,",
						"          POLICY_EFFECTIVE_DATE as timestamp,",
						"          POLICY_EXPIRATION_DATE as timestamp,",
						"          NON_RENEWAL_CODE as string,",
						"          POLICY_RENEWED_YN as string,",
						"          CANCELLATION_DATE as timestamp,",
						"          IS_RENEWABLE_YN as string,",
						"          PREVIOUS_INSURANCE_NO_REASON as string,",
						"          POLICY_STATUS as string,",
						"          CANCEL_REASON_CODE as string,",
						"          CANCEL_REASON_DESCRIPTION as string,",
						"          CANCEL_METHOD as string,",
						"          CANCEL_METHOD_DESC as string,",
						"          LOSE_REASON_CODE as string,",
						"          LOSE_REASON_DESC as string,",
						"          DECLINATION_REASON_CODE as string,",
						"          DECLINATION_REASON_DESC as string,",
						"          NOT_WRITTEN_REASON_CODE as string,",
						"          NOT_WRITTEN_REASON_DESC as string,",
						"          POLICY_STATE_CODE as string,",
						"          PROGRAM_ID as long,",
						"          PROGRAM_OVID as long,",
						"          BILLING_TYPE_CODE as string,",
						"          UNDERWRITING_COMPANY_ID as long,",
						"          UNDERWRITING_COMPANY_OVID as long,",
						"          SUBMISSION_ID as long,",
						"          PREVIOUS_INSURANCE_YN as string,",
						"          LEGACY_POLICY_NUMBER as string,",
						"          POLICY_POLICY as short,",
						"          PAYMENT_PLAN as string,",
						"          APPLICATION_RECEIVED_DATE as timestamp,",
						"          INCEPTION_DATE as timestamp,",
						"          BILL_TYPE as string,",
						"          FORMS_LANGUAGE as string,",
						"          BASE_CURRENCY as string,",
						"          INVOICE_CURRENCY as string,",
						"          PREVIOUS_POLICY_ID as long,",
						"          PREVIOUS_POLICY_OVID as long,",
						"          REVISED_FROM_POLICY_ID as long,",
						"          REVISED_FROM_POLICY_OVID as long,",
						"          OPERATING_COMPANY_ID as long,",
						"          OPERATING_COMPANY_OVID as long,",
						"          CONVERTED_FROM_ID as long,",
						"          CONVERTED_FROM_OVID as long,",
						"          INSTALLMENT_RENEWAL as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from [dbo].[POL_POLICY] where ENTITY_TYPE ='{$policyPrefix}' \"+iif(size($policies) >0&& size($policies) ==1&&$policies[1] =='','','and policy_number in ('+dropLeft(toString(reduce($policies, \"'\", #acc + \",'\" + #item +\"'\", #result)), 2)+')')),",
						"     format: 'query') ~> polPolicy",
						"source(output(",
						"          limit_id as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select MAX (TX_LIMIT_DED_OPT_ID)  as limit_id  from POL_TX_LIMIT_DED_OPT',",
						"     format: 'query') ~> source1",
						"derivedColumn4 compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet3@(output1)",
						"filter1 derive(TX_ID = TX_ID,",
						"          RISK_ID = RISK_ID,",
						"          TX_BRIDGE_ID = TX_BRIDGE_ID,",
						"          POLICY_ID = POLICY_ID,",
						"          POLICY_OVID = POLICY_OVID,",
						"          COVERAGE_ID = COVERAGE_ID,",
						"          COVERAGE_OVID = COVERAGE_VID,",
						"          RISK_OVID = RISK_OVID) ~> limit1",
						"select1, fcp lookup(select1@Policy_Sequence == fcp@Policy_Sequence",
						"     && POLICY_NUMBER == Policy",
						"     && select1@LocationNumber == fcp@LocationNumber",
						"     && select1@LocationUnitNumber == fcp@LocationUnitNumber",
						"     && select1@PrimaryPremiumStateCode == fcp@PrimaryPremiumStateCode",
						"     && select1@ARICLOB == fcp@ARICLOB",
						"     && select1@ARICCoverageCode == fcp@ARICCoverageCode",
						"     && select1@ARICCoverageSequence == toString(fcp@ARICCoverageSequence)",
						"     && select1@ARICGroupCode == fcp@ARICGroupCode,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lookup2",
						"join2 derive(Policy_Sequence = split(TX_CODE,'-')[1],",
						"          LocationNumber = split(TX_CODE,'-')[2],",
						"          LocationUnitNumber = split(TX_CODE,'-')[3],",
						"          ARICGroupCode = split(TX_CODE,'-')[4],",
						"          PrimaryPremiumStateCode = split(TX_CODE,'-')[5],",
						"          ARICLOB = split(TX_CODE,'-')[6],",
						"          ARICCoverageCode = split(TX_CODE,'-')[7],",
						"          ARICCoverageSequence = split(TX_CODE,'-')[8]) ~> derivedColumn2",
						"derivedColumn2 select(mapColumn(",
						"          TX_BRIDGE_ID,",
						"          POLICY_ID = StagingTxnBridge@POLICY_ID,",
						"          POLICY_OVID = StagingTxnBridge@POLICY_OVID,",
						"          TX_ID = StagingTxnBridge@TX_ID,",
						"          RISK_ID,",
						"          RISK_OVID,",
						"          COVERAGE_ID,",
						"          COVERAGE_VID,",
						"          TX_ID = stgPolTxn@TX_ID,",
						"          POLICY_ID = stgPolTxn@POLICY_ID,",
						"          POLICY_OVID = stgPolTxn@POLICY_OVID,",
						"          TX_CODE,",
						"          POLICY_ID = polPolicy@POLICY_ID,",
						"          POLICY_VID,",
						"          POLICY_NUMBER,",
						"          Policy_Sequence,",
						"          LocationNumber,",
						"          LocationUnitNumber,",
						"          ARICGroupCode,",
						"          PrimaryPremiumStateCode,",
						"          ARICLOB,",
						"          ARICCoverageCode,",
						"          ARICCoverageSequence",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"fcp select(mapColumn(",
						"          Policy,",
						"          Policy_Sequence,",
						"          ARICLOB,",
						"          ARICGroupCode,",
						"          ARICCoverageCode,",
						"          ARICCoverageDescription,",
						"          PrimaryPremiumStateCode,",
						"          LocationNumber,",
						"          LocationUnitNumber,",
						"          ARICCoverageSequence,",
						"          CoverageDescription,",
						"          Limit1,",
						"          Limit2,",
						"          PremiumAmount",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select2",
						"surrogateKey1 derive(LIMIT_DED_OPT_TYPE_ID = 3,",
						"          LDO_CODE = 'Limit1',",
						"          LDO_VALUE = Limit1,",
						"          TX_LIMIT_DED_OPT_ID = pkey+limitKeyCache#outputs()[1].limit_id,",
						"          LDO_FLAG = '') ~> derivedColumn4",
						"limit1 select(mapColumn(",
						"          TX_BRIDGE_ID,",
						"          POLICY_ID,",
						"          POLICY_OVID,",
						"          TX_ID,",
						"          RISK_ID,",
						"          RISK_OVID,",
						"          COVERAGE_ID,",
						"          COVERAGE_VID,",
						"          TX_CODE,",
						"          POLICY_VID,",
						"          POLICY_NUMBER,",
						"          Policy,",
						"          Policy_Sequence = fcp@Policy_Sequence,",
						"          PolicyPrefix,",
						"          Description,",
						"          Product,",
						"          ARICCoverageDescription,",
						"          CoveragePart,",
						"          CoverageAddDate,",
						"          CoverageDescription,",
						"          Limit1,",
						"          Limit2,",
						"          PremiumAmount,",
						"          COVERAGE_OVID",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select3",
						"source1 derive(limit_id = iifNull(limit_id, 0, limit_id),",
						"          pkkey := limit_id) ~> derivedColumn5",
						"select3 keyGenerate(output(pkey as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> surrogateKey1",
						"lookup2 filter(!isNull(Policy)) ~> filter1",
						"StagingTxnBridge, stgPolTxn join(StagingTxnBridge@TX_ID == stgPolTxn@TX_ID,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"join1, polPolicy join(StagingTxnBridge@POLICY_ID == polPolicy@POLICY_ID,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join2",
						"flowlet3@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          TX_LIMIT_DED_OPT_ID as long,",
						"          TX_ID as long,",
						"          LOCATION_ID as long,",
						"          LOCATION_OVID as long,",
						"          SECTION_ID as long,",
						"          SECTION_OVID as long,",
						"          TX_BRIDGE_ID as long,",
						"          RISK_ID as long,",
						"          RISK_OVID as long,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          LIMIT_DED_OPT_TYPE_ID as long,",
						"          LDO_FLAG as string,",
						"          LDO_CODE as string,",
						"          LIMIT_OCCURRENCE_FLAG as string,",
						"          LDO_VALUE as long,",
						"          LDO_VALUE_CCY_CODE as string,",
						"          LDO_PERCENTAGE as decimal(6,4),",
						"          LDO_TEXT as string,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          DATA_HASH as binary,",
						"          SOURCE_KEY as string,",
						"          COVERAGE_ID as long,",
						"          COVERAGE_OVID as long",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> PolTxLimitDedOptLimit2",
						"derivedColumn5 sink(validateSchema: false,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     store: 'cache',",
						"     format: 'inline',",
						"     output: false,",
						"     saveOrder: 1) ~> limitKeyCache"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_source_POL_TX_LIMIT2')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Source Stage Data Flows/txnDataFlow"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_txnBridge",
								"type": "DatasetReference"
							},
							"name": "StagingTxnBridge"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_polTxn",
								"type": "DatasetReference"
							},
							"name": "stgPolTxn"
						},
						{
							"dataset": {
								"referenceName": "ds_source_Fact_Coverage_Premium",
								"type": "DatasetReference"
							},
							"name": "fcp"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policy",
								"type": "DatasetReference"
							},
							"name": "polPolicy"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_locationRiskBridge",
								"type": "DatasetReference"
							},
							"name": "risklocationBridge"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_source_POL_TX_LIMIT_DED_OPT",
								"type": "DatasetReference"
							},
							"name": "PolTxLimitDedOptLimit2"
						}
					],
					"transformations": [
						{
							"name": "flowlet3",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "limit1"
						},
						{
							"name": "lookup2"
						},
						{
							"name": "lookup3"
						},
						{
							"name": "derivedColumn2"
						},
						{
							"name": "select1"
						},
						{
							"name": "select2"
						},
						{
							"name": "derivedColumn4"
						},
						{
							"name": "surrogateKey1"
						},
						{
							"name": "select3"
						},
						{
							"name": "filter1"
						},
						{
							"name": "select4"
						},
						{
							"name": "lookup4"
						},
						{
							"name": "join1"
						}
					],
					"scriptLines": [
						"parameters{",
						"     policyPrefix as string",
						"}",
						"source(output(",
						"          TX_BRIDGE_ID as long,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          TX_ID as long,",
						"          SECTION_ID as long,",
						"          SECTION_VID as long,",
						"          RISK_ID as long,",
						"          RISK_OVID as long,",
						"          CLASSIFICATION_ID as long,",
						"          CLASSIFICATION_OVID as long,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          DATA_HASH as binary,",
						"          SOURCE_KEY as string,",
						"          COVERAGE_ID as long,",
						"          COVERAGE_VID as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> StagingTxnBridge",
						"source(output(",
						"          TX_ID as long,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          TX_CODE as string,",
						"          SUB_ACTIVITY as string,",
						"          ENDORSEMENT_SEQ_NO as integer,",
						"          IS_SYSTEM_GENERATED_YN as string,",
						"          ENDORSEMENT_CHANGES as string,",
						"          TRANSACTION_EFFECTIVE_DATE as timestamp,",
						"          TRANSACTION_EXPIRY_DATE as timestamp,",
						"          TRANSACTION_BOOK_FLAG_DATE as timestamp,",
						"          PARENT_TRANSACTION_ID as integer,",
						"          TRANSACTION_TYPE_CODE as string,",
						"          TYPE_OF_CHANGE as string,",
						"          TRANSACTION_CREATED_DATE as timestamp,",
						"          TRANSACTION_MODIFIED_DATE as timestamp,",
						"          TRANSACTION_DISPLAY_NAME as string,",
						"          TRANSACTION_PERIOD_PRORATION as decimal(19,9),",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          DATA_HASH as binary,",
						"          SOURCE_KEY as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> stgPolTxn",
						"source(output(",
						"          Policy as string,",
						"          Policy_Sequence as string,",
						"          PolicyPrefix as string,",
						"          ARICLOB as string,",
						"          ARICGroupCode as string,",
						"          Description as string,",
						"          Product as string,",
						"          ARICCoverageCode as string,",
						"          ARICCoverageDescription as string,",
						"          PrimaryPremiumStateCode as string,",
						"          LocationNumber as string,",
						"          LocationUnitNumber as string,",
						"          ARICCoverageSequence as integer,",
						"          CoveragePart as string,",
						"          CoverageAddDate as timestamp,",
						"          CoverageDescription as string,",
						"          Limit1 as decimal(38,0),",
						"          Limit2 as decimal(38,0),",
						"          PremiumAmount as decimal(38,2)",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from Fact_Coverage_Premium where PolicyPrefix='{$policyPrefix}'\"),",
						"     format: 'query') ~> fcp",
						"source(output(",
						"          POLICY_ID as long,",
						"          POLICY_VID as long,",
						"          REINSURANCE_DAC as string,",
						"          PREVIOUS_INSURANCE_NO_REMARKS as string,",
						"          AGENCY_ID as long,",
						"          AGENCY_OVID as long,",
						"          PRODUCER_ID as long,",
						"          PRODUCER_OVID as long,",
						"          PRODUCER_CONTACT_ID as long,",
						"          PRODUCER_CONTACT_OVID as long,",
						"          POLICY_NUMBER as string,",
						"          ENTITY_TYPE as string,",
						"          ENTITY_STATUS as string,",
						"          IS_RENEWAL_YN as string,",
						"          REVISION_NUMBER as integer,",
						"          PRODUCT_ID as long,",
						"          PRODUCT_OVID as long,",
						"          POLICY_EFFECTIVE_DATE as timestamp,",
						"          POLICY_EXPIRATION_DATE as timestamp,",
						"          NON_RENEWAL_CODE as string,",
						"          POLICY_RENEWED_YN as string,",
						"          CANCELLATION_DATE as timestamp,",
						"          IS_RENEWABLE_YN as string,",
						"          PREVIOUS_INSURANCE_NO_REASON as string,",
						"          POLICY_STATUS as string,",
						"          CANCEL_REASON_CODE as string,",
						"          CANCEL_REASON_DESCRIPTION as string,",
						"          CANCEL_METHOD as string,",
						"          CANCEL_METHOD_DESC as string,",
						"          LOSE_REASON_CODE as string,",
						"          LOSE_REASON_DESC as string,",
						"          DECLINATION_REASON_CODE as string,",
						"          DECLINATION_REASON_DESC as string,",
						"          NOT_WRITTEN_REASON_CODE as string,",
						"          NOT_WRITTEN_REASON_DESC as string,",
						"          POLICY_STATE_CODE as string,",
						"          PROGRAM_ID as long,",
						"          PROGRAM_OVID as long,",
						"          BILLING_TYPE_CODE as string,",
						"          UNDERWRITING_COMPANY_ID as long,",
						"          UNDERWRITING_COMPANY_OVID as long,",
						"          SUBMISSION_ID as long,",
						"          PREVIOUS_INSURANCE_YN as string,",
						"          LEGACY_POLICY_NUMBER as string,",
						"          STATE as string,",
						"          POLICY_POLICY as integer,",
						"          PAYMENT_PLAN as string,",
						"          APPLICATION_RECEIVED_DATE as timestamp,",
						"          INCEPTION_DATE as timestamp,",
						"          BILL_TYPE as string,",
						"          FORMS_LANGUAGE as string,",
						"          BASE_CURRENCY as string,",
						"          INVOICE_CURRENCY as string,",
						"          PREVIOUS_POLICY_ID as long,",
						"          PREVIOUS_POLICY_OVID as long,",
						"          REVISED_FROM_POLICY_ID as long,",
						"          REVISED_FROM_POLICY_OVID as long,",
						"          OPERATING_COMPANY_ID as long,",
						"          OPERATING_COMPANY_OVID as long,",
						"          CONVERTED_FROM_ID as long,",
						"          CONVERTED_FROM_OVID as long,",
						"          INSTALLMENT_RENEWAL as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select * from POL_POLICY',",
						"     format: 'query') ~> polPolicy",
						"source(output(",
						"          LOCATION_ID as long,",
						"          LOCATION_OVID as long,",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          DATA_HASH as binary,",
						"          SOURCE_KEY as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> risklocationBridge",
						"derivedColumn4 compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet3@(output1)",
						"lookup4 derive(TX_ID = TX_ID,",
						"          RISK_ID = select1@RISK_ID,",
						"          TX_BRIDGE_ID = TX_BRIDGE_ID,",
						"          RISK_OVID = RISK_OVID,",
						"          POLICY_ID = POLICY_ID,",
						"          POLICY_OVID = POLICY_OVID,",
						"          COVERAGE_ID = COVERAGE_ID,",
						"          COVERAGE_OVID = COVERAGE_VID) ~> limit1",
						"select1, fcp lookup(select1@Policy_Sequence == fcp@Policy_Sequence",
						"     && select1@LocationNumber == fcp@LocationNumber",
						"     && select1@LocationUnitNumber == fcp@LocationUnitNumber",
						"     && select1@PrimaryPremiumStateCode == fcp@PrimaryPremiumStateCode",
						"     && select1@ARICLOB == fcp@ARICLOB",
						"     && select1@ARICCoverageCode == fcp@ARICCoverageCode",
						"     && select1@ARICCoverageSequence == toString(fcp@ARICCoverageSequence)",
						"     && select1@ARICGroupCode == fcp@ARICGroupCode,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lookup2",
						"join1, polPolicy lookup(StagingTxnBridge@POLICY_ID == polPolicy@POLICY_ID,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lookup3",
						"lookup3 derive(Policy_Sequence = split(TX_CODE,'-')[1],",
						"          LocationNumber = split(TX_CODE,'-')[2],",
						"          LocationUnitNumber = split(TX_CODE,'-')[3],",
						"          ARICGroupCode = split(TX_CODE,'-')[4],",
						"          PrimaryPremiumStateCode = split(TX_CODE,'-')[5],",
						"          ARICLOB = split(TX_CODE,'-')[6],",
						"          ARICCoverageCode = split(TX_CODE,'-')[7],",
						"          ARICCoverageSequence = split(TX_CODE,'-')[8]) ~> derivedColumn2",
						"derivedColumn2 select(mapColumn(",
						"          TX_BRIDGE_ID,",
						"          POLICY_ID = StagingTxnBridge@POLICY_ID,",
						"          POLICY_OVID = StagingTxnBridge@POLICY_OVID,",
						"          TX_ID = StagingTxnBridge@TX_ID,",
						"          SECTION_ID,",
						"          SECTION_VID,",
						"          RISK_ID,",
						"          RISK_OVID,",
						"          COVERAGE_ID,",
						"          COVERAGE_VID,",
						"          TX_ID = stgPolTxn@TX_ID,",
						"          POLICY_ID = stgPolTxn@POLICY_ID,",
						"          POLICY_OVID = stgPolTxn@POLICY_OVID,",
						"          TX_CODE,",
						"          TRANSACTION_TYPE_CODE,",
						"          TYPE_OF_CHANGE,",
						"          POLICY_ID = polPolicy@POLICY_ID,",
						"          POLICY_VID,",
						"          POLICY_NUMBER,",
						"          Policy_Sequence,",
						"          LocationNumber,",
						"          LocationUnitNumber,",
						"          ARICGroupCode,",
						"          PrimaryPremiumStateCode,",
						"          ARICLOB,",
						"          ARICCoverageCode,",
						"          ARICCoverageSequence",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"fcp select(mapColumn(",
						"          Policy,",
						"          Policy_Sequence,",
						"          ARICLOB,",
						"          ARICGroupCode,",
						"          ARICCoverageCode,",
						"          ARICCoverageDescription,",
						"          PrimaryPremiumStateCode,",
						"          LocationNumber,",
						"          LocationUnitNumber,",
						"          ARICCoverageSequence,",
						"          CoverageDescription,",
						"          Limit1,",
						"          Limit2,",
						"          PremiumAmount",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select2",
						"surrogateKey1 derive(LIMIT_DED_OPT_TYPE_ID = 4,",
						"          LDO_CODE = 'Limit2',",
						"          LDO_VALUE = Limit2,",
						"          LDO_FLAG = '') ~> derivedColumn4",
						"select3 keyGenerate(output(TX_LIMIT_DED_OPT_ID as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> surrogateKey1",
						"limit1 select(mapColumn(",
						"          TX_BRIDGE_ID,",
						"          POLICY_ID,",
						"          POLICY_OVID,",
						"          TX_ID,",
						"          SECTION_ID,",
						"          SECTION_VID,",
						"          RISK_ID,",
						"          RISK_OVID,",
						"          COVERAGE_ID,",
						"          COVERAGE_VID,",
						"          TX_CODE,",
						"          TRANSACTION_TYPE_CODE,",
						"          TYPE_OF_CHANGE,",
						"          POLICY_VID,",
						"          POLICY_NUMBER,",
						"          Policy,",
						"          PolicyPrefix,",
						"          Description,",
						"          Product,",
						"          ARICCoverageDescription,",
						"          Limit1,",
						"          Limit2,",
						"          PremiumAmount,",
						"          COVERAGE_OVID,",
						"          LOCATION_ID,",
						"          LOCATION_OVID",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select3",
						"lookup2 filter(!isNull(Policy)) ~> filter1",
						"risklocationBridge select(mapColumn(",
						"          LOCATION_ID,",
						"          LOCATION_OVID,",
						"          RISK_ID,",
						"          RISK_VID",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select4",
						"filter1, risklocationBridge lookup(select1@RISK_ID == risklocationBridge@RISK_ID",
						"     && RISK_OVID == RISK_VID,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lookup4",
						"StagingTxnBridge, stgPolTxn join(StagingTxnBridge@TX_ID == stgPolTxn@TX_ID,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"flowlet3@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          TX_LIMIT_DED_OPT_ID as long,",
						"          TX_ID as long,",
						"          LOCATION_ID as long,",
						"          LOCATION_OVID as long,",
						"          SECTION_ID as long,",
						"          SECTION_OVID as long,",
						"          TX_BRIDGE_ID as long,",
						"          RISK_ID as long,",
						"          RISK_OVID as long,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          LIMIT_DED_OPT_TYPE_ID as long,",
						"          LDO_FLAG as string,",
						"          LDO_CODE as string,",
						"          LIMIT_OCCURRENCE_FLAG as string,",
						"          LDO_VALUE as long,",
						"          LDO_VALUE_CCY_CODE as string,",
						"          LDO_PERCENTAGE as decimal(6,4),",
						"          LDO_TEXT as string,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          DATA_HASH as binary,",
						"          SOURCE_KEY as string,",
						"          COVERAGE_ID as long,",
						"          COVERAGE_OVID as long",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> PolTxLimitDedOptLimit2"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_source_POL__LIMIT_DED_OPT_TYPE')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Source Stage Data Flows/txnDataFlow"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_ECMDataDictionary",
								"type": "DatasetReference"
							},
							"name": "source1"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_POLLIMITDEDOPTTYPE",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "flowlet1",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "surrogateKey1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          amountType as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select [Column] as amountType from ECMDataDictionary where TableName = \\'PolicyCoveragePremium_P\\' and( [Column] =\\'limit1\\'or [Column] =\\'limit2\\')\\nunion\\nselect [Column] from ECMDataDictionary where TableName = \\'PolicyDeductible_P\\' and( [Column] =\\'DeductibleAmount1Type\\'or [Column] =\\'DeductibleAmount2Type\\')',",
						"     format: 'query') ~> source1",
						"derivedColumn1 compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet1@(output1)",
						"surrogateKey1 derive(POLICY_YN = 'N',",
						"          LIMIT_DED_OPT_TYPE = case(startsWith(amountType, 'DeductibleAmount'), 'Deductible',",
						"case(startsWith(amountType, 'limit'), 'limit','limit')),",
						"          LDO_NAME = case(startsWith(amountType, 'DeductibleAmount1Type'), 'DeductibleAmount1Type',",
						"case(startsWith(amountType, 'DeductibleAmount2Type'), 'DeductibleAmount2Type',",
						"case(startsWith(amountType, 'Limit1'), 'Limit1','Limit2'))),",
						"          COVERAGE_YN = 'Y') ~> derivedColumn1",
						"source1 keyGenerate(output(LIMIT_DED_OPT_TYPE_ID as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> surrogateKey1",
						"flowlet1@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          LIMIT_DED_OPT_TYPE_ID as long,",
						"          POLICY_YN as string,",
						"          LIMIT_DED_OPT_TYPE as string,",
						"          LDO_NAME as string,",
						"          LOCATION_YN as string,",
						"          RISK_YN as string,",
						"          SECTION_YN as string,",
						"          COVERAGE_YN as string,",
						"          GRAIN_CD as string,",
						"          IS_KEY_LDO_YN as string,",
						"          LDO_COLUMN_NAME as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink1"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_source_agency')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Source Stage Data Flows/referenceDataFlow"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_agent",
								"type": "DatasetReference"
							},
							"name": "agencySource"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_agency",
								"type": "DatasetReference"
							},
							"name": "agencySourceLookup"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_agency",
								"type": "DatasetReference"
							},
							"name": "agencyStaging"
						}
					],
					"transformations": [
						{
							"name": "metadataflowlet",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "requiredSourceAgencyColumns"
						},
						{
							"name": "derivedOtherRequiredColumns"
						},
						{
							"name": "agencySurrogateKey"
						},
						{
							"name": "requiredStagingAgencyColumns"
						},
						{
							"name": "deriveAgencyName"
						},
						{
							"name": "groupByAgencyName"
						}
					],
					"scriptLines": [
						"parameters{",
						"     DF_max_id as integer (1)",
						"}",
						"source(output(",
						"          AgentCode as string,",
						"          AgentName as string,",
						"          GroupCode as string,",
						"          AgentStatus as string,",
						"          StartDate as date,",
						"          EndDate as date,",
						"          AgentOffice as string,",
						"          RenewalNoticeDays as integer,",
						"          AuditExclusion as string,",
						"          AuditThreshold as decimal(8,0),",
						"          IssuanceGroup as string,",
						"          DefaultBusinessDivisionID as integer,",
						"          DefaultPricingProductID as integer,",
						"          OfficeID as integer,",
						"          EMail as string,",
						"          AgentAddress1 as string,",
						"          AgentAddress2 as string,",
						"          AgentAddress3 as string,",
						"          AgentCity as string,",
						"          AgentState as string,",
						"          AgentZipCode as string,",
						"          AgentPhone as string,",
						"          AgentCounty as string,",
						"          AgentContact as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> agencySource",
						"source(output(",
						"          AGENCY_ID as long,",
						"          AGENCY_VID as long,",
						"          AGENCY_GEN_ADDRESS_ID as long,",
						"          AGENCY_CODE as string,",
						"          AGENCY_NAME as string,",
						"          AGENCY_STATUS as string,",
						"          AGENCY_CATEGORY as string,",
						"          DIRECT_BILL_FLAG_YN as string,",
						"          TELEPHONE as string,",
						"          FAX as string,",
						"          EMAIL_ID as string,",
						"          WEBSITE as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          ENTITY_TYPE as string,",
						"          ENTITY_PARENT_ID as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> agencySourceLookup",
						"derivedOtherRequiredColumns compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> metadataflowlet@(output1)",
						"agencySource select(mapColumn(",
						"          AGENCY_CODE = AgentCode,",
						"          GIVEN_AGENCY_NAME = AgentName,",
						"          AGENCY_CATEGORY = GroupCode,",
						"          AGENCY_STATUS = AgentStatus,",
						"          EMAIL_ID = EMail,",
						"          TELEPHONE = AgentPhone",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> requiredSourceAgencyColumns",
						"agencySurrogateKey derive(ENTITY_TYPE = \"AGENCY\",",
						"          AGENCY_ID = skey + $DF_max_id,",
						"          AGENCY_VID = 1) ~> derivedOtherRequiredColumns",
						"groupByAgencyName keyGenerate(output(skey as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> agencySurrogateKey",
						"agencySourceLookup select(mapColumn(",
						"          AGENCY_CODE",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> requiredStagingAgencyColumns",
						"requiredSourceAgencyColumns derive(AGENCY_NAME = trim(GIVEN_AGENCY_NAME)) ~> deriveAgencyName",
						"deriveAgencyName aggregate(groupBy(AGENCY_NAME),",
						"     each(match(name!='AGENCY_NAME'), $$ = first($$))) ~> groupByAgencyName",
						"metadataflowlet@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          AGENCY_ID as long,",
						"          AGENCY_VID as long,",
						"          AGENCY_GEN_ADDRESS_ID as long,",
						"          AGENCY_CODE as string,",
						"          AGENCY_NAME as string,",
						"          AGENCY_STATUS as string,",
						"          AGENCY_CATEGORY as string,",
						"          DIRECT_BILL_FLAG_YN as string,",
						"          TELEPHONE as string,",
						"          FAX as string,",
						"          EMAIL_ID as string,",
						"          WEBSITE as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          ENTITY_TYPE as string,",
						"          ENTITY_PARENT_ID as long",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> agencyStaging"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_source_cfaInsObj')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Source Stage Data Flows/txnDataFlow"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRisk",
								"type": "DatasetReference"
							},
							"name": "StagingPolicyRisk"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policy",
								"type": "DatasetReference"
							},
							"name": "StagingPolicy"
						},
						{
							"dataset": {
								"referenceName": "ds_source_PolicyAutoUnit",
								"type": "DatasetReference"
							},
							"name": "autoUnitsSource"
						},
						{
							"dataset": {
								"referenceName": "ds_source_locationAddress",
								"type": "DatasetReference"
							},
							"name": "locationAddressSource"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "StagingPolicyRiskTypeBreed"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "StagingPolicyRiskTypeName"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "StagingPolicyRiskTypeSex"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "StagingPolicyRiskTypePurchaseDate"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "StagingPolicyRiskTypeMortality"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "StagingPolicyRiskTypeUse"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "StagingPolicyRiskTypePrice"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "StagingPolicyRiskTypeRequestedLimit"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "StagingPolicyRiskTypeAge"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "StagingPolicyRiskTypeVehicleOwned"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "StagingPolicyRiskTypeRadiusClass"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "StagingPolicyRiskTypePrimaryClass"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "StagingPolicyRiskTypeSecondaryClass"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "sink3"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "sink4"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "sink5"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "sink6"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "StagingPolicyRiskTypeFleet"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "sink7"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "sink8"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "sink9"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "sink10"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "sink11"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "sink13"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "sink14"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "sink15"
						}
					],
					"transformations": [
						{
							"name": "flowlet1",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet2",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet3",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet4",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet5",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet6",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet7",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet9",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet10",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet11",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet12",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet14",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet15",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet16",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet17",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet18",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet19",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet20",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet21",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet22",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet23",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet24",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet25",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet27",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet28",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet29",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "filter1"
						},
						{
							"name": "registeredStateName"
						},
						{
							"name": "originalCostNewOfVehicle"
						},
						{
							"name": "model"
						},
						{
							"name": "autoUnitLookup"
						},
						{
							"name": "make"
						},
						{
							"name": "statedAmount"
						},
						{
							"name": "vin"
						},
						{
							"name": "registeredState"
						},
						{
							"name": "classCode"
						},
						{
							"name": "year"
						},
						{
							"name": "vehicleIsOwnedOrLeased"
						},
						{
							"name": "radiusClass"
						},
						{
							"name": "filter2"
						},
						{
							"name": "primaryClassCode"
						},
						{
							"name": "secondaryClassCode"
						},
						{
							"name": "filter3"
						},
						{
							"name": "filter4"
						},
						{
							"name": "operatorExperience"
						},
						{
							"name": "type"
						},
						{
							"name": "use"
						},
						{
							"name": "fleetPP"
						},
						{
							"name": "fleetTK"
						},
						{
							"name": "addressLookup"
						},
						{
							"name": "zipcode"
						},
						{
							"name": "territory"
						},
						{
							"name": "filter5"
						},
						{
							"name": "supplementaryType"
						},
						{
							"name": "businessUseClass"
						},
						{
							"name": "vehicleSizeClass"
						},
						{
							"name": "vehicleTypeCode"
						},
						{
							"name": "classCodeST"
						},
						{
							"name": "classCodePP"
						},
						{
							"name": "join1"
						}
					],
					"scriptLines": [
						"parameters{",
						"     policyPrefix as string (\"CFA\"),",
						"     policies as string[] (['CFA002097'])",
						"}",
						"source(output(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_NUMBER as string,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          RISK_IS_ACTIVE_YN as string,",
						"          RISK_EFF_DATE as timestamp,",
						"          RISK_EXP_DATE as timestamp,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select * from POL_RISK ',",
						"     format: 'query') ~> StagingPolicyRisk",
						"source(output(",
						"          POLICY_ID as long,",
						"          POLICY_VID as long,",
						"          REINSURANCE_DAC as string,",
						"          PREVIOUS_INSURANCE_NO_REMARKS as string,",
						"          AGENCY_ID as long,",
						"          AGENCY_OVID as long,",
						"          PRODUCER_ID as long,",
						"          PRODUCER_OVID as long,",
						"          PRODUCER_CONTACT_ID as long,",
						"          PRODUCER_CONTACT_OVID as long,",
						"          POLICY_NUMBER as string,",
						"          ENTITY_TYPE as string,",
						"          ENTITY_STATUS as string,",
						"          IS_RENEWAL_YN as string,",
						"          REVISION_NUMBER as integer,",
						"          PRODUCT_ID as long,",
						"          PRODUCT_OVID as long,",
						"          POLICY_EFFECTIVE_DATE as timestamp,",
						"          POLICY_EXPIRATION_DATE as timestamp,",
						"          NON_RENEWAL_CODE as string,",
						"          POLICY_RENEWED_YN as string,",
						"          CANCELLATION_DATE as timestamp,",
						"          IS_RENEWABLE_YN as string,",
						"          PREVIOUS_INSURANCE_NO_REASON as string,",
						"          POLICY_STATUS as string,",
						"          CANCEL_REASON_CODE as string,",
						"          CANCEL_REASON_DESCRIPTION as string,",
						"          CANCEL_METHOD as string,",
						"          CANCEL_METHOD_DESC as string,",
						"          LOSE_REASON_CODE as string,",
						"          LOSE_REASON_DESC as string,",
						"          DECLINATION_REASON_CODE as string,",
						"          DECLINATION_REASON_DESC as string,",
						"          NOT_WRITTEN_REASON_CODE as string,",
						"          NOT_WRITTEN_REASON_DESC as string,",
						"          POLICY_STATE_CODE as string,",
						"          PROGRAM_ID as long,",
						"          PROGRAM_OVID as long,",
						"          BILLING_TYPE_CODE as string,",
						"          UNDERWRITING_COMPANY_ID as long,",
						"          UNDERWRITING_COMPANY_OVID as long,",
						"          SUBMISSION_ID as long,",
						"          PREVIOUS_INSURANCE_YN as string,",
						"          LEGACY_POLICY_NUMBER as string,",
						"          STATE as string,",
						"          POLICY_POLICY as integer,",
						"          PAYMENT_PLAN as string,",
						"          APPLICATION_RECEIVED_DATE as timestamp,",
						"          INCEPTION_DATE as timestamp,",
						"          BILL_TYPE as string,",
						"          FORMS_LANGUAGE as string,",
						"          BASE_CURRENCY as string,",
						"          INVOICE_CURRENCY as string,",
						"          PREVIOUS_POLICY_ID as long,",
						"          PREVIOUS_POLICY_OVID as long,",
						"          REVISED_FROM_POLICY_ID as long,",
						"          REVISED_FROM_POLICY_OVID as long,",
						"          OPERATING_COMPANY_ID as long,",
						"          OPERATING_COMPANY_OVID as long,",
						"          CONVERTED_FROM_ID as long,",
						"          CONVERTED_FROM_OVID as long,",
						"          INSTALLMENT_RENEWAL as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from POL_POLICY where policy_number like '{$policyPrefix}%'\"+iif(size($policies) >0&& size($policies) ==1&&$policies[1] =='','','and policy_number in ('+dropLeft(toString(reduce($policies, \"'\", #acc + \",'\" + #item +\"'\", #result)), 2)+')')),",
						"     format: 'query') ~> StagingPolicy",
						"source(output(",
						"          PolicyPrefix as string,",
						"          Policy as string,",
						"          Policy_Sequence as string,",
						"          RowStatus as string,",
						"          EffectiveDate as timestamp,",
						"          ExpirationDate as timestamp,",
						"          LocationNumber as string,",
						"          LocationUnitNumber as string,",
						"          {UnitType/ModificationType} as string,",
						"          YearBuild as short,",
						"          UnitValue as decimal(13,0),",
						"          RiskUseCode as string,",
						"          Make as string,",
						"          Model as string,",
						"          UnitWidth as short,",
						"          ISOClassCode as string,",
						"          RiskType as string,",
						"          UnitLength as short,",
						"          PurchaseDate as timestamp,",
						"          AppraisalYear as short,",
						"          UnitDescription as string,",
						"          AnimalUseCode as string,",
						"          LeaseFlag as string,",
						"          AppraisalFlag as string,",
						"          RegistrationState as string,",
						"          VehicleID as string,",
						"          EngineDisplacement as short,",
						"          FuelTypeCode as string,",
						"          Layup as string,",
						"          ID as integer,",
						"          DataSource as string,",
						"          DW_InsertDate as date",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from [dbo].[PolicyAutoUnit_P]  where PolicyPrefix='{$policyPrefix}'\"+iif(size($policies) >0&& size($policies) ==1&&$policies[1] =='','','and policy in ('+dropLeft(toString(reduce($policies, \"'\", #acc + \",'\" + #item +\"'\", #result)), 2)+')')),",
						"     format: 'query') ~> autoUnitsSource",
						"source(output(",
						"          Policy as string,",
						"          Policy_Sequence as string,",
						"          PolicyPrefix as string,",
						"          ProductCode as string,",
						"          LocationNumber as string,",
						"          BuildingNumber as string,",
						"          LocationName as string,",
						"          LocationAddress1 as string,",
						"          LocationAddress2 as string,",
						"          LocationAddress3 as string,",
						"          LocationCity as string,",
						"          LocationZipCode as string,",
						"          LocationCounty as string,",
						"          Territory as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from [dbo].[Location_Address]  where PolicyPrefix='{$policyPrefix}'\"+iif(size($policies) >0&& size($policies) ==1&&$policies[1] =='','','and policy in ('+dropLeft(toString(reduce($policies, \"'\", #acc + \",'\" + #item +\"'\", #result)), 2)+')')),",
						"     format: 'query') ~> locationAddressSource",
						"registeredStateName compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet1@(output1)",
						"originalCostNewOfVehicle compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet2@(output1)",
						"model compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet3@(output1)",
						"make compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet4@(output1)",
						"vin compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet5@(output1)",
						"statedAmount compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet6@(output1)",
						"classCode compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet7@(output1)",
						"registeredState compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet9@(output1)",
						"year compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet10@(output1)",
						"vehicleIsOwnedOrLeased compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet11@(output1)",
						"radiusClass compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet12@(output1)",
						"primaryClassCode compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet14@(output1)",
						"secondaryClassCode compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet15@(output1)",
						"use compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet16@(output1)",
						"type compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet17@(output1)",
						"operatorExperience compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet18@(output1)",
						"fleetPP compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet19@(output1)",
						"fleetTK compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet20@(output1)",
						"territory compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet21@(output1)",
						"zipcode compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet22@(output1)",
						"supplementaryType compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet23@(output1)",
						"businessUseClass compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet24@(output1)",
						"vehicleSizeClass compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet25@(output1)",
						"vehicleTypeCode compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet27@(output1)",
						"classCodeST compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet28@(output1)",
						"classCodePP compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet29@(output1)",
						"addressLookup filter(not(isNull(POLICY_NUMBER))) ~> filter1",
						"filter1 derive(RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = RISK_CODE,",
						"          ATTRIBUTE_NAME = \"registeredState_Name\",",
						"          ATTRIBUTE_VALUE = RegistrationState) ~> registeredStateName",
						"filter1 derive(RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = AnimalUseCode,",
						"          ATTRIBUTE_NAME = 'OriginalCostNewOfVehicle',",
						"          ATTRIBUTE_VALUE = UnitValue) ~> originalCostNewOfVehicle",
						"filter1 derive(RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISKCODE = RiskUseCode,",
						"          ATTRIBUTE_NAME = \"Model\",",
						"          ATTRIBUTE_VALUE = trim(Model)) ~> model",
						"join1, autoUnitsSource lookup(POLICY_NUMBER == Policy",
						"     && split(RISK_NUMBER,'-')[1] == LocationNumber",
						"     && split(RISK_NUMBER,'-')[2] == LocationUnitNumber,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> autoUnitLookup",
						"filter1 derive(RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = '',",
						"          ATTRIBUTE_NAME = 'Make',",
						"          ATTRIBUTE_VALUE = trim(Make)) ~> make",
						"filter1 derive(RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = '',",
						"          ATTRIBUTE_NAME = 'StatedAmount',",
						"          ATTRIBUTE_VALUE = 0) ~> statedAmount",
						"filter1 derive(RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = '',",
						"          ATTRIBUTE_NAME = 'Vin',",
						"          ATTRIBUTE_VALUE = VehicleID) ~> vin",
						"filter1 derive(RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = '',",
						"          ATTRIBUTE_NAME = 'RegisteredState',",
						"          ATTRIBUTE_VALUE = RegistrationState) ~> registeredState",
						"filter1 derive(RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = '',",
						"          ATTRIBUTE_NAME = 'ClassCode',",
						"          ATTRIBUTE_VALUE = ISOClassCode) ~> classCode",
						"filter1 derive(RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = \"\",",
						"          ATTRIBUTE_NAME = \"Year\",",
						"          ATTRIBUTE_VALUE = YearBuild) ~> year",
						"filter1 derive(RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = \"\",",
						"          ATTRIBUTE_NAME = 'VehicleIsOwnedOrLeased',",
						"          ATTRIBUTE_VALUE = iif(isNull(LeaseFlag) || trim(LeaseFlag)=='', '', LeaseFlag)) ~> vehicleIsOwnedOrLeased",
						"filter2 derive(ATTRIBUTE_NAME = 'RadiusClass',",
						"          ATTRIBUTE_VALUE = substring(ISOClassCode, 3,1),",
						"          RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = '') ~> radiusClass",
						"filter3 filter(in(['HT','LT','MT','MH','TR','TK','TT','VP','TC','TL','XT'], RiskType)) ~> filter2",
						"filter2 derive(ATTRIBUTE_NAME = 'PrimaryClassCode',",
						"          ATTRIBUTE_VALUE = substring(ISOClassCode, 1,3),",
						"          RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = '') ~> primaryClassCode",
						"filter2 derive(ATTRIBUTE_NAME = 'SecondaryClassCode',",
						"          ATTRIBUTE_VALUE = substring(ISOClassCode, 4,5),",
						"          RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = '') ~> secondaryClassCode",
						"filter1 filter(not(isNull(POLICY_NUMBER))) ~> filter3",
						"filter3 filter(in(['SU', 'PV'], RiskType)) ~> filter4",
						"filter4 derive(RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = '',",
						"          ATTRIBUTE_NAME = 'OperatorExperience',",
						"          ATTRIBUTE_VALUE = 'No Operator Licensed Less Than Five Years') ~> operatorExperience",
						"filter4 derive(RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = '',",
						"          ATTRIBUTE_NAME = 'Type',",
						"          ATTRIBUTE_VALUE = 'Personal Use or Farm Use - Nonfleet Vehicle') ~> type",
						"filter4 derive(RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = '',",
						"          ATTRIBUTE_NAME = 'Use',",
						"          ATTRIBUTE_VALUE = RiskUseCode) ~> use",
						"filter4 derive(ATTRIBUTE_NAME = 'Fleet',",
						"          ATTRIBUTE_VALUE = 'No',",
						"          RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = '') ~> fleetPP",
						"filter2 derive(ATTRIBUTE_NAME = 'Fleet',",
						"          ATTRIBUTE_VALUE = iif(toInteger(substring(ISOClassCode, 3,1))>3, 'Yes', 'No')) ~> fleetTK",
						"autoUnitLookup, locationAddressSource lookup(POLICY_NUMBER == locationAddressSource@Policy",
						"     && autoUnitsSource@LocationNumber == locationAddressSource@LocationNumber,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> addressLookup",
						"filter1 derive(ATTRIBUTE_NAME = 'Zipcode',",
						"          ATTRIBUTE_VALUE = LocationZipCode,",
						"          RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = '') ~> zipcode",
						"filter1 derive(ATTRIBUTE_NAME = 'Territory',",
						"          ATTRIBUTE_VALUE = Territory,",
						"          RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = '') ~> territory",
						"filter3 filter(!in(['HT','LT','MT','MH','TR','TK','TT','VP','TC','TL','XT', 'PV', 'SU'], RiskType)) ~> filter5",
						"filter5 derive(ATRRIBUTE_NAME = 'SupplementaryType',",
						"          ATRRIBUTE_VALUE = '',",
						"          RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = '') ~> supplementaryType",
						"filter2 derive(ATTRIBUTE_NAME = 'BusinessUseClass',",
						"          ATTRIBUTE_VALUE = RiskUseCode,",
						"          RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = '') ~> businessUseClass",
						"filter2 derive(ATTRIBUTE_NAME = 'vehicleSizeClass',",
						"          ATTRIBUTE_VALUE = RiskType,",
						"          RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = '') ~> vehicleSizeClass",
						"filter1 derive(RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = '',",
						"          ATTRIBUTE_NAME = 'VehicleTypeCode',",
						"          ATTRIBUTE_VALUE = RiskType) ~> vehicleTypeCode",
						"filter5 derive(RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = '',",
						"          ATTRIBUTE_NAME = 'ClassCode',",
						"          ATTRIBUTE_VALUE = ISOClassCode) ~> classCodeST",
						"filter4 derive(RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = '',",
						"          ATTRIBUTE_NAME = 'ClassCode',",
						"          ATTRIBUTE_VALUE = ISOClassCode) ~> classCodePP",
						"StagingPolicyRisk, StagingPolicy join(StagingPolicyRisk@POLICY_ID == StagingPolicy@POLICY_ID,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"flowlet1@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> StagingPolicyRiskTypeBreed",
						"flowlet2@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> StagingPolicyRiskTypeName",
						"flowlet3@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> StagingPolicyRiskTypeSex",
						"flowlet5@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> StagingPolicyRiskTypePurchaseDate",
						"flowlet6@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> StagingPolicyRiskTypeMortality",
						"flowlet4@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> StagingPolicyRiskTypeUse",
						"flowlet9@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> StagingPolicyRiskTypePrice",
						"flowlet7@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> StagingPolicyRiskTypeRequestedLimit",
						"flowlet10@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> StagingPolicyRiskTypeAge",
						"flowlet11@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> StagingPolicyRiskTypeVehicleOwned",
						"flowlet12@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> StagingPolicyRiskTypeRadiusClass",
						"flowlet14@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> StagingPolicyRiskTypePrimaryClass",
						"flowlet15@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> StagingPolicyRiskTypeSecondaryClass",
						"flowlet18@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink3",
						"flowlet17@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink4",
						"flowlet16@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink5",
						"flowlet19@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink6",
						"flowlet20@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> StagingPolicyRiskTypeFleet",
						"flowlet22@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink7",
						"flowlet21@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink8",
						"flowlet23@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink9",
						"flowlet24@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink10",
						"flowlet25@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink11",
						"flowlet27@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink13",
						"flowlet28@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink14",
						"flowlet29@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink15"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_source_coverage')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Source Stage Data Flows/txnDataFlow"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_policyCoverage",
								"type": "DatasetReference"
							},
							"name": "policyCoverageSource"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policy",
								"type": "DatasetReference"
							},
							"name": "policyStaging"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_coverageCode",
								"type": "DatasetReference"
							},
							"name": "coverageCodeStaging"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_coverage",
								"type": "DatasetReference"
							},
							"name": "coverageStagingLookup"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_coverage",
								"type": "DatasetReference"
							},
							"name": "coverageStagingMaxId"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_coverage",
								"type": "DatasetReference"
							},
							"name": "coverageStaging"
						},
						{
							"name": "maxIdCache"
						}
					],
					"transformations": [
						{
							"name": "flowlet1",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "select1"
						},
						{
							"name": "select2"
						},
						{
							"name": "policyJoin"
						},
						{
							"name": "select3"
						},
						{
							"name": "coverageCodeJoin"
						},
						{
							"name": "select4"
						},
						{
							"name": "surrogateKey1"
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "exists1"
						}
					],
					"scriptLines": [
						"parameters{",
						"     policyPrefix as string,",
						"     policies as string[]",
						"}",
						"source(output(",
						"          Policy as string,",
						"          ARICCoverageDescription as string,",
						"          Cov_effective_Date as timestamp,",
						"          Cov_Expiry_Date as timestamp,",
						"          CoverageDescription as string,",
						"          ARICLOB as string,",
						"          ARICCOverageCode as string,",
						"          ARICCoverageSequence as integer,",
						"          ARICGroupCode as string,",
						"          PrimaryPremiumStateCode as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select distinct Policy, ARICCoverageDescription ,Cov_effective_Date, Cov_Expiry_Date, CoverageDescription, ARICLOB, ARICCOverageCode, ARICCoverageSequence, ARICGroupCode, PrimaryPremiumStateCode from [dbo].[Policy_Coverage] where PolicyPrefix = '{$policyPrefix}'\"+iif(size($policies) >0&& size($policies) ==1&&$policies[1] =='','','and policy in ('+dropLeft(toString(reduce($policies, \"'\", #acc + \",'\" + #item +\"'\", #result)), 2)+')')),",
						"     format: 'query') ~> policyCoverageSource",
						"source(output(",
						"          POLICY_ID as long,",
						"          POLICY_VID as long,",
						"          REINSURANCE_DAC as string,",
						"          PREVIOUS_INSURANCE_NO_REMARKS as string,",
						"          AGENCY_ID as long,",
						"          AGENCY_OVID as long,",
						"          PRODUCER_ID as long,",
						"          PRODUCER_OVID as long,",
						"          PRODUCER_CONTACT_ID as long,",
						"          PRODUCER_CONTACT_OVID as long,",
						"          POLICY_NUMBER as string,",
						"          ENTITY_TYPE as string,",
						"          ENTITY_STATUS as string,",
						"          IS_RENEWAL_YN as string,",
						"          REVISION_NUMBER as integer,",
						"          PRODUCT_ID as long,",
						"          PRODUCT_OVID as long,",
						"          POLICY_EFFECTIVE_DATE as timestamp,",
						"          POLICY_EXPIRATION_DATE as timestamp,",
						"          NON_RENEWAL_CODE as string,",
						"          POLICY_RENEWED_YN as string,",
						"          CANCELLATION_DATE as timestamp,",
						"          IS_RENEWABLE_YN as string,",
						"          PREVIOUS_INSURANCE_NO_REASON as string,",
						"          POLICY_STATUS as string,",
						"          CANCEL_REASON_CODE as string,",
						"          CANCEL_REASON_DESCRIPTION as string,",
						"          CANCEL_METHOD as string,",
						"          CANCEL_METHOD_DESC as string,",
						"          LOSE_REASON_CODE as string,",
						"          LOSE_REASON_DESC as string,",
						"          DECLINATION_REASON_CODE as string,",
						"          DECLINATION_REASON_DESC as string,",
						"          NOT_WRITTEN_REASON_CODE as string,",
						"          NOT_WRITTEN_REASON_DESC as string,",
						"          POLICY_STATE_CODE as string,",
						"          PROGRAM_ID as long,",
						"          PROGRAM_OVID as long,",
						"          BILLING_TYPE_CODE as string,",
						"          UNDERWRITING_COMPANY_ID as long,",
						"          UNDERWRITING_COMPANY_OVID as long,",
						"          SUBMISSION_ID as long,",
						"          PREVIOUS_INSURANCE_YN as string,",
						"          LEGACY_POLICY_NUMBER as string,",
						"          STATE as string,",
						"          POLICY_POLICY as integer,",
						"          PAYMENT_PLAN as string,",
						"          APPLICATION_RECEIVED_DATE as timestamp,",
						"          INCEPTION_DATE as timestamp,",
						"          BILL_TYPE as string,",
						"          FORMS_LANGUAGE as string,",
						"          BASE_CURRENCY as string,",
						"          INVOICE_CURRENCY as string,",
						"          PREVIOUS_POLICY_ID as long,",
						"          PREVIOUS_POLICY_OVID as long,",
						"          REVISED_FROM_POLICY_ID as long,",
						"          REVISED_FROM_POLICY_OVID as long,",
						"          OPERATING_COMPANY_ID as long,",
						"          OPERATING_COMPANY_OVID as long,",
						"          CONVERTED_FROM_ID as long,",
						"          CONVERTED_FROM_OVID as long,",
						"          INSTALLMENT_RENEWAL as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> policyStaging",
						"source(output(",
						"          COVERAGE_CODE_ID as long,",
						"          COVERAGE_CODE as string,",
						"          COVERAGE_DESCRIPTION as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> coverageCodeStaging",
						"source(output(",
						"          COVERAGE_ID as long,",
						"          COVERAGE_VID as long,",
						"          COVERAGE_CODE_ID as long,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          COV_STATE_ID as long,",
						"          COVERAGE_EFFECTIVE_DATE as timestamp,",
						"          COVERAGE_EXPIRATION_DATE as timestamp,",
						"          ASL_CODE as string,",
						"          ASSL_CODE as string,",
						"          ASL_CODE_GBL as string,",
						"          ASSL_CODE_GBL as string,",
						"          CLASSIFICATION_CODE_ID as long,",
						"          CLASSIFICATION_CODE_OVID as long,",
						"          COVERAGE_CODE as string,",
						"          RETROACTIVE_DATE as timestamp,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> coverageStagingLookup",
						"source(output(",
						"          maxId as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT isnull(MAX(COVERAGE_ID), 0) as maxId\\nFROM dbo.POL_COVERAGE',",
						"     format: 'query') ~> coverageStagingMaxId",
						"derivedColumn1 compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet1@(output1)",
						"policyCoverageSource select(mapColumn(",
						"          Policy,",
						"          ARICCoverageDescription,",
						"          COVERAGE_LINE = CoverageDescription,",
						"          COVERAGE_EFFECTIVE_DATE = Cov_effective_Date,",
						"          COVERAGE_EXPIRATION_DATE = Cov_Expiry_Date,",
						"          ARICLOB,",
						"          ARICCoverageCode = ARICCOverageCode,",
						"          ARICCoverageSequence,",
						"          ARICGroupCode,",
						"          PrimaryPremiumStateCode",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"policyStaging select(mapColumn(",
						"          POLICY_ID,",
						"          POLICY_OVID = POLICY_VID,",
						"          POLICY_NUMBER",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select2",
						"exists1, select2 join(Policy == POLICY_NUMBER,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> policyJoin",
						"coverageCodeStaging select(mapColumn(",
						"          COVERAGE_CODE_ID,",
						"          COVERAGE_CODE,",
						"          COVERAGE_DESCRIPTION",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select3",
						"policyJoin, select3 join(ARICCoverageDescription == COVERAGE_DESCRIPTION,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> coverageCodeJoin",
						"coverageCodeJoin select(mapColumn(",
						"          COVERAGE_EFFECTIVE_DATE,",
						"          COVERAGE_EXPIRATION_DATE,",
						"          POLICY_ID,",
						"          POLICY_OVID,",
						"          COVERAGE_CODE_ID,",
						"          ARICLOB,",
						"          ARICCoverageCode,",
						"          ARICCoverageSequence,",
						"          ARICGroupCode,",
						"          PrimaryPremiumStateCode,",
						"          Policy",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select4",
						"select4 keyGenerate(output(skey as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> surrogateKey1",
						"surrogateKey1 derive(COVERAGE_ID = skey + maxIdCache#outputs()[1].maxId,",
						"          COVERAGE_VID = 1,",
						"          COVERAGE_CODE = concatWS('-', iif(isNull(ARICGroupCode), '', replace(ARICGroupCode, ' ', '')), iif(isNull(PrimaryPremiumStateCode), '', replace(PrimaryPremiumStateCode, ' ', '')) , iif(isNull(ARICLOB), '', replace(ARICLOB, ' ', '')), iif(isNull(ARICCoverageCode), '', replace(ARICCoverageCode, ' ', '')), toString(ARICCoverageSequence)),",
						"          SOURCE_KEY = concatWS('', Policy, iif(isNull(ARICGroupCode), '', replace(ARICGroupCode, ' ', '')), iif(isNull(PrimaryPremiumStateCode), '', replace(PrimaryPremiumStateCode, ' ', '')) , iif(isNull(ARICLOB), '', replace(ARICLOB, ' ', '')), iif(isNull(ARICCoverageCode), '', replace(ARICCoverageCode, ' ', '')), toString(ARICCoverageSequence))) ~> derivedColumn1",
						"select1, coverageStagingLookup exists(concatWS('', Policy, iif(isNull(ARICGroupCode), '', replace(ARICGroupCode, ' ', '')), iif(isNull(PrimaryPremiumStateCode), '', replace(PrimaryPremiumStateCode, ' ', '')) , iif(isNull(ARICLOB), '', replace(ARICLOB, ' ', '')), iif(isNull(ARICCoverageCode), '', replace(ARICCoverageCode, ' ', '')), toString(ARICCoverageSequence)) == SOURCE_KEY,",
						"     negate:true,",
						"     broadcast: 'auto')~> exists1",
						"flowlet1@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          COVERAGE_ID as long,",
						"          COVERAGE_VID as long,",
						"          COVERAGE_CODE_ID as long,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          COV_STATE_ID as long,",
						"          COVERAGE_EFFECTIVE_DATE as timestamp,",
						"          COVERAGE_EXPIRATION_DATE as timestamp,",
						"          ASL_CODE as string,",
						"          ASSL_CODE as string,",
						"          ASL_CODE_GBL as string,",
						"          ASSL_CODE_GBL as string,",
						"          CLASSIFICATION_CODE_ID as long,",
						"          CLASSIFICATION_CODE_OVID as long,",
						"          COVERAGE_CODE as string,",
						"          RETROACTIVE_DATE as timestamp,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> coverageStaging",
						"coverageStagingMaxId sink(validateSchema: false,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     store: 'cache',",
						"     format: 'inline',",
						"     output: false,",
						"     saveOrder: 1) ~> maxIdCache"
					]
				}
			},
			"dependsOn": []
		}
	]
}