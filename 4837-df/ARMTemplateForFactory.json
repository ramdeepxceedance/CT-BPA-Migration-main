{
	"$schema": "http://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
	"contentVersion": "1.0.0.0",
	"parameters": {
		"factoryName": {
			"type": "string",
			"metadata": "Data Factory name",
			"defaultValue": "4837-df"
		},
		"AzureBlobStorage1_connectionString": {
			"type": "secureString",
			"metadata": "Secure string for 'connectionString' of 'AzureBlobStorage1'"
		},
		"RestService1_clientSecret": {
			"type": "secureString",
			"metadata": "Secure string for 'clientSecret' of 'RestService1'"
		},
		"RestService2_clientSecret": {
			"type": "secureString",
			"metadata": "Secure string for 'clientSecret' of 'RestService2'"
		},
		"ecmmigrationdb_connectionString": {
			"type": "secureString",
			"metadata": "Secure string for 'connectionString' of 'ecmmigrationdb'"
		},
		"ls_DM_Stage_Target_connectionString": {
			"type": "secureString",
			"metadata": "Secure string for 'connectionString' of 'ls_DM_Stage_Target'"
		},
		"postgresTest_connectionString": {
			"type": "secureString",
			"metadata": "Secure string for 'connectionString' of 'postgresTest'"
		},
		"sourceStageDB_connectionString": {
			"type": "secureString",
			"metadata": "Secure string for 'connectionString' of 'sourceStageDB'"
		},
		"ssSqlServer_connectionString": {
			"type": "secureString",
			"metadata": "Secure string for 'connectionString' of 'ssSqlServer'",
			"defaultValue": "Integrated Security=False;Data Source=@{linkedService().dbUrl};Initial Catalog=@{linkedService().dbName};User ID=@{linkedService().dbUsername};Password=@{linkedService().dbPassword}"
		},
		"submitService_clientSecret": {
			"type": "secureString",
			"metadata": "Secure string for 'clientSecret' of 'submitService'"
		},
		"RestService1_properties_typeProperties_url": {
			"type": "string",
			"defaultValue": "https://bpa-dev.chainthat.net"
		},
		"RestService1_properties_typeProperties_clientId": {
			"type": "string",
			"defaultValue": "adf-client"
		},
		"RestService2_properties_typeProperties_url": {
			"type": "string",
			"defaultValue": "https://bpa-ecm-migration.chainthat.net"
		},
		"RestService2_properties_typeProperties_clientId": {
			"type": "string",
			"defaultValue": "adf-client"
		},
		"sampleLogin_properties_typeProperties_url": {
			"type": "string",
			"defaultValue": "http://restapi.adequateshop.com"
		},
		"submitService_properties_typeProperties_url": {
			"type": "string",
			"defaultValue": "https://bpa-tst.chainthat.net/policyadmin-api/submitPolicyInformation/v1/policy"
		},
		"submitService_properties_typeProperties_clientId": {
			"type": "string",
			"defaultValue": "ecm-claims-client"
		},
		"AzureBlobStorageECM_properties_privateLinkResourceId": {
			"type": "string",
			"defaultValue": "/subscriptions/dcd09377-b8fe-4215-bcee-03ff11e989d6/resourceGroups/CT-AKS-RG-BPA-ECM-MIGRATION/providers/Microsoft.Storage/storageAccounts/bpaecmmigration"
		},
		"AzureBlobStorageECM_properties_groupId": {
			"type": "string",
			"defaultValue": "blob"
		}
	},
	"variables": {
		"factoryId": "[concat('Microsoft.DataFactory/factories/', parameters('factoryName'))]"
	},
	"resources": [
		{
			"name": "[concat(parameters('factoryName'), '/pl_Target_policy_master')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "ForEach1",
						"type": "ForEach",
						"dependsOn": [
							{
								"activity": "Set round",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@range(variables('lowerBound'), variables('round'))",
								"type": "Expression"
							},
							"isSequential": true,
							"activities": [
								{
									"name": "policyRun",
									"type": "ExecutePipeline",
									"dependsOn": [],
									"policy": {
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"pipeline": {
											"referenceName": "pl_api_policy",
											"type": "PipelineReference"
										},
										"waitOnCompletion": true,
										"parameters": {
											"lb": {
												"value": "@variables('lowerBound')",
												"type": "Expression"
											},
											"hb": {
												"value": "@variables('higherBound')",
												"type": "Expression"
											}
										}
									}
								},
								{
									"name": "update lowerbound",
									"type": "SetVariable",
									"dependsOn": [
										{
											"activity": "policyRun",
											"dependencyConditions": [
												"Completed"
											]
										}
									],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "lowerBound",
										"value": {
											"value": "@variables('higherBound')",
											"type": "Expression"
										}
									}
								},
								{
									"name": "update higherbound",
									"type": "SetVariable",
									"dependsOn": [
										{
											"activity": "update lowerbound",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "higherBound",
										"value": {
											"value": "@add(variables('lowerBound'),500)",
											"type": "Expression"
										}
									}
								}
							]
						}
					},
					{
						"name": "Set lowerBound",
						"type": "SetVariable",
						"dependsOn": [],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "lowerBound",
							"value": 1
						}
					},
					{
						"name": "Set higherbound",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "Set lowerBound",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "higherBound",
							"value": 500
						}
					},
					{
						"name": "Set round",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "Set higherbound",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "round",
							"value": 18
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"variables": {
					"higherBound": {
						"type": "Integer"
					},
					"round": {
						"type": "Integer"
					},
					"lowerBound": {
						"type": "Integer"
					}
				},
				"folder": {
					"name": "Target Data Movement"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/pipelines/pl_api_policy')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_api_agency')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Target Agency Lookup",
						"type": "Lookup",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "AzurePostgreSqlSource",
								"query": "select agency_id, json_data from agency where bpa_party_code is null",
								"partitionOption": "None"
							},
							"dataset": {
								"referenceName": "ds_stage_agency",
								"type": "DatasetReference",
								"parameters": {}
							},
							"firstRowOnly": false
						}
					},
					{
						"name": "Iterate Agency JSON",
						"type": "ForEach",
						"dependsOn": [
							{
								"activity": "Get token",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@activity('Target Agency Lookup').output.value",
								"type": "Expression"
							},
							"isSequential": true,
							"activities": [
								{
									"name": "Create Agency",
									"type": "WebActivity",
									"dependsOn": [],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"method": "POST",
										"headers": {
											"Authorization": {
												"value": "Bearer @{activity('Get token').output.access_token}",
												"type": "Expression"
											},
											"Content-Type": "application/json"
										},
										"url": {
											"value": "@{pipeline().globalParameters.baseURL}/party-api/submitPartyInformations/v1/party",
											"type": "Expression"
										},
										"body": {
											"value": "@json(replace('{\"messageInformation\":{\"sender\":\"adfclient\",\"userInfo\":{\"partyDetails\":[{\"partyCode\":\"\",\"partyRole\":\"\"}],\"userName\":\"Viswa\"},\"businessPurposeTypeCode\":\"xyz\",\"trackingNumber\":\"09cbf4b4-2b59-f42c-3ce2-e8c34e737398\"},\"party\":[dynamicData]', 'dynamicData' , string(item().json_data)))",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Update Agency",
									"type": "Lookup",
									"dependsOn": [
										{
											"activity": "Create Agency",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"source": {
											"type": "AzurePostgreSqlSource",
											"query": {
												"value": "update agency set bpa_party_id='@{activity('Create Agency').output.success[0].partyId}', bpa_party_code='@{activity('Create Agency').output.success[0].partyCode}', party_name='@{activity('Create Agency').output.success[0].fullName}' where agency_id=@{string(item().agency_id)};\n\nselect * from agency limit 1",
												"type": "Expression"
											},
											"partitionOption": "None"
										},
										"dataset": {
											"referenceName": "ds_stage_party",
											"type": "DatasetReference",
											"parameters": {}
										}
									}
								}
							]
						}
					},
					{
						"name": "Get token",
						"type": "WebActivity",
						"dependsOn": [
							{
								"activity": "Target Agency Lookup",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"method": "POST",
							"headers": {
								"Content-Type": "application/x-www-form-urlencoded"
							},
							"url": {
								"value": "@{pipeline().globalParameters.baseURL}/auth/realms/ecm/protocol/openid-connect/token",
								"type": "Expression"
							},
							"body": {
								"value": "grant_type=client_credentials&client_id=@{pipeline().globalParameters.client_id}&client_secret=@{pipeline().globalParameters.client_secret}",
								"type": "Expression"
							}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "Target Data Movement"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ds_stage_agency')]",
				"[concat(variables('factoryId'), '/datasets/ds_stage_party')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_api_party')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Target Party Lookup",
						"type": "Lookup",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "AzurePostgreSqlSource",
								"query": "select party_id,json_data from partyidentity where bpa_party_code is null",
								"partitionOption": "None"
							},
							"dataset": {
								"referenceName": "ds_stage_party",
								"type": "DatasetReference",
								"parameters": {}
							},
							"firstRowOnly": false
						}
					},
					{
						"name": "Iterate Party JSON",
						"type": "ForEach",
						"dependsOn": [
							{
								"activity": "Get token",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@activity('Target Party Lookup').output.value",
								"type": "Expression"
							},
							"isSequential": true,
							"activities": [
								{
									"name": "Create Party",
									"type": "WebActivity",
									"dependsOn": [],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"method": "POST",
										"headers": {
											"Authorization": {
												"value": "Bearer @{activity('Get token').output.access_token}",
												"type": "Expression"
											},
											"Content-Type": "application/json"
										},
										"url": {
											"value": "@{pipeline().globalParameters.baseURL}/party-api/submitPartyInformations/v1/party",
											"type": "Expression"
										},
										"body": {
											"value": "@json(replace('{\"messageInformation\":{\"sender\":\"adfclient\",\"userInfo\":{\"partyDetails\":[{\"partyCode\":\"\",\"partyRole\":\"\"}],\"userName\":\"Viswa\"},\"businessPurposeTypeCode\":\"xyz\",\"trackingNumber\":\"09cbf4b4-2b59-f42c-3ce2-e8c34e737398\"},\"party\":[dynamicData]', 'dynamicData' , string(item().json_data)))",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Update Party",
									"type": "Lookup",
									"dependsOn": [
										{
											"activity": "Create Party",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"source": {
											"type": "AzurePostgreSqlSource",
											"query": {
												"value": "update partyidentity set bpa_party_id='@{activity('Create Party').output.success[0].partyId}', bpa_party_code='@{activity('Create Party').output.success[0].partyCode}', party_name='@{activity('Create Party').output.success[0].fullName}' where party_id=@{string(item().party_id)};\n\nselect  * from partyidentity limit 1\n",
												"type": "Expression"
											},
											"partitionOption": "None"
										},
										"dataset": {
											"referenceName": "ds_stage_party",
											"type": "DatasetReference",
											"parameters": {}
										}
									}
								}
							]
						}
					},
					{
						"name": "Get token",
						"type": "WebActivity",
						"dependsOn": [
							{
								"activity": "Target Party Lookup",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"method": "POST",
							"headers": {
								"Content-Type": "application/x-www-form-urlencoded"
							},
							"url": {
								"value": "@{pipeline().globalParameters.baseURL}/auth/realms/ecm/protocol/openid-connect/token\n",
								"type": "Expression"
							},
							"body": {
								"value": "grant_type=client_credentials&client_id=@{pipeline().globalParameters.client_id}&client_secret=@{pipeline().globalParameters.client_secret}",
								"type": "Expression"
							}
						}
					}
				],
				"concurrency": 4,
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "Target Data Movement"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ds_stage_party')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_api_policy')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Target Policy Lookup",
						"type": "Lookup",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "AzurePostgreSqlSource",
								"query": {
									"value": "@concat( 'SELECT * FROM POLICY where policy_id BETWEEN ',string(pipeline().parameters.lb) ,' and ',string(pipeline().parameters.hb))",
									"type": "Expression"
								},
								"partitionOption": "None"
							},
							"dataset": {
								"referenceName": "ds_stage_policy",
								"type": "DatasetReference",
								"parameters": {}
							},
							"firstRowOnly": false
						}
					},
					{
						"name": "Iterate Policy JSON",
						"type": "ForEach",
						"dependsOn": [
							{
								"activity": "Set access token",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@activity('Target Policy Lookup').output.value",
								"type": "Expression"
							},
							"isSequential": false,
							"batchCount": 50,
							"activities": [
								{
									"name": "Create Policy",
									"type": "WebActivity",
									"dependsOn": [],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"method": "POST",
										"headers": {
											"Authorization": {
												"value": "Bearer @{variables('access_token')}",
												"type": "Expression"
											},
											"Content-Type": "application/json"
										},
										"url": {
											"value": "@{pipeline().globalParameters.baseURL}/policyadmin-api/initiateRenewal/v1/renewal",
											"type": "Expression"
										},
										"connectVia": {
											"referenceName": "integrationRuntime2-selfhosted",
											"type": "IntegrationRuntimeReference"
										},
										"body": {
											"value": "@json(replace(concat('{\"messageInformation\": {\n        \"businessPurposeTypeCode\": \"RWL\",\n        \"trackingNumber\": \"ed5c2e08-7714-446c-84d1-0f67a7964593\",\n        \"messageStatus\": {\n            \"statusCode\": 200,\n            \"statusDescription\": \"Policy created \",\n            \"successStatusCode\": \"200\"\n        },\n        \"userInfo\": {\n            \"userName\": \"policyadmin\"\n        },\n        \"userJourneyType\": \"empty\"\n    },\n    \"policy\": dynamicData,\n    \"renewalOf\":\"', string(item().policy_number),'\",\n    \"sourcePolicyEffectiveDate\": \"2023-12-02\",\n    \"sourcePolicyExpirationDate\": \"2023-12-31\",\n    \"typeCode\": \"MANUAL\",\n    \"renewalTriggerInDays\": 60 }'), 'dynamicData' , string(item().json_data)))",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Update Succeed Policy in Tracker",
									"type": "Lookup",
									"dependsOn": [
										{
											"activity": "Create Policy",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"source": {
											"type": "AzurePostgreSqlSource",
											"query": {
												"value": "insert into policy_tracker(policy_id, policy_number, bpa_tracking_number, status, bpa_tenant_id, response_description) \nvalues(@{string(item().policy_id)},'@{string(item().policy_number)}', '@{activity('Create Policy').output.messageInformation.trackingNumber}','@{activity('Create Policy').output.messageInformation.messageStatus.statusCode}', '@{activity('Create Policy').output.messageInformation.userInfo.tenantId}', '@{activity('Create Policy').output.messageInformation.messageStatus.statusDescription}');\n\nselect * from policy_tracker limit 1",
												"type": "Expression"
											},
											"partitionOption": "None"
										},
										"dataset": {
											"referenceName": "ds_stage_policytracker",
											"type": "DatasetReference",
											"parameters": {}
										}
									}
								},
								{
									"name": "Update Failed Policy in Tracker",
									"type": "Lookup",
									"dependsOn": [
										{
											"activity": "Create Policy",
											"dependencyConditions": [
												"Failed"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"source": {
											"type": "AzurePostgreSqlSource",
											"query": {
												"value": "insert into policy_tracker(policy_id, policy_number, bpa_tracking_number, status, response_description) \nvalues(@{string(item().policy_id)},'@{string(item().policy_number)}', '@{activity('Create Policy').output.messageInformation.trackingNumber}','@{activity('Create Policy').output.messageInformation.messageStatus.statusCode}', '@{activity('Create Policy').output.messageInformation.messageStatus.errors}');\n\nselect * from policy_tracker limit 1",
												"type": "Expression"
											},
											"partitionOption": "None"
										},
										"dataset": {
											"referenceName": "ds_stage_policytracker",
											"type": "DatasetReference",
											"parameters": {}
										}
									}
								},
								{
									"name": "Lookup1",
									"type": "Lookup",
									"dependsOn": [
										{
											"activity": "Update Failed Policy in Tracker",
											"dependencyConditions": [
												"Failed"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"source": {
											"type": "AzurePostgreSqlSource",
											"query": {
												"value": "insert into policy_tracker(policy_id, policy_number, status, response_description) \nvalues(@{string(item().policy_id)},'@{string(item().policy_number)}','400', '@{activity('Create Policy').output.messageInformation}');\n\nselect * from policy_tracker limit 1",
												"type": "Expression"
											},
											"partitionOption": "None"
										},
										"dataset": {
											"referenceName": "ds_stage_policytracker",
											"type": "DatasetReference",
											"parameters": {}
										}
									}
								}
							]
						}
					},
					{
						"name": "Get token",
						"type": "WebActivity",
						"dependsOn": [
							{
								"activity": "Target Policy Lookup",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"method": "POST",
							"headers": {
								"Content-Type": "application/x-www-form-urlencoded"
							},
							"url": {
								"value": "@{pipeline().globalParameters.baseURL}/auth/realms/ecm/protocol/openid-connect/token",
								"type": "Expression"
							},
							"connectVia": {
								"referenceName": "integrationRuntime2-selfhosted",
								"type": "IntegrationRuntimeReference"
							},
							"body": {
								"value": "grant_type=client_credentials&client_id=@{pipeline().globalParameters.client_id}&client_secret=@{pipeline().globalParameters.client_secret}",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Set access token",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "Get token",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "access_token",
							"value": {
								"value": "@{activity('Get token').output.access_token}",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Stop Refreshing Token",
						"type": "SetVariable",
						"state": "Inactive",
						"onInactiveMarkAs": "Succeeded",
						"dependsOn": [
							{
								"activity": "Iterate Policy JSON",
								"dependencyConditions": [
									"Completed"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "continueLoop",
							"value": true
						}
					},
					{
						"name": "Refresh token",
						"type": "Until",
						"state": "Inactive",
						"onInactiveMarkAs": "Succeeded",
						"dependsOn": [
							{
								"activity": "Set access token",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"expression": {
								"value": "@variables('continueLoop')",
								"type": "Expression"
							},
							"activities": [
								{
									"name": "Get new token",
									"type": "WebActivity",
									"dependsOn": [
										{
											"activity": "Wait",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"method": "POST",
										"headers": {
											"Content-Type": "application/x-www-form-urlencoded"
										},
										"url": {
											"value": "@{pipeline().globalParameters.baseURL}/auth/realms/ecm/protocol/openid-connect/token\n",
											"type": "Expression"
										},
										"body": {
											"value": "grant_type=client_credentials&client_id=@{pipeline().globalParameters.client_id}&client_secret=@{pipeline().globalParameters.client_secret}",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Wait",
									"type": "Wait",
									"dependsOn": [],
									"userProperties": [],
									"typeProperties": {
										"waitTimeInSeconds": 1
									}
								},
								{
									"name": "Set new token",
									"type": "SetVariable",
									"dependsOn": [
										{
											"activity": "Get new token",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "access_token",
										"value": {
											"value": "@{activity('Get new token').output.access_token}",
											"type": "Expression"
										}
									}
								}
							],
							"timeout": "0.12:00:00"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"lb": {
						"type": "int",
						"defaultValue": 1
					},
					"hb": {
						"type": "int",
						"defaultValue": 4
					}
				},
				"variables": {
					"access_token": {
						"type": "String"
					},
					"continueLoop": {
						"type": "Boolean",
						"defaultValue": false
					},
					"lowerBound": {
						"type": "Integer"
					},
					"higherBound": {
						"type": "Integer"
					},
					"round": {
						"type": "Integer"
					}
				},
				"folder": {
					"name": "Target Data Movement"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ds_stage_policy')]",
				"[concat(variables('factoryId'), '/integrationRuntimes/integrationRuntime2-selfhosted')]",
				"[concat(variables('factoryId'), '/datasets/ds_stage_policytracker')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_api_token_only')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Get token",
						"type": "WebActivity",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"method": "POST",
							"headers": {
								"Content-Type": "application/x-www-form-urlencoded"
							},
							"url": {
								"value": "@{pipeline().globalParameters.tokenBaseURL}/auth/realms/ecm/protocol/openid-connect/token",
								"type": "Expression"
							},
							"body": {
								"value": "grant_type=client_credentials&client_id=@{pipeline().globalParameters.client_id}&client_secret=@{pipeline().globalParameters.client_secret}",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Set access token",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "Get token",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "access_token",
							"value": {
								"value": "@{activity('Get token').output.access_token}",
								"type": "Expression"
							}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"variables": {
					"access_token": {
						"type": "String"
					},
					"continueLoop": {
						"type": "Boolean",
						"defaultValue": false
					}
				},
				"folder": {
					"name": "Target Data Movement"
				},
				"annotations": []
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_bpa_limt_ref')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "empLimits",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_bpa_product_Ref",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"source2": {},
									"sink1": {}
								}
							},
							"staging": {},
							"integrationRuntime": {
								"referenceName": "integrationRuntime2-selfhosted",
								"type": "IntegrationRuntimeReference"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "cfaLimits",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "empLimits",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_bpa_cfa_limits",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"source2": {},
									"pkey": {},
									"limitMeta": {},
									"nextPkey": {}
								}
							},
							"staging": {},
							"integrationRuntime": {
								"referenceName": "integrationRuntime2-selfhosted",
								"type": "IntegrationRuntimeReference"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "Target Data Movement"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_bpa_product_Ref')]",
				"[concat(variables('factoryId'), '/integrationRuntimes/integrationRuntime2-selfhosted')]",
				"[concat(variables('factoryId'), '/dataflows/df_bpa_cfa_limits')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_cfa_coverage_meta_upload')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Data flow1",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_CFA_coverages_meta",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"source1": {},
									"source2": {},
									"sink1": {},
									"sink2": {}
								}
							},
							"staging": {},
							"integrationRuntime": {
								"referenceName": "integrationRuntime2-selfhosted",
								"type": "IntegrationRuntimeReference"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "Target Data Movement/cfa"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_CFA_coverages_meta')]",
				"[concat(variables('factoryId'), '/integrationRuntimes/integrationRuntime2-selfhosted')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_cfa_limit_meta_upload')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "limitMetaUpload",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_bpa_cfa_limits",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"source2": {},
									"pkey": {},
									"limitMeta": {},
									"nextPkey": {}
								}
							},
							"staging": {},
							"integrationRuntime": {
								"referenceName": "integrationRuntime2-selfhosted",
								"type": "IntegrationRuntimeReference"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "Target Data Movement/cfa"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_bpa_cfa_limits')]",
				"[concat(variables('factoryId'), '/integrationRuntimes/integrationRuntime2-selfhosted')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_compare_premium')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Compare Premium - Risk",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_target_premiumComparison_risk",
								"type": "DataFlowReference",
								"parameters": {
									"policyPrefix": {
										"value": "'@{pipeline().globalParameters.policyPrefix}'",
										"type": "Expression"
									},
									"policies": {
										"value": "@pipeline().globalParameters.policies",
										"type": "Expression"
									}
								},
								"datasetParameters": {
									"targetQuoteInfo": {},
									"sourcePremium": {},
									"coverageSectionLookup": {},
									"stagingPolicyRisk": {},
									"stageRiskDetails": {},
									"sourceLocation": {},
									"horseLookup": {},
									"sink1": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "Compare Premium - Policy",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "Compare Premium - Risk",
								"dependencyConditions": [
									"Completed"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_target_premiumComparison_policy",
								"type": "DataFlowReference",
								"parameters": {
									"policyPrefix": {
										"value": "'@{pipeline().globalParameters.policyPrefix}'",
										"type": "Expression"
									},
									"policies": {
										"value": "@pipeline().globalParameters.policies",
										"type": "Expression"
									}
								},
								"datasetParameters": {
									"targetQuoteInfo": {},
									"sourcePremium": {},
									"coverageSectionLookup": {},
									"sink1": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "utility/rating"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_target_premiumComparison_risk')]",
				"[concat(variables('factoryId'), '/dataflows/df_target_premiumComparison_policy')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_premium_report')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Premium Report",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_target_premium_report",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"source1": {},
									"sink1": {}
								}
							},
							"staging": {},
							"integrationRuntime": {
								"referenceName": "integrationRuntime2-selfhosted",
								"type": "IntegrationRuntimeReference"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "utility/rating"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_target_premium_report')]",
				"[concat(variables('factoryId'), '/integrationRuntimes/integrationRuntime2-selfhosted')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_quote_premium')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Policy Lookup",
						"type": "Lookup",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "AzurePostgreSqlSource",
								"query": {
									"value": "@concat( 'select policy_id, policy_number from policy_tracker where status= ''', '200',  ''' and policy_id BETWEEN ',string(pipeline().parameters.lb) ,' and ',string(pipeline().parameters.hb))",
									"type": "Expression"
								},
								"partitionOption": "None"
							},
							"dataset": {
								"referenceName": "joinTablePostgres",
								"type": "DatasetReference",
								"parameters": {}
							},
							"firstRowOnly": false
						}
					},
					{
						"name": "Get token",
						"type": "WebActivity",
						"dependsOn": [
							{
								"activity": "Policy Lookup",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"method": "POST",
							"headers": {
								"Content-Type": "application/x-www-form-urlencoded"
							},
							"url": {
								"value": "@{pipeline().globalParameters.baseURL}/auth/realms/ecm/protocol/openid-connect/token\n",
								"type": "Expression"
							},
							"body": {
								"value": "grant_type=client_credentials&client_id=@{pipeline().globalParameters.client_id}&client_secret=@{pipeline().globalParameters.client_secret}",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Iterate QuoteInfo JSON",
						"type": "ForEach",
						"dependsOn": [
							{
								"activity": "Get token",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@activity('Policy Lookup').output.value",
								"type": "Expression"
							},
							"isSequential": false,
							"batchCount": 50,
							"activities": [
								{
									"name": "Search Policy By RenewalOf",
									"type": "WebActivity",
									"dependsOn": [],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"method": "POST",
										"headers": {
											"Authorization": {
												"value": "Bearer @{activity('Get token').output.access_token}",
												"type": "Expression"
											},
											"Content-Type": "application/json"
										},
										"url": {
											"value": "@{pipeline().globalParameters.baseURL}/policyadmin-api/searchPolicyInformation/v1/policy",
											"type": "Expression"
										},
										"body": {
											"value": "@json(replace('{\"searchParams\":\"renewalOf:dynamicData\"}', 'dynamicData' , string(item().policy_number)))",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Lookup2",
									"type": "Lookup",
									"dependsOn": [
										{
											"activity": "Search Policy By RenewalOf",
											"dependencyConditions": [
												"Failed"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"source": {
											"type": "AzurePostgreSqlSource",
											"query": {
												"value": "INSERT INTO quote_info (policy_id, status, api_stage, response)\nVALUES (@{string(item().policy_id)}, 'failed', 'Search Policy By RenewalOf', '@{activity('Search Policy By RenewalOf').output.messageInformation}');\n\nselect * from quote_info limit 1;\n",
												"type": "Expression"
											},
											"partitionOption": "None"
										},
										"dataset": {
											"referenceName": "ds_target_quoteInfo",
											"type": "DatasetReference",
											"parameters": {}
										}
									}
								},
								{
									"name": "SearchQuote",
									"type": "WebActivity",
									"dependsOn": [
										{
											"activity": "Search Policy By RenewalOf",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"method": "POST",
										"headers": {
											"Authorization": {
												"value": "Bearer @{activity('Get token').output.access_token}",
												"type": "Expression"
											},
											"Content-Type": "application/json"
										},
										"url": {
											"value": "@{pipeline().globalParameters.baseURL}/policyadmin-api/searchQuote/v1/quote",
											"type": "Expression"
										},
										"body": {
											"value": "@json(replace('{\"searchParams\":\"referenceNumber:*dynamicData*\"}', 'dynamicData' , activity('Search Policy By RenewalOf').output.policy[0].referenceNumber))",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Retrieve QuoteInfo",
									"type": "WebActivity",
									"dependsOn": [
										{
											"activity": "SearchQuote",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"method": "GET",
										"headers": {
											"Authorization": {
												"value": "Bearer @{activity('Get token').output.access_token}",
												"type": "Expression"
											},
											"Content-Type": "application/json"
										},
										"url": {
											"value": "@{pipeline().globalParameters.baseURL}/policyadmin-api/retrieveQuoteInformation/v1/quote/@{activity('SearchQuote').output.quote[0].quoteNumber}?identifierType=number",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Lookup3",
									"type": "Lookup",
									"dependsOn": [
										{
											"activity": "SearchQuote",
											"dependencyConditions": [
												"Failed"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"source": {
											"type": "AzurePostgreSqlSource",
											"query": {
												"value": "INSERT INTO quote_info (policy_id, policy_reference, status, api_stage, response)\nVALUES (@{string(item().policy_id)}, '@{activity('Search Policy By RenewalOf').output.policy[0].referenceNumber}', 'failed', 'Search Quote', '@{activity('SearchQuote').output.messageInformation}');\n\nselect * from quote_info limit 1;",
												"type": "Expression"
											},
											"partitionOption": "None"
										},
										"dataset": {
											"referenceName": "ds_target_quoteInfo",
											"type": "DatasetReference",
											"parameters": {}
										}
									}
								},
								{
									"name": "Lookup4",
									"type": "Lookup",
									"dependsOn": [
										{
											"activity": "Retrieve QuoteInfo",
											"dependencyConditions": [
												"Failed"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"source": {
											"type": "AzurePostgreSqlSource",
											"query": {
												"value": "INSERT INTO quote_info (policy_id, policy_reference, quote_number, status, api_stage, response)\nVALUES (@{string(item().policy_id)}, '@{activity('Search Policy By RenewalOf').output.policy[0].referenceNumber}', '@{activity('SearchQuote').output.quote[0].quoteNumber}','failed', 'Retrieve QuoteInfo', '@{activity('Retrieve QuoteInfo').output.messageInformation}');\n\nselect * from quote_info limit 1;",
												"type": "Expression"
											},
											"partitionOption": "None"
										},
										"dataset": {
											"referenceName": "ds_target_quoteInfo",
											"type": "DatasetReference",
											"parameters": {}
										}
									}
								},
								{
									"name": "Lookup5",
									"type": "Lookup",
									"dependsOn": [
										{
											"activity": "Calculate Premium",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"source": {
											"type": "AzurePostgreSqlSource",
											"query": {
												"value": "INSERT INTO quote_info (policy_id, policy_number, policy_reference, quote_number, status, api_stage, quote, response)\nVALUES (@{string(item().policy_id)}, '@{string(item().policy_number)}', '@{activity('Search Policy By RenewalOf').output.policy[0].referenceNumber}', '@{activity('SearchQuote').output.quote[0].quoteNumber}','success', 'Calculate Premium', '@{replace(string(activity('Retrieve QuoteInfo').output.quote), '''', '')}', '@{replace(string(activity('Calculate Premium').output.riskDetail), '''', '')}');\n\nselect * from quote_info limit 1;\n\n",
												"type": "Expression"
											},
											"partitionOption": "None"
										},
										"dataset": {
											"referenceName": "ds_target_quoteInfo",
											"type": "DatasetReference",
											"parameters": {}
										}
									}
								},
								{
									"name": "Calculate Premium",
									"type": "WebActivity",
									"dependsOn": [
										{
											"activity": "Retrieve QuoteInfo",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"method": "POST",
										"headers": {
											"Authorization": {
												"value": "Bearer @{activity('Get token').output.access_token}",
												"type": "Expression"
											},
											"Content-Type": "application/json"
										},
										"url": {
											"value": "@{pipeline().globalParameters.baseURL}/policyadmin-api/calculateRatedValues/v1/quote/@{activity('SearchQuote').output.quote[0].quoteNumber}",
											"type": "Expression"
										},
										"body": {
											"value": "@json(replace('{\"messageInformation\":{\"sender\":\"adfclient\",\"userInfo\":{\"partyDetails\":[{\"partyCode\":\"\",\"partyRole\":\"\"}],\"userName\":\"Viswa\"},\"businessPurposeTypeCode\":\"xyz\",\"trackingNumber\":\"09cbf4b4-2b59-f42c-3ce2-e8c34e737398\"},\"quote\":dynamicData', 'dynamicData' , string(activity('Retrieve QuoteInfo').output.quote)))",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Lookup6",
									"type": "Lookup",
									"dependsOn": [
										{
											"activity": "Calculate Premium",
											"dependencyConditions": [
												"Failed"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"source": {
											"type": "AzurePostgreSqlSource",
											"query": {
												"value": "INSERT INTO quote_info (policy_id, policy_number, policy_reference, quote_number, status, api_stage, quote, response)\nVALUES (@{string(item().policy_id)}, '@{string(item().policy_number)}', '@{activity('Search Policy By RenewalOf').output.policy[0].referenceNumber}', '@{activity('SearchQuote').output.quote[0].quoteNumber}','failed', 'Calculate Premium', '@{activity('Retrieve QuoteInfo').output.quote}', '@{replace(string(activity('Calculate Premium').output.messageInformation), '''', '')}');\n\nselect * from quote_info limit 1;",
												"type": "Expression"
											},
											"partitionOption": "None"
										},
										"dataset": {
											"referenceName": "ds_target_quoteInfo",
											"type": "DatasetReference",
											"parameters": {}
										}
									}
								}
							]
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"lb": {
						"type": "int",
						"defaultValue": 617
					},
					"hb": {
						"type": "int",
						"defaultValue": 617
					}
				},
				"folder": {
					"name": "utility/rating"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/joinTablePostgres')]",
				"[concat(variables('factoryId'), '/datasets/ds_target_quoteInfo')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_rater_report_deprecated')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "QuoteInfo Lookup",
						"type": "Lookup",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "AzurePostgreSqlSource",
								"query": {
									"value": "@concat( 'select policy_number , quote_number, quote, policy_id from quote_info where policy_id BETWEEN ',string(pipeline().parameters.lb) ,' and ',string(pipeline().parameters.hb))",
									"type": "Expression"
								},
								"partitionOption": "None"
							},
							"dataset": {
								"referenceName": "ds_target_quoteInfo",
								"type": "DatasetReference",
								"parameters": {}
							},
							"firstRowOnly": false
						}
					},
					{
						"name": "Iterate QuoteInfo JSON",
						"type": "ForEach",
						"dependsOn": [
							{
								"activity": "Get token",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@activity('QuoteInfo Lookup').output.value",
								"type": "Expression"
							},
							"isSequential": false,
							"batchCount": 50,
							"activities": [
								{
									"name": "Calculate Premium",
									"type": "WebActivity",
									"dependsOn": [],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"method": "POST",
										"headers": {
											"Authorization": {
												"value": "Bearer @{activity('Get token').output.access_token}",
												"type": "Expression"
											},
											"Content-Type": "application/json"
										},
										"url": {
											"value": "@{pipeline().globalParameters.baseURL}/policyadmin-api/calculateRatedValues/v1/quote/item().quote_number",
											"type": "Expression"
										},
										"body": {
											"value": "@json(replace('{\"messageInformation\":{\"sender\":\"adfclient\",\"userInfo\":{\"partyDetails\":[{\"partyCode\":\"\",\"partyRole\":\"\"}],\"userName\":\"Viswa\"},\"businessPurposeTypeCode\":\"xyz\",\"trackingNumber\":\"09cbf4b4-2b59-f42c-3ce2-e8c34e737398\"},\"quote\":dynamicData', 'dynamicData' , string(item().quote)))",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Lookup1",
									"type": "Lookup",
									"dependsOn": [
										{
											"activity": "Calculate Premium",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"source": {
											"type": "AzurePostgreSqlSource",
											"query": {
												"value": "update quote_info set status='success', response='@{activity('Calculate Premium').output.riskDetail}' where policy_id=@{string(item().policy_id)};\n\nselect * from quote_info limit 1;",
												"type": "Expression"
											},
											"partitionOption": "None"
										},
										"dataset": {
											"referenceName": "ds_target_quoteInfo",
											"type": "DatasetReference",
											"parameters": {}
										}
									}
								},
								{
									"name": "Lookup2",
									"type": "Lookup",
									"dependsOn": [
										{
											"activity": "Calculate Premium",
											"dependencyConditions": [
												"Failed"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"source": {
											"type": "AzurePostgreSqlSource",
											"query": {
												"value": "update quote_info set status='failed', response='@{activity('Calculate Premium').output.messageInformation}' where policy_id=@{string(item().policy_id)};\n\nselect * from quote_info limit 1;",
												"type": "Expression"
											},
											"partitionOption": "None"
										},
										"dataset": {
											"referenceName": "ds_target_quoteInfo",
											"type": "DatasetReference",
											"parameters": {}
										}
									}
								}
							]
						}
					},
					{
						"name": "Get token",
						"type": "WebActivity",
						"dependsOn": [
							{
								"activity": "QuoteInfo Lookup",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"method": "POST",
							"headers": {
								"Content-Type": "application/x-www-form-urlencoded"
							},
							"url": {
								"value": "@{pipeline().globalParameters.baseURL}/auth/realms/ecm/protocol/openid-connect/token\n",
								"type": "Expression"
							},
							"body": {
								"value": "grant_type=client_credentials&client_id=@{pipeline().globalParameters.client_id}&client_secret=@{pipeline().globalParameters.client_secret}",
								"type": "Expression"
							}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"lb": {
						"type": "int"
					},
					"hb": {
						"type": "int"
					}
				},
				"variables": {
					"policy_id": {
						"type": "String"
					}
				},
				"folder": {
					"name": "utility"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ds_target_quoteInfo')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_rater_report_master')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "ForEach1",
						"type": "ForEach",
						"dependsOn": [
							{
								"activity": "Set round",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@range(variables('lowerBound'), variables('round'))",
								"type": "Expression"
							},
							"isSequential": true,
							"activities": [
								{
									"name": "raterReport",
									"type": "ExecutePipeline",
									"dependsOn": [],
									"policy": {
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"pipeline": {
											"referenceName": "pl_quote_premium",
											"type": "PipelineReference"
										},
										"waitOnCompletion": true,
										"parameters": {
											"lb": {
												"value": "@variables('lowerBound')",
												"type": "Expression"
											},
											"hb": {
												"value": "@variables('higherBound')",
												"type": "Expression"
											}
										}
									}
								},
								{
									"name": "update lowerbound",
									"type": "SetVariable",
									"dependsOn": [
										{
											"activity": "raterReport",
											"dependencyConditions": [
												"Completed"
											]
										}
									],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "lowerBound",
										"value": {
											"value": "@variables('higherBound')",
											"type": "Expression"
										}
									}
								},
								{
									"name": "update higherbound",
									"type": "SetVariable",
									"dependsOn": [
										{
											"activity": "update lowerbound",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "higherBound",
										"value": {
											"value": "@add(variables('lowerBound'),500)",
											"type": "Expression"
										}
									}
								}
							]
						}
					},
					{
						"name": "Set lowerBound",
						"type": "SetVariable",
						"dependsOn": [],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "lowerBound",
							"value": 1
						}
					},
					{
						"name": "Set higherbound",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "Set lowerBound",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "higherBound",
							"value": 500
						}
					},
					{
						"name": "Set round",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "Set higherbound",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "round",
							"value": 18
						}
					},
					{
						"name": "Execute Compare Premium",
						"type": "ExecutePipeline",
						"dependsOn": [
							{
								"activity": "ForEach1",
								"dependencyConditions": [
									"Completed"
								]
							}
						],
						"policy": {
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "pl_compare_premium",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					},
					{
						"name": "Execute Premium Report",
						"type": "ExecutePipeline",
						"dependsOn": [
							{
								"activity": "Execute Compare Premium",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "pl_premium_report",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"variables": {
					"higherBound": {
						"type": "Integer"
					},
					"round": {
						"type": "Integer"
					},
					"lowerBound": {
						"type": "Integer"
					}
				},
				"folder": {
					"name": "utility/rating"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/pipelines/pl_compare_premium')]",
				"[concat(variables('factoryId'), '/pipelines/pl_premium_report')]",
				"[concat(variables('factoryId'), '/pipelines/pl_quote_premium')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_source_agencyproducer')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Agency Data Flow",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "Agency MaxId Lookup",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_source_agency",
								"type": "DataFlowReference",
								"parameters": {
									"DF_max_id": {
										"value": "@activity('Agency MaxId Lookup').output.firstRow.maxId",
										"type": "Expression"
									}
								},
								"datasetParameters": {
									"agencySource": {},
									"agencySourceLookup": {},
									"agencyStaging": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "Agency MaxId Lookup",
						"type": "Lookup",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "SqlServerSource",
								"sqlReaderQuery": "SELECT isnull(MAX(AGENCY_ID), 0) as maxId\nFROM dbo.POL_AGENCY",
								"queryTimeout": "02:00:00",
								"partitionOption": "None"
							},
							"dataset": {
								"referenceName": "ds_source_stage_agency",
								"type": "DatasetReference",
								"parameters": {}
							}
						}
					},
					{
						"name": "Agency MaxId Lookup1",
						"type": "Lookup",
						"dependsOn": [
							{
								"activity": "Agency Data Flow",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "SqlServerSource",
								"sqlReaderQuery": "SELECT isnull(MAX(AGENCY_ID), 0) as maxId\nFROM dbo.POL_AGENCY",
								"queryTimeout": "02:00:00",
								"partitionOption": "None"
							},
							"dataset": {
								"referenceName": "ds_source_stage_agency",
								"type": "DatasetReference",
								"parameters": {}
							}
						}
					},
					{
						"name": "Producer Data Flow",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "Agency MaxId Lookup1",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_source_producer",
								"type": "DataFlowReference",
								"parameters": {
									"DF_max_id": {
										"value": "@activity('Agency MaxId Lookup1').output.firstRow.maxId",
										"type": "Expression"
									}
								},
								"datasetParameters": {
									"producerSource": {},
									"agencyStagingLookup": {},
									"agencyStaging": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "Source Data Movement/ecm/pipeline_reference"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_source_agency')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_agency')]",
				"[concat(variables('factoryId'), '/dataflows/df_source_producer')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_source_bpa_cov_mapping')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "df_coverage_BPA_mapping",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_stage_ecm_bpa_cov_mapping",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"ecmCovMapping": {},
									"ecmBpaCovMapping": {}
								}
							},
							"staging": {},
							"integrationRuntime": {
								"referenceName": "integrationRuntime2-selfhosted",
								"type": "IntegrationRuntimeReference"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "Source Data Movement/ecm/pipeline_reference"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_stage_ecm_bpa_cov_mapping')]",
				"[concat(variables('factoryId'), '/integrationRuntimes/integrationRuntime2-selfhosted')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_source_coverage_coverageext')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Coverage Data Flow",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_source_coverage",
								"type": "DataFlowReference",
								"parameters": {
									"policyPrefix": {
										"value": "'@{pipeline().globalParameters.policyPrefix}'",
										"type": "Expression"
									},
									"policies": {
										"value": "@pipeline().globalParameters.policies",
										"type": "Expression"
									}
								},
								"datasetParameters": {
									"policyCoverageSource": {},
									"policyStaging": {},
									"coverageCodeStaging": {},
									"coverageStagingLookup": {},
									"coverageStagingMaxId": {},
									"coverageStaging": {},
									"maxIdCache": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "Coverage Ext Data Flow",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "Coverage Data Flow",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_source_coverageExt",
								"type": "DataFlowReference",
								"parameters": {
									"policyPrefix": {
										"value": "'@{pipeline().globalParameters.policyPrefix}'",
										"type": "Expression"
									},
									"policies": {
										"value": "@pipeline().globalParameters.policies",
										"type": "Expression"
									}
								},
								"datasetParameters": {
									"coverageStaging": {},
									"policyStaging": {},
									"policySource": {},
									"coverageExtStaging": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "Source Data Movement/ecm/pipelien_txn"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_source_coverage')]",
				"[concat(variables('factoryId'), '/dataflows/df_source_coverageExt')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_source_coveragecode')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Coverage Code Data flow",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_source_coverageCode",
								"type": "DataFlowReference",
								"parameters": {
									"policyPrefix": {
										"value": "'@{pipeline().globalParameters.policyPrefix}'",
										"type": "Expression"
									}
								},
								"datasetParameters": {
									"policyCoverageSource": {},
									"pkey": {},
									"coverageCodeStaging": {},
									"ssCoverCodPkeyCache": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "Source Data Movement/ecm/pipeline_reference"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_source_coverageCode')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_source_genaddress')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Gen Address MaxId Lookup",
						"type": "Lookup",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "SqlServerSource",
								"sqlReaderQuery": "SELECT isnull(MAX(GEN_ADDRESS_UNIQ_ID), 0) as maxId\nFROM dbo.GEN_ADDRESS",
								"queryTimeout": "02:00:00",
								"partitionOption": "None"
							},
							"dataset": {
								"referenceName": "ds_source_stage_genAddress",
								"type": "DatasetReference",
								"parameters": {}
							}
						}
					},
					{
						"name": "Gen Address MaxId Lookup1",
						"type": "Lookup",
						"dependsOn": [
							{
								"activity": "Location Address Data flow",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "SqlServerSource",
								"sqlReaderQuery": "SELECT isnull(MAX(GEN_ADDRESS_UNIQ_ID), 0) as maxId\nFROM dbo.GEN_ADDRESS",
								"queryTimeout": "02:00:00",
								"partitionOption": "None"
							},
							"dataset": {
								"referenceName": "ds_source_stage_genAddress",
								"type": "DatasetReference",
								"parameters": {}
							}
						}
					},
					{
						"name": "Location Address Data flow",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "Gen Address MaxId Lookup",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_source_locationgenaddress",
								"type": "DataFlowReference",
								"parameters": {
									"DF_max_id": {
										"value": "@activity('Gen Address MaxId Lookup').output.firstRow.maxId",
										"type": "Expression"
									},
									"policyPrefix": {
										"value": "'@{pipeline().globalParameters.policyPrefix}'",
										"type": "Expression"
									}
								},
								"datasetParameters": {
									"locationAddressSource": {},
									"genAddressStagingLookup": {},
									"genAddressStaging": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "Insured Address Data flow",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "Gen Address MaxId Lookup1",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_source_insuredgenaddress",
								"type": "DataFlowReference",
								"parameters": {
									"DF_max_id": {
										"value": "@activity('Gen Address MaxId Lookup1').output.firstRow.maxId",
										"type": "Expression"
									},
									"policyPrefix": {
										"value": "'@{pipeline().globalParameters.policyPrefix}'",
										"type": "Expression"
									}
								},
								"datasetParameters": {
									"insuredAddressSource": {},
									"genAddressStagingLookup": {},
									"genAddressStaging": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "Source Data Movement/ecm/pipeline_reference"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_genAddress')]",
				"[concat(variables('factoryId'), '/dataflows/df_source_locationgenaddress')]",
				"[concat(variables('factoryId'), '/dataflows/df_source_insuredgenaddress')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_source_limitDedType')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Data flow1",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_source_POL__LIMIT_DED_OPT_TYPE",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"source1": {},
									"sink1": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "Source Data Movement/ecm/pipeline_reference"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_source_POL__LIMIT_DED_OPT_TYPE')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_source_lobcompany')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Lob Company Data Flow",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "lob max id Lookup",
								"dependencyConditions": [
									"Succeeded"
								]
							},
							{
								"activity": "company max id Lookup",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_source_lobcompany",
								"type": "DataFlowReference",
								"parameters": {
									"DF_batch": {
										"value": "@variables('BatchId')",
										"type": "Expression"
									},
									"DF_lob_max_id": {
										"value": "@activity('lob max id Lookup').output.firstRow.maxId",
										"type": "Expression"
									},
									"DF_company_max_id": {
										"value": "@activity('company max id Lookup').output.firstRow.maxId",
										"type": "Expression"
									}
								},
								"datasetParameters": {
									"companySource": {},
									"lobSource": {},
									"compnayStatgingLookup": {},
									"lobStagingLookup": {},
									"companyStaging": {},
									"lobStaging": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "lob max id Lookup",
						"type": "Lookup",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "SqlServerSource",
								"sqlReaderQuery": "SELECT isnull(MAX(LOB_ID), 0) as maxId\nFROM dbo.POL_LOB",
								"queryTimeout": "02:00:00",
								"partitionOption": "None"
							},
							"dataset": {
								"referenceName": "ds_source_stage_lob",
								"type": "DatasetReference",
								"parameters": {}
							}
						}
					},
					{
						"name": "company max id Lookup",
						"type": "Lookup",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "SqlServerSource",
								"sqlReaderQuery": "SELECT isnull(MAX(COMPANY_ID), 0) as maxId\nFROM dbo.CO_COMPANY",
								"queryTimeout": "02:00:00",
								"partitionOption": "None"
							},
							"dataset": {
								"referenceName": "ds_source_stage_company",
								"type": "DatasetReference",
								"parameters": {}
							}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"variables": {
					"BatchId": {
						"type": "Integer",
						"defaultValue": 1
					}
				},
				"folder": {
					"name": "Source Data Movement/ecm/pipeline_reference"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_source_lobcompany')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_lob')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_company')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_source_loc_risk_bridge')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "df_risk_location_bridge",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_source_location_risk_bridege",
								"type": "DataFlowReference",
								"parameters": {
									"policies": {
										"value": "@pipeline().globalParameters.policies",
										"type": "Expression"
									},
									"policyPrefix": {
										"value": "'@{pipeline().globalParameters.policyPrefix}'",
										"type": "Expression"
									}
								},
								"datasetParameters": {
									"location": {},
									"policy": {},
									"risk": {},
									"sink1": {},
									"sink2": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "Source Data Movement/ecm/pipelien_txn"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_source_location_risk_bridege')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_source_location')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Location Address to Location Data flow",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_source_locationAddressToLocation",
								"type": "DataFlowReference",
								"parameters": {
									"policyPrefix": {
										"value": "'@{pipeline().globalParameters.policyPrefix}'",
										"type": "Expression"
									},
									"policies": {
										"value": "@pipeline().globalParameters.policies",
										"type": "Expression"
									}
								},
								"datasetParameters": {
									"locationAddressSource": {},
									"policyStaging": {},
									"genAddressStaging": {},
									"locationStagingMaxId": {},
									"locationStaging": {},
									"maxIdCache": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "Insured Address to Insured Location Data flow",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "Location Address to Location Data flow",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_source_insuredAddressToLocation",
								"type": "DataFlowReference",
								"parameters": {
									"policyPrefix": {
										"value": "'@{pipeline().globalParameters.policyPrefix}'",
										"type": "Expression"
									},
									"policies": {
										"value": "@pipeline().globalParameters.policies",
										"type": "Expression"
									}
								},
								"datasetParameters": {
									"insuredAddressSource": {},
									"policyStaging": {},
									"genAddressStaging": {},
									"insuredLocationStagingMaxId": {},
									"insuredLocationStaging": {},
									"maxIdCache": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "Source Data Movement/ecm/pipelien_txn"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_source_locationAddressToLocation')]",
				"[concat(variables('factoryId'), '/dataflows/df_source_insuredAddressToLocation')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_source_lookupType')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "lookupType",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_source_emp_lookupType",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"empRiskTypeCodes": {},
									"lookupTypeSource": {},
									"LookUpTypeSink": {},
									"lookupTypeCache": {}
								}
							},
							"staging": {},
							"integrationRuntime": {
								"referenceName": "integrationRuntime2-selfhosted",
								"type": "IntegrationRuntimeReference"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "lookupDetails",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "lookupType",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_source_emp_lookupTypeDetails",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"empRiskTypeCodes": {},
									"lookupTypeSource": {},
									"lookupType": {},
									"LookUpDetailsSink": {},
									"lookupTypeCache": {}
								}
							},
							"staging": {},
							"integrationRuntime": {
								"referenceName": "integrationRuntime2-selfhosted",
								"type": "IntegrationRuntimeReference"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "Source Data Movement/ecm/pipeline_reference"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_source_emp_lookupType')]",
				"[concat(variables('factoryId'), '/integrationRuntimes/integrationRuntime2-selfhosted')]",
				"[concat(variables('factoryId'), '/dataflows/df_source_emp_lookupTypeDetails')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_source_lookupTypeAndDetails')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "lookupType",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_source_emp_lookupType",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"empRiskTypeCodes": {},
									"lookupTypeSource": {},
									"LookUpTypeSink": {},
									"lookupTypeCache": {}
								}
							},
							"staging": {},
							"integrationRuntime": {
								"referenceName": "integrationRuntime2-selfhosted",
								"type": "IntegrationRuntimeReference"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "lookupDetails",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "lookupType",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_source_emp_lookupTypeDetails",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"empRiskTypeCodes": {},
									"lookupTypeSource": {},
									"lookupType": {},
									"LookUpDetailsSink": {},
									"lookupTypeCache": {}
								}
							},
							"staging": {},
							"integrationRuntime": {
								"referenceName": "integrationRuntime2-selfhosted",
								"type": "IntegrationRuntimeReference"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "Source Data Movement/ecm/pipeline_reference"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_source_emp_lookupType')]",
				"[concat(variables('factoryId'), '/integrationRuntimes/integrationRuntime2-selfhosted')]",
				"[concat(variables('factoryId'), '/dataflows/df_source_emp_lookupTypeDetails')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_source_party')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Party Data flow",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "Party MaxId Lookup",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_source_party",
								"type": "DataFlowReference",
								"parameters": {
									"DF_batch": {
										"value": "@variables('BatchId')",
										"type": "Expression"
									},
									"DF_max_id": {
										"value": "@activity('Party MaxId Lookup').output.firstRow.maxId",
										"type": "Expression"
									}
								},
								"datasetParameters": {
									"partySource": {},
									"partyStagingLookup": {},
									"partyStaging": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "Party MaxId Lookup",
						"type": "Lookup",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "SqlServerSource",
								"sqlReaderQuery": "SELECT isnull(MAX(PARTY_ID), 0) as maxId\nFROM dbo.POL_PARTY",
								"queryTimeout": "02:00:00",
								"partitionOption": "None"
							},
							"dataset": {
								"referenceName": "ds_source_stage_party",
								"type": "DatasetReference",
								"parameters": {}
							},
							"firstRowOnly": true
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"variables": {
					"BatchId": {
						"type": "Integer",
						"defaultValue": 1
					}
				},
				"folder": {
					"name": "Source Data Movement/ecm/pipeline_reference"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_source_party')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_party')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_source_polRiskAndDetails')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Switch1",
						"type": "Switch",
						"dependsOn": [],
						"userProperties": [],
						"typeProperties": {
							"on": {
								"value": "@pipeline().globalParameters.policyPrefix",
								"type": "Expression"
							},
							"cases": [
								{
									"value": "EMP",
									"activities": [
										{
											"name": "empRisk",
											"type": "ExecuteDataFlow",
											"dependsOn": [],
											"policy": {
												"timeout": "0.12:00:00",
												"retry": 0,
												"retryIntervalInSeconds": 30,
												"secureOutput": false,
												"secureInput": false
											},
											"userProperties": [],
											"typeProperties": {
												"dataflow": {
													"referenceName": "df_source_policy_risk_emp",
													"type": "DataFlowReference",
													"parameters": {
														"policyPrefix": {
															"value": "'@{pipeline().globalParameters.policyPrefix}'",
															"type": "Expression"
														},
														"policies": {
															"value": "@pipeline().globalParameters.policies",
															"type": "Expression"
														}
													},
													"datasetParameters": {
														"PropertyUnits": {},
														"stgPolicy": {},
														"riskStaging": {},
														"PolRisk": {},
														"maxId": {}
													}
												},
												"staging": {},
												"compute": {
													"coreCount": 8,
													"computeType": "General"
												},
												"traceLevel": "Fine"
											}
										},
										{
											"name": "empRiskDetails",
											"type": "ExecuteDataFlow",
											"dependsOn": [
												{
													"activity": "empRisk",
													"dependencyConditions": [
														"Succeeded"
													]
												}
											],
											"policy": {
												"timeout": "0.12:00:00",
												"retry": 0,
												"retryIntervalInSeconds": 30,
												"secureOutput": false,
												"secureInput": false
											},
											"userProperties": [],
											"typeProperties": {
												"dataflow": {
													"referenceName": "df_source_empInsObj",
													"type": "DataFlowReference",
													"parameters": {
														"policyPrefix": {
															"value": "'@{pipeline().globalParameters.policyPrefix}'",
															"type": "Expression"
														},
														"policies": {
															"value": "@pipeline().globalParameters.policies",
															"type": "Expression"
														}
													},
													"datasetParameters": {
														"StagingPolicyRisk": {},
														"StagingPolicy": {},
														"EcmPropertyUnits": {},
														"ecmWithLimits": {},
														"sourceRefLookUp": {},
														"StagingPolicyRiskTypeBreed": {},
														"StagingPolicyRiskTypeName": {},
														"StagingPolicyRiskTypeSex": {},
														"StagingPolicyRiskTypePurchaseDate": {},
														"StagingPolicyRiskTypeMortality": {},
														"StagingPolicyRiskTypeUse": {},
														"StagingPolicyRiskTypePrice": {},
														"StagingPolicyRiskTypeYearBorn": {},
														"StagingPolicyRiskTypeRequestedLimit": {},
														"StagingPolicyRiskTypeAge": {}
													}
												},
												"staging": {},
												"compute": {
													"coreCount": 8,
													"computeType": "General"
												},
												"traceLevel": "Fine"
											}
										}
									]
								},
								{
									"value": "CFA",
									"activities": [
										{
											"name": "cfaRisk",
											"type": "ExecuteDataFlow",
											"dependsOn": [],
											"policy": {
												"timeout": "0.12:00:00",
												"retry": 0,
												"retryIntervalInSeconds": 30,
												"secureOutput": false,
												"secureInput": false
											},
											"userProperties": [],
											"typeProperties": {
												"dataflow": {
													"referenceName": "df_source_policy_risk_cfa",
													"type": "DataFlowReference",
													"parameters": {
														"policyPrefix": {
															"value": "'@{pipeline().globalParameters.policyPrefix}'",
															"type": "Expression"
														},
														"policies": {
															"value": "@pipeline().globalParameters.policies",
															"type": "Expression"
														}
													},
													"datasetParameters": {
														"autoUnitSource": {},
														"stgPolicy": {},
														"riskStaging": {},
														"PolRisk": {},
														"maxId": {}
													}
												},
												"staging": {},
												"compute": {
													"coreCount": 8,
													"computeType": "General"
												},
												"traceLevel": "Fine"
											}
										},
										{
											"name": "cfaRiskDetails",
											"type": "ExecuteDataFlow",
											"dependsOn": [
												{
													"activity": "cfaRisk",
													"dependencyConditions": [
														"Succeeded"
													]
												}
											],
											"policy": {
												"timeout": "0.12:00:00",
												"retry": 0,
												"retryIntervalInSeconds": 30,
												"secureOutput": false,
												"secureInput": false
											},
											"userProperties": [],
											"typeProperties": {
												"dataflow": {
													"referenceName": "df_source_cfaInsObj",
													"type": "DataFlowReference",
													"parameters": {
														"policyPrefix": {
															"value": "'@{pipeline().globalParameters.policyPrefix}'",
															"type": "Expression"
														},
														"policies": {
															"value": "@pipeline().globalParameters.policies",
															"type": "Expression"
														}
													},
													"datasetParameters": {
														"StagingPolicyRisk": {},
														"StagingPolicy": {},
														"autoUnitsSource": {},
														"locationAddressSource": {},
														"StagingPolicyRiskTypeBreed": {},
														"StagingPolicyRiskTypeName": {},
														"StagingPolicyRiskTypeSex": {},
														"StagingPolicyRiskTypePurchaseDate": {},
														"StagingPolicyRiskTypeMortality": {},
														"StagingPolicyRiskTypeUse": {},
														"StagingPolicyRiskTypePrice": {},
														"StagingPolicyRiskTypeRequestedLimit": {},
														"StagingPolicyRiskTypeAge": {},
														"StagingPolicyRiskTypeVehicleOwned": {},
														"StagingPolicyRiskTypeRadiusClass": {},
														"StagingPolicyRiskTypePrimaryClass": {},
														"StagingPolicyRiskTypeSecondaryClass": {},
														"sink3": {},
														"sink4": {},
														"sink5": {},
														"sink6": {},
														"StagingPolicyRiskTypeFleet": {},
														"sink7": {},
														"sink8": {},
														"sink9": {},
														"sink10": {},
														"sink11": {},
														"sink13": {},
														"sink14": {},
														"sink15": {}
													}
												},
												"staging": {},
												"compute": {
													"coreCount": 8,
													"computeType": "General"
												},
												"traceLevel": "Fine"
											}
										}
									]
								}
							]
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"productCode": {
						"type": "string",
						"defaultValue": "\"emp\""
					}
				},
				"folder": {
					"name": "Source Data Movement/ecm/pipelien_txn"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_source_policy_risk_emp')]",
				"[concat(variables('factoryId'), '/dataflows/df_source_empInsObj')]",
				"[concat(variables('factoryId'), '/dataflows/df_source_policy_risk_cfa')]",
				"[concat(variables('factoryId'), '/dataflows/df_source_cfaInsObj')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_source_polSection')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "polSectionDf",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_source_policy_section",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"source1": {},
									"source2": {},
									"lobStg": {},
									"subLobStg": {},
									"sink1": {},
									"sink2": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "Source Data Movement/ecm/pipelien_txn"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_source_policy_section')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_source_policy')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "ecmToSrcStgPolicy",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_source_policy",
								"type": "DataFlowReference",
								"parameters": {
									"policyPrefix": {
										"value": "'@{pipeline().globalParameters.policyPrefix}'",
										"type": "Expression"
									},
									"policies": {
										"value": "@pipeline().globalParameters.policies",
										"type": "Expression"
									}
								},
								"datasetParameters": {
									"ecmPolicyCoverage": {},
									"polAgencyStg": {},
									"producerStg": {},
									"stateCode": {},
									"stgPolicyNextPkey": {},
									"stgPolicy": {},
									"stateCodeSink": {},
									"policyPkeyCache": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "Source Data Movement/ecm/pipelien_txn"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_source_policy')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_source_policy_master')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "polPolicy",
						"type": "ExecutePipeline",
						"dependsOn": [],
						"policy": {
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "pl_source_policy",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					},
					{
						"name": "insurableObjPipeline",
						"type": "ExecutePipeline",
						"dependsOn": [
							{
								"activity": "Policy PartyRole",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "pl_source_polRiskAndDetails",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					},
					{
						"name": "locationpipeline",
						"type": "ExecutePipeline",
						"dependsOn": [
							{
								"activity": "insurableObjPipeline",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "pl_source_location",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					},
					{
						"name": "coveragePipeline",
						"type": "ExecutePipeline",
						"dependsOn": [
							{
								"activity": "locationpipeline",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "pl_source_coverage_coverageext",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					},
					{
						"name": "riskBridge",
						"type": "ExecutePipeline",
						"dependsOn": [
							{
								"activity": "coveragePipeline",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "pl_source_loc_risk_bridge",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					},
					{
						"name": "txn premiums",
						"type": "ExecutePipeline",
						"dependsOn": [
							{
								"activity": "riskBridge",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "pl_source_policy_txn",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					},
					{
						"name": "Policy PartyRole",
						"type": "ExecutePipeline",
						"dependsOn": [
							{
								"activity": "polPolicy",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "pl_source_policy_partyrole_bridge",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					},
					{
						"name": "tx and limits",
						"type": "ExecutePipeline",
						"dependsOn": [
							{
								"activity": "txn premiums",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "pl_source_tx_limits",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "Source Data Movement/ecm/pipleline_master"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/pipelines/pl_source_policy')]",
				"[concat(variables('factoryId'), '/pipelines/pl_source_polRiskAndDetails')]",
				"[concat(variables('factoryId'), '/pipelines/pl_source_location')]",
				"[concat(variables('factoryId'), '/pipelines/pl_source_coverage_coverageext')]",
				"[concat(variables('factoryId'), '/pipelines/pl_source_loc_risk_bridge')]",
				"[concat(variables('factoryId'), '/pipelines/pl_source_policy_txn')]",
				"[concat(variables('factoryId'), '/pipelines/pl_source_policy_partyrole_bridge')]",
				"[concat(variables('factoryId'), '/pipelines/pl_source_tx_limits')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_source_policy_partyrole_bridge')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Policy Party Role Data flow",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_source_policy_partyrole_bridge",
								"type": "DataFlowReference",
								"parameters": {
									"policies": {
										"value": "@pipeline().globalParameters.policies",
										"type": "Expression"
									},
									"policyPrefix": {
										"value": "'@{pipeline().globalParameters.policyPrefix}'",
										"type": "Expression"
									}
								},
								"datasetParameters": {
									"EcmParty": {},
									"StagingParty": {},
									"StagingPolicy": {},
									"StagingPartyRole": {},
									"bridgeMaxId": {},
									"StagingPolicyPartyRoleBridge": {},
									"maxIdCache": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "Source Data Movement/ecm/pipelien_txn"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_source_policy_partyrole_bridge')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_source_policy_premium')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "polTxnPremium",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_source_policy_premium",
								"type": "DataFlowReference",
								"parameters": {
									"policyPrefix": {
										"value": "'@{pipeline().globalParameters.policyPrefix}'",
										"type": "Expression"
									},
									"policies": {
										"value": "@pipeline().globalParameters.policies",
										"type": "Expression"
									}
								},
								"datasetParameters": {
									"StagingPolTxn": {},
									"FactCoveragePremium": {},
									"StagingPolicy": {},
									"source1": {},
									"sink1": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "Source Data Movement/ecm/pipelien_txn"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_source_policy_premium')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_source_policy_txn')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "pol_txn",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_source_policy_txn",
								"type": "DataFlowReference",
								"parameters": {
									"policyPrefix": {
										"value": "'@{pipeline().globalParameters.policyPrefix}'",
										"type": "Expression"
									},
									"policies": {
										"value": "@pipeline().globalParameters.policies",
										"type": "Expression"
									}
								},
								"datasetParameters": {
									"coverages": {},
									"polPolicy": {},
									"txnStagingMaxId": {},
									"polTxn": {},
									"maxIdCache": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "pol_txn_bridge",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "pol_txn",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_source_policy_tx_bridge",
								"type": "DataFlowReference",
								"parameters": {
									"policyPrefix": {
										"value": "'@{pipeline().globalParameters.policyPrefix}'",
										"type": "Expression"
									},
									"policies": {
										"value": "@pipeline().globalParameters.policies",
										"type": "Expression"
									}
								},
								"datasetParameters": {
									"polTxnStg": {},
									"coverageStg": {},
									"source1": {},
									"polSection": {},
									"txnBridgeStagingMaxId": {},
									"stagingPolicy": {},
									"sink1": {},
									"maxIdCache": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "pol_premium",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "pol_txn_bridge",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_source_policy_premium",
								"type": "DataFlowReference",
								"parameters": {
									"policyPrefix": {
										"value": "'@{pipeline().globalParameters.policyPrefix}'",
										"type": "Expression"
									},
									"policies": {
										"value": "@pipeline().globalParameters.policies",
										"type": "Expression"
									}
								},
								"datasetParameters": {
									"StagingPolTxn": {},
									"FactCoveragePremium": {},
									"StagingPolicy": {},
									"source1": {},
									"sink1": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "Source Data Movement/ecm/pipelien_txn"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_source_policy_txn')]",
				"[concat(variables('factoryId'), '/dataflows/df_source_policy_tx_bridge')]",
				"[concat(variables('factoryId'), '/dataflows/df_source_policy_premium')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_source_reference_master')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Execute Lob Company Data Pipeline",
						"type": "ExecutePipeline",
						"dependsOn": [],
						"policy": {
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "pl_source_lobcompany",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					},
					{
						"name": "Execute Gen Address Data Pipeline",
						"type": "ExecutePipeline",
						"dependsOn": [
							{
								"activity": "Execute Agency and Producer Data Pipeline",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "pl_source_genaddress",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					},
					{
						"name": "Execute Party Data Pipeline",
						"type": "ExecutePipeline",
						"dependsOn": [
							{
								"activity": "Execute Lob Company Data Pipeline",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "pl_source_party",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					},
					{
						"name": "Execute Agency and Producer Data Pipeline",
						"type": "ExecutePipeline",
						"dependsOn": [
							{
								"activity": "Execute Party Data Pipeline",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "pl_source_agencyproducer",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					},
					{
						"name": "Execute Coverage Code Data Pipeline",
						"type": "ExecutePipeline",
						"dependsOn": [
							{
								"activity": "Execute Gen Address Data Pipeline",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "pl_source_coveragecode",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					},
					{
						"name": "Execute Limit Ded type Data Pipeline",
						"type": "ExecutePipeline",
						"dependsOn": [
							{
								"activity": "Execute Coverage Code Data Pipeline",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "pl_source_limitDedType",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "Source Data Movement/ecm/pipleline_master"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/pipelines/pl_source_lobcompany')]",
				"[concat(variables('factoryId'), '/pipelines/pl_source_genaddress')]",
				"[concat(variables('factoryId'), '/pipelines/pl_source_party')]",
				"[concat(variables('factoryId'), '/pipelines/pl_source_agencyproducer')]",
				"[concat(variables('factoryId'), '/pipelines/pl_source_coveragecode')]",
				"[concat(variables('factoryId'), '/pipelines/pl_source_limitDedType')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_source_stage_remove_txn')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Remove policy data from source stage",
						"type": "SqlServerStoredProcedure",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"storedProcedureName": "[[dbo].[removeData]"
						},
						"linkedServiceName": {
							"referenceName": "sourceStageDB",
							"type": "LinkedServiceReference"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "utility/cleanup"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/sourceStageDB')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_source_sublob')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Data flow1",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "sub_lob_df",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"source1": {},
									"source2": {},
									"sink1": {},
									"sink2": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "Source Data Movement/ecm/pipeline_reference"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/sub_lob_df')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_source_target_policy_master')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Execute Source Policy Master Pipeline",
						"type": "ExecutePipeline",
						"dependsOn": [],
						"policy": {
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "pl_source_policy_master",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					},
					{
						"name": "Execute Stage Policy Master Pipeline",
						"type": "ExecutePipeline",
						"dependsOn": [
							{
								"activity": "Execute Source Policy Master Pipeline",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "pl_stage_policy_master",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					},
					{
						"name": "Execute Target Master Pipeline",
						"type": "ExecutePipeline",
						"dependsOn": [
							{
								"activity": "Execute Stage Policy Master Pipeline",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "pl_api_policy",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "Soure to Target"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/pipelines/pl_source_policy_master')]",
				"[concat(variables('factoryId'), '/pipelines/pl_stage_policy_master')]",
				"[concat(variables('factoryId'), '/pipelines/pl_api_policy')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_source_tx_limits')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "limit2",
						"type": "ExecuteDataFlow",
						"state": "Inactive",
						"onInactiveMarkAs": "Succeeded",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_source_POL_TX_LIMIT2",
								"type": "DataFlowReference",
								"parameters": {
									"policyPrefix": {
										"value": "'@{pipeline().globalParameters.policyPrefix}'",
										"type": "Expression"
									}
								},
								"datasetParameters": {
									"StagingTxnBridge": {},
									"stgPolTxn": {},
									"fcp": {},
									"polPolicy": {},
									"risklocationBridge": {},
									"PolTxLimitDedOptLimit2": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "limit1",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "limit2",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_source_POL_TX_LIMIT1",
								"type": "DataFlowReference",
								"parameters": {
									"policyPrefix": {
										"value": "'@{pipeline().globalParameters.policyPrefix}'",
										"type": "Expression"
									},
									"policies": {
										"value": "@pipeline().globalParameters.policies",
										"type": "Expression"
									}
								},
								"datasetParameters": {
									"StagingTxnBridge": {},
									"stgPolTxn": {},
									"fcp": {},
									"polPolicy": {},
									"source1": {},
									"PolTxLimitDedOptLimit2": {},
									"limitKeyCache": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "POL_TX_Deductible_DF",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "limit1",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_source_POL_TX_Deductible",
								"type": "DataFlowReference",
								"parameters": {
									"policyPrefix": {
										"value": "'@{pipeline().globalParameters.policyPrefix}'",
										"type": "Expression"
									},
									"policies": {
										"value": "@pipeline().globalParameters.policies",
										"type": "Expression"
									}
								},
								"datasetParameters": {
									"StagingTxnBridge": {},
									"stgPolTxn": {},
									"fcp": {},
									"polPolicy": {},
									"PolTxnLimitDedMaxId": {},
									"PolTxLimitDedOptLimit2": {},
									"polTxnLDCache": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "Source Data Movement/ecm/pipelien_txn"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_source_POL_TX_LIMIT2')]",
				"[concat(variables('factoryId'), '/dataflows/df_source_POL_TX_LIMIT1')]",
				"[concat(variables('factoryId'), '/dataflows/df_source_POL_TX_Deductible')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_stage_address')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Address Data flow",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_stage_address",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"addressStaging": {},
									"addressTarget": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "Staging Data Movement"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_stage_address')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_stage_agency')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Target Agency Data Flow",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_stage_agency",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"agencyStaging": {},
									"policyPartyRoleBridge": {},
									"agencyTargetLookup": {},
									"agencyTarget": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "Staging Data Movement"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_stage_agency')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_stage_cov_ded_limit')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "targetCoverages",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "Set locationCode",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_stage_riskLevel_coverages",
								"type": "DataFlowReference",
								"parameters": {
									"isLimitUpdateOnly": "false()",
									"policyPrefix": {
										"value": "'@{pipeline().globalParameters.policyPrefix}'",
										"type": "Expression"
									},
									"locationState": {
										"value": "'@{variables('locationState')}'",
										"type": "Expression"
									}
								},
								"datasetParameters": {
									"ssCoverages": {},
									"ssCoverageExt": {},
									"sslocation": {},
									"ecmBpaCovMap": {},
									"targetPolicy": {},
									"stgPolicy": {},
									"osStageCoverage": {},
									"covCache": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "addLimitToCoverages",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "targetdeductible",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_addLimit_to_risk_level_coverage",
								"type": "DataFlowReference",
								"parameters": {
									"policyPrefix": {
										"value": "'@{pipeline().globalParameters.policyPrefix}'",
										"type": "Expression"
									}
								},
								"datasetParameters": {
									"targetCoverage": {},
									"osTargeLimit": {},
									"osTargetDeductible": {},
									"sink1": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "limitRiskLevel",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "Set variable1",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_stage_covLimit_risk_level_cov",
								"type": "DataFlowReference",
								"parameters": {
									"policyPrefix": {
										"value": "'@{pipeline().globalParameters.policyPrefix}'",
										"type": "Expression"
									},
									"locationCode": {
										"value": "'@{variables('locationCode')}'",
										"type": "Expression"
									}
								},
								"datasetParameters": {
									"source1": {},
									"osStagingCoverageExt": {},
									"srcBpaCovMap": {},
									"BPAlimitRef": {},
									"source2": {},
									"TargetlimitSink": {},
									"sink2": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "targetdeductible",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "limitPolicyLevel",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_stage_Deductible",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"stageDeductible": {},
									"source1": {},
									"source2": {},
									"TargetdeductSink": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "onlyPolicyLevelCoverages",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "targetCoverages",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_stage_policyLevel_coverages",
								"type": "DataFlowReference",
								"parameters": {
									"isLimitUpdateOnlyForPolicy": "false()",
									"policyPrefix": {
										"value": "'@{pipeline().globalParameters.policyPrefix}'",
										"type": "Expression"
									},
									"locationState": {
										"value": "'@{variables('locationState')}'",
										"type": "Expression"
									}
								},
								"datasetParameters": {
									"ssCoverages": {},
									"ssCoverageExt": {},
									"ecmBpaCovMap": {},
									"targetPolicy": {},
									"srcStgPolicy": {},
									"osStageCoverage": {},
									"sink2": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "limitsToPolicyLevelCoverages",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "addLimitToCoverages",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_addLimit_to_policy_level_coverage",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"targetCoverage": {},
									"osTargeLimit": {},
									"sink1": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "limitPolicyLevel",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "limitRiskLevel",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_stage_covLimit_policy_level",
								"type": "DataFlowReference",
								"parameters": {
									"policyPrefix": {
										"value": "'@{pipeline().globalParameters.policyPrefix}'",
										"type": "Expression"
									},
									"locationCode": "'MT'"
								},
								"datasetParameters": {
									"source1": {},
									"osStagingCoverageExt": {},
									"srcBpaCovMap": {},
									"BPAlimitRef": {},
									"source2": {},
									"TargetlimitSink": {},
									"sink2": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "updateDeductibleToRiskLevelCoverages",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "limitsToPolicyLevelCoverages",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_addDeductible_to_risk_level_coverage",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"targetCoverage": {},
									"osTargetDeductible": {},
									"sink1": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "updateDeductibleToPolicyCoverages",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "updateDeductibleToRiskLevelCoverages",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_addDeductible_to_policy_level_coverage",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"targetCoverage": {},
									"osDeductibleLimit": {},
									"sink1": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "locaitonState",
						"type": "SetVariable",
						"dependsOn": [],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "locationState",
							"value": "Montana"
						}
					},
					{
						"name": "Set locationCode",
						"type": "SetVariable",
						"state": "Inactive",
						"onInactiveMarkAs": "Succeeded",
						"dependsOn": [
							{
								"activity": "locaitonState",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "locationCode",
							"value": "'MT'"
						}
					},
					{
						"name": "Set variable1",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "onlyPolicyLevelCoverages",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "locationCode",
							"value": "MT"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"variables": {
					"isLimitUpdateOnly": {
						"type": "Boolean"
					},
					"limiPolicyLevelOnly": {
						"type": "Boolean"
					},
					"locationState": {
						"type": "String"
					},
					"locationCode": {
						"type": "String"
					}
				},
				"folder": {
					"name": "Staging Data Movement"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_stage_riskLevel_coverages')]",
				"[concat(variables('factoryId'), '/dataflows/df_addLimit_to_risk_level_coverage')]",
				"[concat(variables('factoryId'), '/dataflows/df_stage_covLimit_risk_level_cov')]",
				"[concat(variables('factoryId'), '/dataflows/df_stage_Deductible')]",
				"[concat(variables('factoryId'), '/dataflows/df_stage_policyLevel_coverages')]",
				"[concat(variables('factoryId'), '/dataflows/df_addLimit_to_policy_level_coverage')]",
				"[concat(variables('factoryId'), '/dataflows/df_stage_covLimit_policy_level')]",
				"[concat(variables('factoryId'), '/dataflows/df_addDeductible_to_risk_level_coverage')]",
				"[concat(variables('factoryId'), '/dataflows/df_addDeductible_to_policy_level_coverage')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_stage_final_policy')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "updatePolicyWithFinalSections",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_update_stage_policyWithSection",
								"type": "DataFlowReference",
								"parameters": {
									"policyPrefix": {
										"value": "'@{pipeline().globalParameters.policyPrefix}'",
										"type": "Expression"
									}
								},
								"datasetParameters": {
									"source1": {},
									"sink1": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "Staging Data Movement"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_update_stage_policyWithSection')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_stage_horseDetails')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Horse details lookup data",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_stage_horsedetails_lookup",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"horseBreedCodes": {},
									"stageHorseDetailsLookup": {},
									"horseSexCodes": {},
									"horseUseCodes": {},
									"horseDetailsBreedTarget": {},
									"lookupCache": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "Staging Data Movement/lookup"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_stage_horsedetails_lookup')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_stage_location')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Location Data flow",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_stage_location",
								"type": "DataFlowReference",
								"parameters": {
									"policyPrefix": {
										"value": "'@{pipeline().globalParameters.policyPrefix}'",
										"type": "Expression"
									}
								},
								"datasetParameters": {
									"locationStagingJoinStgingPolicy": {},
									"addressTarget": {},
									"stgPolicy": {},
									"locationTarget": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "Staging Data Movement"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_stage_location')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_stage_party')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Target Party Data Flow",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_stage_party",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"partyStaging": {},
									"targetPartyLookup": {},
									"policyPartyRoleJoin": {},
									"sink1": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "Staging Data Movement"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_stage_party')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_stage_party_master')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Execute Party JSON Pipeline",
						"type": "ExecutePipeline",
						"dependsOn": [],
						"policy": {
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "pl_stage_party",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					},
					{
						"name": "Execute Party API Pipeline",
						"type": "ExecutePipeline",
						"state": "Inactive",
						"onInactiveMarkAs": "Succeeded",
						"dependsOn": [
							{
								"activity": "Execute Party JSON Pipeline",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "pl_api_party",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					},
					{
						"name": "Execute Agency JSON Pipeline",
						"type": "ExecutePipeline",
						"dependsOn": [
							{
								"activity": "Execute Party JSON Pipeline",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "pl_stage_agency",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					},
					{
						"name": "Execute Party API Pipeline for Agency",
						"type": "ExecutePipeline",
						"dependsOn": [
							{
								"activity": "Execute Agency JSON Pipeline",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "pl_api_agency",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "Staging Data Movement/pipeline_master"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/pipelines/pl_stage_party')]",
				"[concat(variables('factoryId'), '/pipelines/pl_api_party')]",
				"[concat(variables('factoryId'), '/pipelines/pl_stage_agency')]",
				"[concat(variables('factoryId'), '/pipelines/pl_api_agency')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_stage_policy')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "df_target_policy",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_stage_policy",
								"type": "DataFlowReference",
								"parameters": {
									"policyPrefix": {
										"value": "'@{pipeline().globalParameters.policyPrefix}'",
										"type": "Expression"
									}
								},
								"datasetParameters": {
									"StagingPolicy": {},
									"pkey": {},
									"targetPolicyEMP": {},
									"nextPkey": {},
									"targetPolicyCFA": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "Staging Data Movement"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_stage_policy')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_stage_policySectionWithCoverages')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "target_section_with_cov",
						"type": "ExecuteDataFlow",
						"state": "Inactive",
						"onInactiveMarkAs": "Succeeded",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_stage_section",
								"type": "DataFlowReference",
								"parameters": {
									"policyPrefix": {
										"value": "'@{pipeline().globalParameters.policyPrefix}'",
										"type": "Expression"
									}
								},
								"datasetParameters": {
									"SScoverages": {},
									"EcmBPACovMap": {},
									"targetCoverage": {},
									"targetPolicy": {},
									"source2": {},
									"targetPolicyCopy": {},
									"sourceStgPolicy": {},
									"targetSection": {},
									"sink1": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "addRiskToSection",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "target_section_with_cov",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_stage_risk_Location_to_sections",
								"type": "DataFlowReference",
								"parameters": {
									"policyPrefix": {
										"value": "'@{pipeline().globalParameters.policyPrefix}'",
										"type": "Expression"
									}
								},
								"datasetParameters": {
									"targetCoverage": {},
									"stgCoverage": {},
									"srcCovergeBpaSectionMap": {},
									"riskById": {},
									"section": {},
									"targetLocation": {},
									"source1": {},
									"sectionTarget": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "addDefaultSection",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "addRiskToSection",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_addSec000",
								"type": "DataFlowReference",
								"parameters": {
									"policyPrefix": {
										"value": "'@{pipeline().globalParameters.policyPrefix}'",
										"type": "Expression"
									}
								},
								"datasetParameters": {
									"source1": {},
									"targetLocation": {},
									"targetRisk": {},
									"source2": {},
									"stgPolicy": {},
									"sec000Coverages": {},
									"osBpaCovMap": {},
									"targetSection": {},
									"sink2": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "Staging Data Movement"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_stage_section')]",
				"[concat(variables('factoryId'), '/dataflows/df_stage_risk_Location_to_sections')]",
				"[concat(variables('factoryId'), '/dataflows/df_addSec000')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_stage_policy_master')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Execute Pipeline1",
						"type": "ExecutePipeline",
						"dependsOn": [
							{
								"activity": "Execute Party related Pipeline",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "pl_stage_policy",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					},
					{
						"name": "risk",
						"type": "ExecutePipeline",
						"dependsOn": [
							{
								"activity": "Location",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "pl_stage_risk",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					},
					{
						"name": "CovDedLimit",
						"type": "ExecutePipeline",
						"dependsOn": [
							{
								"activity": "risk",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "pl_stage_cov_ded_limit",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					},
					{
						"name": "aggSections",
						"type": "ExecutePipeline",
						"dependsOn": [
							{
								"activity": "CovDedLimit",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "pl_stage_policySectionWithCoverages",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					},
					{
						"name": "aggPolicies",
						"type": "ExecutePipeline",
						"dependsOn": [
							{
								"activity": "aggSections",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "pl_stage_final_policy",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					},
					{
						"name": "Location",
						"type": "ExecutePipeline",
						"dependsOn": [
							{
								"activity": "addInsuredOnly",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "pl_stage_location",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					},
					{
						"name": "updateAgentAndClientData",
						"type": "ExecutePipeline",
						"dependsOn": [
							{
								"activity": "Execute Pipeline1",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "pl_target_updateagentparty",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					},
					{
						"name": "Execute Party related Pipeline",
						"type": "ExecutePipeline",
						"state": "Inactive",
						"onInactiveMarkAs": "Succeeded",
						"dependsOn": [],
						"policy": {
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "pl_stage_party_master",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					},
					{
						"name": "addInsuredOnly",
						"type": "ExecutePipeline",
						"dependsOn": [
							{
								"activity": "updateAgentAndClientData",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "pl_temp_clientPartToBlank",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"variables": {
					"isRiskUpdateOnly": {
						"type": "Boolean"
					},
					"isLimitUpdateOnly": {
						"type": "Boolean"
					}
				},
				"folder": {
					"name": "Staging Data Movement/pipeline_master"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/pipelines/pl_stage_policy')]",
				"[concat(variables('factoryId'), '/pipelines/pl_stage_risk')]",
				"[concat(variables('factoryId'), '/pipelines/pl_stage_cov_ded_limit')]",
				"[concat(variables('factoryId'), '/pipelines/pl_stage_policySectionWithCoverages')]",
				"[concat(variables('factoryId'), '/pipelines/pl_stage_final_policy')]",
				"[concat(variables('factoryId'), '/pipelines/pl_stage_location')]",
				"[concat(variables('factoryId'), '/pipelines/pl_target_updateagentparty')]",
				"[concat(variables('factoryId'), '/pipelines/pl_stage_party_master')]",
				"[concat(variables('factoryId'), '/pipelines/pl_temp_clientPartToBlank')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_stage_risk')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "update extended attr",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "Set variable1",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_stage_risk",
								"type": "DataFlowReference",
								"parameters": {
									"isRiskUpdateOnly": {
										"value": "@variables('isRiskUpdateOnly')",
										"type": "Expression"
									},
									"policyPrefix": {
										"value": "'@{pipeline().globalParameters.policyPrefix}'",
										"type": "Expression"
									}
								},
								"datasetParameters": {
									"ssRisk": {},
									"riskDetails": {},
									"stgPolicy": {},
									"lookUp": {},
									"lookupType": {},
									"targetPolicy": {},
									"targetRisk": {},
									"targetRiskCfa": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "Set variable1",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "Switch1",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "isRiskUpdateOnly",
							"value": true
						}
					},
					{
						"name": "risk",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_stage_risk",
								"type": "DataFlowReference",
								"parameters": {
									"isRiskUpdateOnly": "false()",
									"policyPrefix": {
										"value": "'@{pipeline().globalParameters.policyPrefix}'",
										"type": "Expression"
									}
								},
								"datasetParameters": {
									"ssRisk": {},
									"riskDetails": {},
									"stgPolicy": {},
									"lookUp": {},
									"lookupType": {},
									"targetPolicy": {},
									"targetRisk": {},
									"targetRiskCfa": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "Switch1",
						"type": "Switch",
						"dependsOn": [
							{
								"activity": "risk",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"on": {
								"value": "@pipeline().globalParameters.policyPrefix",
								"type": "Expression"
							},
							"cases": [
								{
									"value": "EMP",
									"activities": [
										{
											"name": "riskDetail_EMP",
											"type": "ExecuteDataFlow",
											"dependsOn": [],
											"policy": {
												"timeout": "0.12:00:00",
												"retry": 0,
												"retryIntervalInSeconds": 30,
												"secureOutput": false,
												"secureInput": false
											},
											"userProperties": [],
											"typeProperties": {
												"dataflow": {
													"referenceName": "df_stage_risk_details",
													"type": "DataFlowReference",
													"parameters": {},
													"datasetParameters": {
														"riskDetailsStaging": {},
														"targetRisk": {},
														"horseDetailsLookup": {},
														"sourceRefLookUp": {},
														"sourceRefLookUpType": {},
														"riskDetails": {}
													}
												},
												"staging": {},
												"compute": {
													"coreCount": 8,
													"computeType": "General"
												},
												"traceLevel": "Fine"
											}
										}
									]
								},
								{
									"value": "CFA",
									"activities": [
										{
											"name": "riskDetail_CFA",
											"type": "ExecuteDataFlow",
											"dependsOn": [],
											"policy": {
												"timeout": "0.12:00:00",
												"retry": 0,
												"retryIntervalInSeconds": 30,
												"secureOutput": false,
												"secureInput": false
											},
											"userProperties": [],
											"typeProperties": {
												"dataflow": {
													"referenceName": "df_stage_risk_details_cfa",
													"type": "DataFlowReference",
													"parameters": {},
													"datasetParameters": {
														"riskDetailsStaging": {},
														"targetRisk": {},
														"sourceRefLookUp": {},
														"sourceRefLookUpType": {},
														"riskDetailMaxIdTarget": {},
														"riskDetails": {},
														"maxIdLookup": {}
													}
												},
												"staging": {},
												"compute": {
													"coreCount": 8,
													"computeType": "General"
												},
												"traceLevel": "Fine"
											}
										}
									]
								}
							]
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"variables": {
					"isRiskUpdateOnly": {
						"type": "Boolean"
					}
				},
				"folder": {
					"name": "Staging Data Movement"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_stage_risk')]",
				"[concat(variables('factoryId'), '/dataflows/df_stage_risk_details')]",
				"[concat(variables('factoryId'), '/dataflows/df_stage_risk_details_cfa')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_target_quoteinfo_deprecated')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "quoteInfo",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_target_quoteInfo_deprecated",
								"type": "DataFlowReference",
								"parameters": {
									"policyPrefix": {
										"value": "'@{pipeline().globalParameters.policyPrefix}'",
										"type": "Expression"
									},
									"policies": {
										"value": "@pipeline().globalParameters.policies",
										"type": "Expression"
									}
								},
								"datasetParameters": {
									"policyTarget": {},
									"policyTrackerTarget": {},
									"sink1": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "utility"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_target_quoteInfo_deprecated')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_target_updateagentparty')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Update Party and Agent in Policy json",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_update_stage_policy_agent_clientparticipant",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"policyPartyBridgeStaging": {},
									"partyroleStaging": {},
									"agencyTarget": {},
									"policyTarget": {},
									"policyTargetSink": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "Staging Data Movement/JsonUpdate"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_update_stage_policy_agent_clientparticipant')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_temp_clientPartToBlank')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Data flow1",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_clientPartToBlank",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"policy": {},
									"ecmInsured": {},
									"sink1": {}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "Staging Data Movement/JsonUpdate"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_clientPartToBlank')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/DelimitedText1')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "AzureBlobStorage1",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobStorageLocation",
						"container": "migration"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzureBlobStorage1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ECMBPA_COV_MAP')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "postgresTest",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "AzurePostgreSqlTable",
				"schema": [
					{
						"name": "COV_SEQ",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "BPA_SECTION_CODE",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "COVERAGE_CODE",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "COVERAGE_CODE_DES",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "BPA_COVERAGE_CODES",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "BPA_COVERAGES",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "COVERAGES",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "BPA_PRODUCT_CODE",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "SI_NO",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "id",
						"type": "bigint",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "BPA_SEC_NAME",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "SOURCE_PRODUCT_CODE",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "bpa_coverage_group",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "bpa_coverage_level",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "bpa_coverage_type",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					}
				],
				"typeProperties": {
					"schema": "public",
					"table": "ecm_bpa_cov_mapping"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/postgresTest')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ECM_BPA_COV_Mapping')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "AzureBlobStorage1",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "Excel",
				"typeProperties": {
					"sheetName": "Sheet1",
					"location": {
						"type": "AzureBlobStorageLocation",
						"fileName": "coverages_BPA_MetaV2.xlsx",
						"container": "migration"
					},
					"firstRowAsHeader": true
				},
				"schema": [
					{
						"name": "SI_NO",
						"type": "String"
					},
					{
						"name": "COV_SEQ",
						"type": "String"
					},
					{
						"name": "COVERAGE_CODE",
						"type": "String"
					},
					{
						"name": "COVERAGE_CODE_DES",
						"type": "String"
					},
					{
						"name": "COVERAGES",
						"type": "String"
					},
					{
						"name": "BPA_SEC_NAME",
						"type": "String"
					},
					{
						"name": "BPA_SECTION_CODE",
						"type": "String"
					},
					{
						"name": "BPA_COVERAGES",
						"type": "String"
					},
					{
						"name": "BPA_COVERAGE_CODES",
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzureBlobStorage1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/StgLookUpType')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "sourceStageDB",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [
					{
						"name": "LOOKUP_TYPE_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "LOOKUP_TYPE_DOMAIN",
						"type": "nvarchar"
					},
					{
						"name": "BATCH_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "DELETED_YN",
						"type": "nchar"
					},
					{
						"name": "IS_VALID_YN",
						"type": "nchar"
					},
					{
						"name": "VALID_START_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "VALID_END_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "BPAM_LAST_MODIFIED_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "BPAM_LAST_CREATED_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "DATA_HASH",
						"type": "varbinary"
					},
					{
						"name": "SOURCE_KEY",
						"type": "nvarchar"
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "REF_LOOKUP_TYPE"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/sourceStageDB')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/StgRefLookUp')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "sourceStageDB",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [
					{
						"name": "LOOKUP_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "LOOKUP_TYPE_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "LOOKUP_CODE",
						"type": "nvarchar"
					},
					{
						"name": "LOOKUP_SHORT_DESCRIPTION",
						"type": "nvarchar"
					},
					{
						"name": "LOOKUP_DESCRIPTION",
						"type": "nvarchar"
					},
					{
						"name": "BATCH_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "DELETED_YN",
						"type": "nchar"
					},
					{
						"name": "IS_VALID_YN",
						"type": "nchar"
					},
					{
						"name": "VALID_START_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "VALID_END_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "BPAM_LAST_MODIFIED_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "BPAM_LAST_CREATED_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "DATA_HASH",
						"type": "varbinary"
					},
					{
						"name": "SOURCE_KEY",
						"type": "nvarchar"
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "REF_LOOKUP"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/sourceStageDB')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/bpa_CFA_product_json')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "AzureBlobStorage1",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "CFA"
				},
				"annotations": [],
				"type": "Json",
				"typeProperties": {
					"location": {
						"type": "AzureBlobStorageLocation",
						"fileName": "CFA1_1.0.417.json",
						"container": "migration"
					}
				},
				"schema": {
					"type": "object",
					"properties": {
						"BroadLine": {
							"type": "string"
						},
						"Sections": {
							"type": "array",
							"items": {
								"type": "object",
								"properties": {
									"Code": {
										"type": "string"
									},
									"DisplayName": {
										"type": "string"
									},
									"Description": {
										"type": "string"
									},
									"LOB": {
										"type": "string"
									},
									"SequenceNumber": {
										"type": "integer"
									},
									"IsPrimary": {
										"type": "boolean"
									},
									"IsMandatory": {
										"type": "boolean"
									},
									"Coverages": {
										"type": "array",
										"items": {
											"type": "object",
											"properties": {
												"Code": {
													"type": "string"
												},
												"DisplayName": {
													"type": "string"
												},
												"CoverageType": {
													"type": "string"
												},
												"Limit": {
													"type": "array",
													"items": {
														"type": "object",
														"properties": {
															"TypeCode": {
																"type": "string"
															},
															"Min": {
																"type": "number"
															},
															"Max": {
																"type": "integer"
															},
															"ValueType": {
																"type": "string"
															},
															"InputType": {
																"type": "string"
															},
															"Name": {
																"type": "string"
															}
														}
													}
												},
												"Level": {
													"type": "string"
												},
												"IsMandatory": {
													"type": "boolean"
												},
												"IsDefault": {
													"type": "boolean"
												}
											}
										}
									},
									"IsSharedCarrier": {
										"type": "boolean"
									}
								}
							}
						}
					}
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzureBlobStorage1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/bpa_emp_product')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "AzureBlobStorage1",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "Json",
				"typeProperties": {
					"location": {
						"type": "AzureBlobStorageLocation",
						"fileName": "EMP1_1.0.3.json",
						"container": "migration"
					}
				},
				"schema": {
					"type": "object",
					"properties": {
						"BroadLine": {
							"type": "string"
						},
						"Sections": {
							"type": "array",
							"items": {
								"type": "object",
								"properties": {
									"Code": {
										"type": "string"
									},
									"DisplayName": {
										"type": "string"
									},
									"Description": {
										"type": "string"
									},
									"LOB": {
										"type": "string"
									},
									"SequenceNumber": {
										"type": "integer"
									},
									"IsPrimary": {
										"type": "boolean"
									},
									"IsMandatory": {
										"type": "boolean"
									},
									"Coverages": {
										"type": "array",
										"items": {
											"type": "object",
											"properties": {
												"Code": {
													"type": "string"
												},
												"DisplayName": {
													"type": "string"
												},
												"CoverageType": {
													"type": "string"
												},
												"Limit": {
													"type": "array",
													"items": {
														"type": "object",
														"properties": {
															"TypeCode": {
																"type": "string"
															},
															"Min": {
																"type": "number"
															},
															"Max": {
																"type": "integer"
															},
															"ValueType": {
																"type": "string"
															},
															"InputType": {
																"type": "string"
															},
															"Name": {
																"type": "string"
															}
														}
													}
												},
												"Level": {
													"type": "string"
												},
												"IsMandatory": {
													"type": "boolean"
												},
												"IsDefault": {
													"type": "boolean"
												}
											}
										}
									},
									"IsSharedCarrier": {
										"type": "boolean"
									}
								}
							}
						}
					}
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzureBlobStorage1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/dsCFA')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "AzureBlobStorage1",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "CFA"
				},
				"annotations": [],
				"type": "Excel",
				"typeProperties": {
					"location": {
						"type": "AzureBlobStorageLocation",
						"fileName": "coverages_BPA_MetaV2.xlsx",
						"container": "migration"
					},
					"sheetIndex": 0,
					"firstRowAsHeader": true
				},
				"schema": [
					{
						"name": "SI_NO",
						"type": "String"
					},
					{
						"name": "id",
						"type": "String"
					},
					{
						"name": "COVERAGE_CODE",
						"type": "String"
					},
					{
						"name": "COV_SEQ",
						"type": "String"
					},
					{
						"name": "COVERAGE_CODE_DES",
						"type": "String"
					},
					{
						"name": "COVERAGES",
						"type": "String"
					},
					{
						"name": "BPA_COVERAGE_CODES",
						"type": "String"
					},
					{
						"name": "BPA_SECTION_CODE",
						"type": "String"
					},
					{
						"name": "BPA_SEC_NAME",
						"type": "String"
					},
					{
						"name": "BPA_COVERAGES",
						"type": "String"
					},
					{
						"name": "BPA Coverage Groups",
						"type": "String"
					},
					{
						"name": "BPA Coverage Type",
						"type": "String"
					},
					{
						"name": "BPA_PRODUCT_CODE",
						"type": "String"
					},
					{
						"name": "SOURCE_PRODUCT_CODE",
						"type": "String"
					},
					{
						"name": "coverage_level",
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzureBlobStorage1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_BPA_limit')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_DM_Stage_Target",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "AzurePostgreSqlTable",
				"schema": [
					{
						"name": "limit_id",
						"type": "bigint",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "coverageCode",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "secCode",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "limitValueType",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "limitTypeCode",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "limitName",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "coverage_group_code",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					}
				],
				"typeProperties": {
					"schema": "public",
					"table": "bpa_limit_detail"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/ls_DM_Stage_Target')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_calculate_premium')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "RestService2",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"baseURL": {
						"type": "string"
					},
					"domain": {
						"type": "string"
					}
				},
				"folder": {
					"name": "rest"
				},
				"annotations": [],
				"type": "RestResource",
				"typeProperties": {
					"relativeUrl": "/policyadmin-api/calculateRatedValues/v1/quote"
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/RestService2')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_ecm_state_code')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ecmmigrationdb",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [
					{
						"name": "StateCode",
						"type": "char"
					},
					{
						"name": "StateAbbreviation",
						"type": "char"
					},
					{
						"name": "StateName",
						"type": "varchar"
					},
					{
						"name": "WCTypeOfLossGroupCode",
						"type": "varchar"
					},
					{
						"name": "QuickRaterStateID",
						"type": "smallint",
						"precision": 5
					},
					{
						"name": "AutoDoNotRenewDays",
						"type": "smallint",
						"precision": 5
					},
					{
						"name": "AutoConditionalRenewalNoticeDays",
						"type": "smallint",
						"precision": 5
					},
					{
						"name": "AutoUMLimitFlag",
						"type": "char"
					},
					{
						"name": "AutoStateBand",
						"type": "char"
					},
					{
						"name": "AutoRegionID",
						"type": "smallint",
						"precision": 5
					},
					{
						"name": "StateTypeCode",
						"type": "char"
					},
					{
						"name": "FIPSStateCode",
						"type": "char"
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "dimState"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/ecmmigrationdb')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_error_location_risk_bridge')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ecmmigrationdb",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [],
				"typeProperties": {
					"schema": "dbo",
					"table": "RISK_LOCATION_ERROR"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/ecmmigrationdb')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_source_FactCoverageDeductible')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ecmmigrationdb",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Source/ecm"
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [
					{
						"name": "Policy",
						"type": "varchar"
					},
					{
						"name": "Policy_Sequence",
						"type": "varchar"
					},
					{
						"name": "PolicyPrefix",
						"type": "char"
					},
					{
						"name": "ARICCoverageCode",
						"type": "varchar"
					},
					{
						"name": "ARICCoverageDescription",
						"type": "varchar"
					},
					{
						"name": "CoverageDescription",
						"type": "char"
					},
					{
						"name": "CoverageInternalCode",
						"type": "char"
					},
					{
						"name": "LocationState",
						"type": "char"
					},
					{
						"name": "ARICLOB",
						"type": "char"
					},
					{
						"name": "LocationNumber",
						"type": "varchar"
					},
					{
						"name": "LocationUnitNumber",
						"type": "varchar"
					},
					{
						"name": "ARICCoverageSequence",
						"type": "int",
						"precision": 10
					},
					{
						"name": "CoveragePart",
						"type": "char"
					},
					{
						"name": "CoverageAddDate",
						"type": "datetime",
						"precision": 23,
						"scale": 3
					},
					{
						"name": "DESDSC",
						"type": "char"
					},
					{
						"name": "DEDESC",
						"type": "char"
					},
					{
						"name": "DeductibleCode",
						"type": "varchar"
					},
					{
						"name": "DeductibleAmount1Type",
						"type": "char"
					},
					{
						"name": "DeductibleAmount1",
						"type": "decimal",
						"precision": 7,
						"scale": 0
					},
					{
						"name": "DeductibleAmount2Type",
						"type": "char"
					},
					{
						"name": "DeductibleAmount2",
						"type": "decimal",
						"precision": 7,
						"scale": 0
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "Fact_Coverage_Deductible"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/ecmmigrationdb')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_source_Fact_Coverage_Premium')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ecmmigrationdb",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Source/ecm"
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [
					{
						"name": "Policy",
						"type": "varchar"
					},
					{
						"name": "Policy_Sequence",
						"type": "varchar"
					},
					{
						"name": "PolicyPrefix",
						"type": "char"
					},
					{
						"name": "ARICLOB",
						"type": "char"
					},
					{
						"name": "ARICGroupCode",
						"type": "char"
					},
					{
						"name": "Description",
						"type": "char"
					},
					{
						"name": "Product",
						"type": "char"
					},
					{
						"name": "ARICCoverageCode",
						"type": "varchar"
					},
					{
						"name": "ARICCoverageDescription",
						"type": "varchar"
					},
					{
						"name": "PrimaryPremiumStateCode",
						"type": "char"
					},
					{
						"name": "LocationNumber",
						"type": "varchar"
					},
					{
						"name": "LocationUnitNumber",
						"type": "varchar"
					},
					{
						"name": "ARICCoverageSequence",
						"type": "int",
						"precision": 10
					},
					{
						"name": "CoveragePart",
						"type": "char"
					},
					{
						"name": "CoverageAddDate",
						"type": "datetime",
						"precision": 23,
						"scale": 3
					},
					{
						"name": "CoverageDescription",
						"type": "char"
					},
					{
						"name": "Limit1",
						"type": "decimal",
						"precision": 38,
						"scale": 0
					},
					{
						"name": "Limit2",
						"type": "decimal",
						"precision": 38,
						"scale": 0
					},
					{
						"name": "PremiumAmount",
						"type": "decimal",
						"precision": 38,
						"scale": 2
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "Fact_Coverage_Premium"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/ecmmigrationdb')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_source_POL_TX_LIMIT_DED_OPT')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "sourceStageDB",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Source/ecm"
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [
					{
						"name": "TX_LIMIT_DED_OPT_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "TX_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "LOCATION_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "LOCATION_OVID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "SECTION_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "SECTION_OVID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "TX_BRIDGE_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "RISK_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "RISK_OVID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "POLICY_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "POLICY_OVID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "LIMIT_DED_OPT_TYPE_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "LDO_FLAG",
						"type": "nchar"
					},
					{
						"name": "LDO_CODE",
						"type": "nvarchar"
					},
					{
						"name": "LIMIT_OCCURRENCE_FLAG",
						"type": "nvarchar"
					},
					{
						"name": "LDO_VALUE",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "LDO_VALUE_CCY_CODE",
						"type": "nvarchar"
					},
					{
						"name": "LDO_PERCENTAGE",
						"type": "decimal",
						"precision": 6,
						"scale": 4
					},
					{
						"name": "LDO_TEXT",
						"type": "nvarchar"
					},
					{
						"name": "BATCH_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "UNIQUE_IDENTIFIER",
						"type": "nvarchar"
					},
					{
						"name": "DELETED_YN",
						"type": "nchar"
					},
					{
						"name": "BPAM_LAST_MODIFIED_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "BPAM_LAST_CREATED_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "DATA_HASH",
						"type": "varbinary"
					},
					{
						"name": "SOURCE_KEY",
						"type": "nvarchar"
					},
					{
						"name": "COVERAGE_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "COVERAGE_OVID",
						"type": "bigint",
						"precision": 19
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "POL_TX_LIMIT_DED_OPT"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/sourceStageDB')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_source_PolicyAutoUnit')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ecmmigrationdb",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Source/ecm"
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [
					{
						"name": "PolicyPrefix",
						"type": "char"
					},
					{
						"name": "Policy",
						"type": "varchar"
					},
					{
						"name": "Policy_Sequence",
						"type": "varchar"
					},
					{
						"name": "RowStatus",
						"type": "char"
					},
					{
						"name": "EffectiveDate",
						"type": "datetime",
						"precision": 23,
						"scale": 3
					},
					{
						"name": "ExpirationDate",
						"type": "datetime",
						"precision": 23,
						"scale": 3
					},
					{
						"name": "LocationNumber",
						"type": "varchar"
					},
					{
						"name": "LocationUnitNumber",
						"type": "varchar"
					},
					{
						"name": "UnitType/ModificationType",
						"type": "varchar"
					},
					{
						"name": "YearBuild",
						"type": "smallint",
						"precision": 5
					},
					{
						"name": "UnitValue",
						"type": "decimal",
						"precision": 13,
						"scale": 0
					},
					{
						"name": "RiskUseCode",
						"type": "char"
					},
					{
						"name": "Make",
						"type": "varchar"
					},
					{
						"name": "Model",
						"type": "varchar"
					},
					{
						"name": "UnitWidth",
						"type": "smallint",
						"precision": 5
					},
					{
						"name": "ISOClassCode",
						"type": "varchar"
					},
					{
						"name": "RiskType",
						"type": "char"
					},
					{
						"name": "UnitLength",
						"type": "smallint",
						"precision": 5
					},
					{
						"name": "PurchaseDate",
						"type": "datetime",
						"precision": 23,
						"scale": 3
					},
					{
						"name": "AppraisalYear",
						"type": "smallint",
						"precision": 5
					},
					{
						"name": "UnitDescription",
						"type": "varchar"
					},
					{
						"name": "AnimalUseCode",
						"type": "char"
					},
					{
						"name": "LeaseFlag",
						"type": "char"
					},
					{
						"name": "AppraisalFlag",
						"type": "char"
					},
					{
						"name": "RegistrationState",
						"type": "char"
					},
					{
						"name": "VehicleID",
						"type": "varchar"
					},
					{
						"name": "EngineDisplacement",
						"type": "smallint",
						"precision": 5
					},
					{
						"name": "FuelTypeCode",
						"type": "varchar"
					},
					{
						"name": "Layup",
						"type": "char"
					},
					{
						"name": "ID",
						"type": "int",
						"precision": 10
					},
					{
						"name": "DataSource",
						"type": "char"
					},
					{
						"name": "DW_InsertDate",
						"type": "date"
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "PolicyAutoUnit_P"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/ecmmigrationdb')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_source_agent')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ecmmigrationdb",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Source/ecm"
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [
					{
						"name": "AgentCode",
						"type": "char"
					},
					{
						"name": "AgentName",
						"type": "varchar"
					},
					{
						"name": "GroupCode",
						"type": "varchar"
					},
					{
						"name": "AgentStatus",
						"type": "varchar"
					},
					{
						"name": "StartDate",
						"type": "date"
					},
					{
						"name": "EndDate",
						"type": "date"
					},
					{
						"name": "AgentOffice",
						"type": "varchar"
					},
					{
						"name": "RenewalNoticeDays",
						"type": "smallint",
						"precision": 5
					},
					{
						"name": "AuditExclusion",
						"type": "char"
					},
					{
						"name": "AuditThreshold",
						"type": "decimal",
						"precision": 8,
						"scale": 0
					},
					{
						"name": "IssuanceGroup",
						"type": "varchar"
					},
					{
						"name": "DefaultBusinessDivisionID",
						"type": "int",
						"precision": 10
					},
					{
						"name": "DefaultPricingProductID",
						"type": "smallint",
						"precision": 5
					},
					{
						"name": "OfficeID",
						"type": "smallint",
						"precision": 5
					},
					{
						"name": "EMail",
						"type": "varchar"
					},
					{
						"name": "AgentAddress1",
						"type": "varchar"
					},
					{
						"name": "AgentAddress2",
						"type": "varchar"
					},
					{
						"name": "AgentAddress3",
						"type": "varchar"
					},
					{
						"name": "AgentCity",
						"type": "varchar"
					},
					{
						"name": "AgentState",
						"type": "varchar"
					},
					{
						"name": "AgentZipCode",
						"type": "varchar"
					},
					{
						"name": "AgentPhone",
						"type": "varchar"
					},
					{
						"name": "AgentCounty",
						"type": "varchar"
					},
					{
						"name": "AgentContact",
						"type": "varchar"
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "dimAgent"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/ecmmigrationdb')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_source_company')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ecmmigrationdb",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Source/ecm"
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [
					{
						"name": "ID",
						"type": "int",
						"precision": 10
					},
					{
						"name": "WINSCompanyID",
						"type": "char"
					},
					{
						"name": "Name",
						"type": "varchar"
					},
					{
						"name": "NAICNumber",
						"type": "varchar"
					},
					{
						"name": "NAICGroupCode",
						"type": "char"
					},
					{
						"name": "NCCICode",
						"type": "char"
					},
					{
						"name": "ISOCode",
						"type": "char"
					},
					{
						"name": "FEIN",
						"type": "char"
					},
					{
						"name": "AddressLine1",
						"type": "varchar"
					},
					{
						"name": "AddressLine2",
						"type": "varchar"
					},
					{
						"name": "City",
						"type": "varchar"
					},
					{
						"name": "AlphaStateCode",
						"type": "varchar"
					},
					{
						"name": "ZipCode",
						"type": "varchar"
					},
					{
						"name": "CreateTime",
						"type": "datetime",
						"precision": 23,
						"scale": 3
					},
					{
						"name": "CreatedBy",
						"type": "varchar"
					},
					{
						"name": "UpdateTime",
						"type": "datetime",
						"precision": 23,
						"scale": 3
					},
					{
						"name": "UpdatedBy",
						"type": "varchar"
					},
					{
						"name": "AgentUploadFlag",
						"type": "char"
					},
					{
						"name": "ARICGroupCode",
						"type": "char"
					},
					{
						"name": "CompanyGroup",
						"type": "char"
					},
					{
						"name": "ARICDirectAssumed",
						"type": "char"
					},
					{
						"name": "CompanyAbbreviation",
						"type": "varchar"
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "dimCompany"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/ecmmigrationdb')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_source_insuredAddress')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ecmmigrationdb",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Source/ecm"
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [
					{
						"name": "Policy",
						"type": "varchar"
					},
					{
						"name": "Policy_Sequence",
						"type": "char"
					},
					{
						"name": "PolicyPrefix",
						"type": "char"
					},
					{
						"name": "ProductCode",
						"type": "char"
					},
					{
						"name": "EffectiveDate",
						"type": "datetime",
						"precision": 23,
						"scale": 3
					},
					{
						"name": "ExpirationDate",
						"type": "datetime",
						"precision": 23,
						"scale": 3
					},
					{
						"name": "InsuredName",
						"type": "varchar"
					},
					{
						"name": "InsuredAddress1",
						"type": "varchar"
					},
					{
						"name": "InsuredAddress2",
						"type": "varchar"
					},
					{
						"name": "InsuredAddress3",
						"type": "varchar"
					},
					{
						"name": "InsuredCity",
						"type": "varchar"
					},
					{
						"name": "InsuredState",
						"type": "char"
					},
					{
						"name": "InsuredZipCode",
						"type": "varchar"
					},
					{
						"name": "InsuredTelephone",
						"type": "varchar"
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "Insured_Address"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/ecmmigrationdb')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_source_lob')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ecmmigrationdb",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Source/ecm"
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [
					{
						"name": "ARICGroupCode",
						"type": "char"
					},
					{
						"name": "ARICLineOfBusinessID",
						"type": "char"
					},
					{
						"name": "ARICGroupLineDescription",
						"type": "varchar"
					},
					{
						"name": "ARICMajorProductCode",
						"type": "char"
					},
					{
						"name": "ProductCode",
						"type": "varchar"
					},
					{
						"name": "INFCATPProduct",
						"type": "varchar"
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "dimARICCompanyLineofBusiness"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/ecmmigrationdb')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_source_locationAddress')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ecmmigrationdb",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Source/ecm"
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [
					{
						"name": "Policy",
						"type": "varchar"
					},
					{
						"name": "Policy_Sequence",
						"type": "varchar"
					},
					{
						"name": "PolicyPrefix",
						"type": "char"
					},
					{
						"name": "ProductCode",
						"type": "char"
					},
					{
						"name": "LocationNumber",
						"type": "varchar"
					},
					{
						"name": "BuildingNumber",
						"type": "varchar"
					},
					{
						"name": "LocationName",
						"type": "varchar"
					},
					{
						"name": "LocationAddress1",
						"type": "varchar"
					},
					{
						"name": "LocationAddress2",
						"type": "varchar"
					},
					{
						"name": "LocationAddress3",
						"type": "varchar"
					},
					{
						"name": "LocationCity",
						"type": "varchar"
					},
					{
						"name": "LocationZipCode",
						"type": "char"
					},
					{
						"name": "LocationCounty",
						"type": "varchar"
					},
					{
						"name": "Territory",
						"type": "char"
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "Location_Address"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/ecmmigrationdb')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_source_party')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ecmmigrationdb",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Source/ecm"
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [
					{
						"name": "Policy",
						"type": "varchar"
					},
					{
						"name": "Policy_Sequence",
						"type": "varchar"
					},
					{
						"name": "EffectiveDate",
						"type": "datetime",
						"precision": 23,
						"scale": 3
					},
					{
						"name": "ExpirationDate",
						"type": "datetime",
						"precision": 23,
						"scale": 3
					},
					{
						"name": "LocationNumber",
						"type": "varchar"
					},
					{
						"name": "LocationUnitNumber",
						"type": "varchar"
					},
					{
						"name": "InsuredNumber",
						"type": "smallint",
						"precision": 5
					},
					{
						"name": "InsuredType",
						"type": "char"
					},
					{
						"name": "InsuredSubType",
						"type": "char"
					},
					{
						"name": "FirstName",
						"type": "varchar"
					},
					{
						"name": "MiddleName",
						"type": "varchar"
					},
					{
						"name": "LastName",
						"type": "varchar"
					},
					{
						"name": "NameSuffix",
						"type": "varchar"
					},
					{
						"name": "CorporateName",
						"type": "varchar"
					},
					{
						"name": "AlternateName",
						"type": "varchar"
					},
					{
						"name": "MailingAddress1",
						"type": "varchar"
					},
					{
						"name": "MailingAddress2",
						"type": "varchar"
					},
					{
						"name": "MailingCity",
						"type": "varchar"
					},
					{
						"name": "MailingZipCode",
						"type": "varchar"
					},
					{
						"name": "DOB",
						"type": "date"
					},
					{
						"name": "Relationship",
						"type": "char"
					},
					{
						"name": "ExcludedDate",
						"type": "date"
					},
					{
						"name": "DW_InsertDate",
						"type": "date"
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "Additional_Insured"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/ecmmigrationdb')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_source_policyCoverage')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ecmmigrationdb",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Source/ecm"
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [
					{
						"name": "Policy",
						"type": "varchar"
					},
					{
						"name": "Policy_Sequence",
						"type": "varchar"
					},
					{
						"name": "ARICLOB",
						"type": "char"
					},
					{
						"name": "ARICGroupCode",
						"type": "char"
					},
					{
						"name": "Description",
						"type": "char"
					},
					{
						"name": "Product",
						"type": "char"
					},
					{
						"name": "ARICCoverageCode",
						"type": "varchar"
					},
					{
						"name": "ARICCoverageDescription",
						"type": "varchar"
					},
					{
						"name": "EndorsementNumber",
						"type": "smallint",
						"precision": 5
					},
					{
						"name": "LocationNumber",
						"type": "varchar"
					},
					{
						"name": "LocationUnitNumber",
						"type": "varchar"
					},
					{
						"name": "BuildingNumber",
						"type": "varchar"
					},
					{
						"name": "LocationName",
						"type": "varchar"
					},
					{
						"name": "LocationAddress1",
						"type": "varchar"
					},
					{
						"name": "LocationAddress2",
						"type": "varchar"
					},
					{
						"name": "LocationAddress3",
						"type": "varchar"
					},
					{
						"name": "Occupancy",
						"type": "varchar"
					},
					{
						"name": "LocationCity",
						"type": "varchar"
					},
					{
						"name": "LocationZipCode",
						"type": "char"
					},
					{
						"name": "LocationCounty",
						"type": "varchar"
					},
					{
						"name": "Territory",
						"type": "char"
					},
					{
						"name": "ConstructionCode",
						"type": "char"
					},
					{
						"name": "ConstructionYear",
						"type": "int",
						"precision": 10
					},
					{
						"name": "NumberOfFloors",
						"type": "int",
						"precision": 10
					},
					{
						"name": "ProtectionClass",
						"type": "char"
					},
					{
						"name": "GEOLatitude",
						"type": "decimal",
						"precision": 11,
						"scale": 8
					},
					{
						"name": "GEOLongitude",
						"type": "decimal",
						"precision": 11,
						"scale": 8
					},
					{
						"name": "CauseOfLoss",
						"type": "char"
					},
					{
						"name": "BCEGClassCode",
						"type": "char"
					},
					{
						"name": "CoverageForm",
						"type": "varchar"
					},
					{
						"name": "DesignatedPremisis",
						"type": "varchar"
					},
					{
						"name": "WindIndicatorFlag",
						"type": "char"
					},
					{
						"name": "PurchaseCost",
						"type": "decimal",
						"precision": 8,
						"scale": 2
					},
					{
						"name": "dbo",
						"type": "char"
					},
					{
						"name": "CoInsuranceBuilding",
						"type": "int",
						"precision": 10
					},
					{
						"name": "CoInsurancePersonalProperty",
						"type": "int",
						"precision": 10
					},
					{
						"name": "CoInsuranceBodilyInjury",
						"type": "int",
						"precision": 10
					},
					{
						"name": "CountryCode",
						"type": "char"
					},
					{
						"name": "MunicipalityCode",
						"type": "varchar"
					},
					{
						"name": "ParkName",
						"type": "varchar"
					},
					{
						"name": "CountyCode",
						"type": "smallint",
						"precision": 5
					},
					{
						"name": "NumberParkSpaces",
						"type": "int",
						"precision": 10
					},
					{
						"name": "NumberOfAcres",
						"type": "int",
						"precision": 10
					},
					{
						"name": "OwnOrRent",
						"type": "char"
					},
					{
						"name": "ResidenceTypeCode",
						"type": "char"
					},
					{
						"name": "LocationZone",
						"type": "varchar"
					},
					{
						"name": "ARICCoverageSequence",
						"type": "int",
						"precision": 10
					},
					{
						"name": "CoveragePart",
						"type": "char"
					},
					{
						"name": "CoverageAddDate",
						"type": "datetime",
						"precision": 23,
						"scale": 3
					},
					{
						"name": "CoverageDescription",
						"type": "char"
					},
					{
						"name": "CoverageInternalCode",
						"type": "char"
					},
					{
						"name": "CoverageAbbreviation",
						"type": "char"
					},
					{
						"name": "CoveragePartSequence",
						"type": "int",
						"precision": 10
					},
					{
						"name": "CoverageISOLine",
						"type": "int",
						"precision": 10
					},
					{
						"name": "CoverageCATCode",
						"type": "char"
					},
					{
						"name": "CoverageLine4",
						"type": "int",
						"precision": 10
					},
					{
						"name": "CoverageAddUser",
						"type": "char"
					},
					{
						"name": "CoverageUpdateDate",
						"type": "datetime",
						"precision": 23,
						"scale": 3
					},
					{
						"name": "CoverageUpdateUser",
						"type": "char"
					},
					{
						"name": "CoverageLineFlag",
						"type": "char"
					},
					{
						"name": "LocationState",
						"type": "char"
					},
					{
						"name": "ISOClassCode",
						"type": "varchar"
					},
					{
						"name": "RetroEndorsementNumber",
						"type": "int",
						"precision": 10
					},
					{
						"name": "PolicyPrefix",
						"type": "char"
					},
					{
						"name": "EffectiveDate",
						"type": "datetime",
						"precision": 23,
						"scale": 3
					},
					{
						"name": "Policy_Accounting_date",
						"type": "datetime",
						"precision": 23,
						"scale": 3
					},
					{
						"name": "ExpirationDate",
						"type": "datetime",
						"precision": 23,
						"scale": 3
					},
					{
						"name": "CancelDate",
						"type": "datetime",
						"precision": 23,
						"scale": 3
					},
					{
						"name": "CancelReason",
						"type": "varchar"
					},
					{
						"name": "CancelReasonDescription",
						"type": "varchar"
					},
					{
						"name": "PolicyTermMonths",
						"type": "int",
						"precision": 10
					},
					{
						"name": "InsuredName",
						"type": "varchar"
					},
					{
						"name": "InsuredAddress1",
						"type": "varchar"
					},
					{
						"name": "InsuredAddress2",
						"type": "varchar"
					},
					{
						"name": "InsuredCity",
						"type": "varchar"
					},
					{
						"name": "InsuredState",
						"type": "char"
					},
					{
						"name": "InsuredZipCode",
						"type": "varchar"
					},
					{
						"name": "CompanyCode",
						"type": "char"
					},
					{
						"name": "CompanyName",
						"type": "varchar"
					},
					{
						"name": "GroupName",
						"type": "varchar"
					},
					{
						"name": "GBLICompanyCode",
						"type": "char"
					},
					{
						"name": "AgentCode",
						"type": "varchar"
					},
					{
						"name": "AgentName",
						"type": "varchar"
					},
					{
						"name": "AgentOffice",
						"type": "varchar"
					},
					{
						"name": "GroupCode",
						"type": "varchar"
					},
					{
						"name": "AgentCity",
						"type": "varchar"
					},
					{
						"name": "EMail",
						"type": "varchar"
					},
					{
						"name": "AgentPhone",
						"type": "varchar"
					},
					{
						"name": "AgentCounty",
						"type": "varchar"
					},
					{
						"name": "AgentZipCode",
						"type": "varchar"
					},
					{
						"name": "AgentAddress1",
						"type": "varchar"
					},
					{
						"name": "AgentAddress2",
						"type": "varchar"
					},
					{
						"name": "AgentState",
						"type": "varchar"
					},
					{
						"name": "SubProducerNumber",
						"type": "varchar"
					},
					{
						"name": "SubProducerCode",
						"type": "varchar"
					},
					{
						"name": "SubProducerName",
						"type": "varchar"
					},
					{
						"name": "SubproducerState",
						"type": "varchar"
					},
					{
						"name": "SubProducerType",
						"type": "varchar"
					},
					{
						"name": "ProductCode",
						"type": "char"
					},
					{
						"name": "ProductCodeDescription",
						"type": "varchar"
					},
					{
						"name": "PreviousPolicy",
						"type": "varchar"
					},
					{
						"name": "OriginalPolicyYear",
						"type": "int",
						"precision": 10
					},
					{
						"name": "NonRenewalReason",
						"type": "char"
					},
					{
						"name": "NonRenewalNoticeDate",
						"type": "datetime",
						"precision": 23,
						"scale": 3
					},
					{
						"name": "DatabaseCode",
						"type": "char"
					},
					{
						"name": "Policy_ID",
						"type": "int",
						"precision": 10
					},
					{
						"name": "MinimumPremium",
						"type": "decimal",
						"precision": 13,
						"scale": 0
					},
					{
						"name": "POlicy_Receive_date",
						"type": "datetime",
						"precision": 23,
						"scale": 3
					},
					{
						"name": "MasterPolicy",
						"type": "varchar"
					},
					{
						"name": "BillingType",
						"type": "char"
					},
					{
						"name": "RowStatus",
						"type": "char"
					},
					{
						"name": "OriginalInceptionDate",
						"type": "datetime",
						"precision": 23,
						"scale": 3
					},
					{
						"name": "MultiplePolicyFlag",
						"type": "char"
					},
					{
						"name": "ARICBusinessUnit",
						"type": "char"
					},
					{
						"name": "HonorCurrentRateFlag",
						"type": "char"
					},
					{
						"name": "FarmType",
						"type": "char"
					},
					{
						"name": "PrimaryPremiumStateCode",
						"type": "char"
					},
					{
						"name": "StateName",
						"type": "varchar"
					},
					{
						"name": "Policy_Insert_Date",
						"type": "date"
					},
					{
						"name": "BillingSystem",
						"type": "varchar"
					},
					{
						"name": "Cov_effective_Date",
						"type": "datetime",
						"precision": 23,
						"scale": 3
					},
					{
						"name": "Cov_Expiry_Date",
						"type": "datetime",
						"precision": 23,
						"scale": 3
					},
					{
						"name": "ReceivedDate",
						"type": "date"
					},
					{
						"name": "CoverageArrayNumber",
						"type": "smallint",
						"precision": 5
					},
					{
						"name": "LiabilityFlag",
						"type": "char"
					},
					{
						"name": "ExperienceModFactor",
						"type": "decimal",
						"precision": 7,
						"scale": 4
					},
					{
						"name": "Exposure",
						"type": "decimal",
						"precision": 8,
						"scale": 0
					},
					{
						"name": "TaxFeeSurchargeFlag",
						"type": "char"
					},
					{
						"name": "CancelReinstateFlag",
						"type": "char"
					},
					{
						"name": "ReleasedFlag",
						"type": "char"
					},
					{
						"name": "ReleaseDate",
						"type": "date"
					},
					{
						"name": "Rate",
						"type": "decimal",
						"precision": 12,
						"scale": 6
					},
					{
						"name": "PremiumStateCode",
						"type": "varchar"
					},
					{
						"name": "Coverage_ID",
						"type": "int",
						"precision": 10
					},
					{
						"name": "Coverage_accounting_date",
						"type": "datetime",
						"precision": 23,
						"scale": 3
					},
					{
						"name": "Coverage_Insert_Date",
						"type": "date"
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "Policy_Coverage"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/ecmmigrationdb')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_source_producer')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ecmmigrationdb",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Source/ecm"
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [
					{
						"name": "SubProducerCode",
						"type": "varchar"
					},
					{
						"name": "SubProducerName",
						"type": "varchar"
					},
					{
						"name": "FergusonSubProducerFlag",
						"type": "varchar"
					},
					{
						"name": "GroupCode",
						"type": "varchar"
					},
					{
						"name": "SubProducerType",
						"type": "varchar"
					},
					{
						"name": "SubproducerState",
						"type": "varchar"
					},
					{
						"name": "DistributionTypeCode",
						"type": "smallint",
						"precision": 5
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "dimSubProducer"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/ecmmigrationdb')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_source_propertyUnits')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ecmmigrationdb",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Source/ecm"
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [
					{
						"name": "PolicyPrefix",
						"type": "char"
					},
					{
						"name": "Policy",
						"type": "varchar"
					},
					{
						"name": "Policy_Sequence",
						"type": "varchar"
					},
					{
						"name": "RowStatus",
						"type": "char"
					},
					{
						"name": "EffectiveDate",
						"type": "datetime",
						"precision": 23,
						"scale": 3
					},
					{
						"name": "ExpirationDate",
						"type": "datetime",
						"precision": 23,
						"scale": 3
					},
					{
						"name": "LocationNumber",
						"type": "varchar"
					},
					{
						"name": "LocationUnitNumber",
						"type": "varchar"
					},
					{
						"name": "UnitType/ModificationType",
						"type": "varchar"
					},
					{
						"name": "YearBuild",
						"type": "smallint",
						"precision": 5
					},
					{
						"name": "UnitValue",
						"type": "decimal",
						"precision": 13,
						"scale": 0
					},
					{
						"name": "SquareFootage",
						"type": "int",
						"precision": 10
					},
					{
						"name": "RiskUseCode",
						"type": "char"
					},
					{
						"name": "Occupancy",
						"type": "char"
					},
					{
						"name": "RoofTypeCode",
						"type": "varchar"
					},
					{
						"name": "RoofYear",
						"type": "smallint",
						"precision": 5
					},
					{
						"name": "Make",
						"type": "varchar"
					},
					{
						"name": "Model",
						"type": "varchar"
					},
					{
						"name": "SerialNumber",
						"type": "varchar"
					},
					{
						"name": "UnitWidth",
						"type": "smallint",
						"precision": 5
					},
					{
						"name": "RiskType",
						"type": "char"
					},
					{
						"name": "UnitLength",
						"type": "smallint",
						"precision": 5
					},
					{
						"name": "PurchasePrice",
						"type": "decimal",
						"precision": 9,
						"scale": 0
					},
					{
						"name": "PurchaseDate",
						"type": "datetime",
						"precision": 23,
						"scale": 3
					},
					{
						"name": "NewUsed",
						"type": "char"
					},
					{
						"name": "ProtectionClass",
						"type": "varchar"
					},
					{
						"name": "NumberOfSections",
						"type": "decimal",
						"precision": 1,
						"scale": 0
					},
					{
						"name": "AppraisalYear",
						"type": "smallint",
						"precision": 5
					},
					{
						"name": "AppraisedValue",
						"type": "decimal",
						"precision": 9,
						"scale": 0
					},
					{
						"name": "ConstructionTypeCode",
						"type": "varchar"
					},
					{
						"name": "ParkCode",
						"type": "char"
					},
					{
						"name": "OrdinanceLawPercent",
						"type": "decimal",
						"precision": 5,
						"scale": 2
					},
					{
						"name": "PropertyLossScore",
						"type": "varchar"
					},
					{
						"name": "ProtectedRiskFlag",
						"type": "char"
					},
					{
						"name": "PreferredRiskFlag",
						"type": "char"
					},
					{
						"name": "ReplaceOrFullRepair",
						"type": "char"
					},
					{
						"name": "MineSubsidenceFlag",
						"type": "char"
					},
					{
						"name": "NumberOfStories",
						"type": "decimal",
						"precision": 3,
						"scale": 0
					},
					{
						"name": "InZoneFlag",
						"type": "char"
					},
					{
						"name": "BasicFlag",
						"type": "char"
					},
					{
						"name": "DwellingUnits",
						"type": "char"
					},
					{
						"name": "ElectricSystemTypeCode",
						"type": "char"
					},
					{
						"name": "PlumbingSystemTypeCode",
						"type": "char"
					},
					{
						"name": "ExtentOfRoofUpdateCode",
						"type": "char"
					},
					{
						"name": "ElectricSystemYear",
						"type": "smallint",
						"precision": 5
					},
					{
						"name": "ExtentOfElectricSystemUpdate",
						"type": "char"
					},
					{
						"name": "PlumbingSystemYear",
						"type": "smallint",
						"precision": 5
					},
					{
						"name": "ExtentOfPlumbingSystemUpdate",
						"type": "char"
					},
					{
						"name": "HeatingSystemYear",
						"type": "smallint",
						"precision": 5
					},
					{
						"name": "ExtentOfHeatingSystemUpdate",
						"type": "char"
					},
					{
						"name": "MilesToFireDepartmentCode",
						"type": "char"
					},
					{
						"name": "FeetToHydrantCode",
						"type": "char"
					},
					{
						"name": "UnitDescription",
						"type": "varchar"
					},
					{
						"name": "InflationGuardPercent",
						"type": "decimal",
						"precision": 6,
						"scale": 3
					},
					{
						"name": "NumberOfHouseholds",
						"type": "smallint",
						"precision": 5
					},
					{
						"name": "AnimalUseCode",
						"type": "char"
					},
					{
						"name": "AnimalOtherUse",
						"type": "varchar"
					},
					{
						"name": "LeaseFlag",
						"type": "char"
					},
					{
						"name": "ID",
						"type": "int",
						"precision": 10
					},
					{
						"name": "DataSource",
						"type": "char"
					},
					{
						"name": "FirelineScore",
						"type": "varchar"
					},
					{
						"name": "FirelineStatus",
						"type": "varchar"
					},
					{
						"name": "FirelineDate",
						"type": "datetime",
						"precision": 23,
						"scale": 3
					},
					{
						"name": "AnimalDOB",
						"type": "datetime",
						"precision": 23,
						"scale": 3
					},
					{
						"name": "AnimalName",
						"type": "varchar"
					},
					{
						"name": "AnimalBreed",
						"type": "varchar"
					},
					{
						"name": "AnimalBreedOtherDescription",
						"type": "varchar"
					},
					{
						"name": "AnimalSireName",
						"type": "varchar"
					},
					{
						"name": "AnimalDamName",
						"type": "varchar"
					},
					{
						"name": "AnimalSex",
						"type": "varchar"
					},
					{
						"name": "DW_InsertDate",
						"type": "date"
					},
					{
						"name": "CoveragePart",
						"type": "varchar"
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "PolicyPropertyUnit_P"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/ecmmigrationdb')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_source_stage_ECMDataDictionary')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ecmmigrationdb",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Source Stage"
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [
					{
						"name": "Database",
						"type": "nvarchar"
					},
					{
						"name": "SchemaName",
						"type": "nvarchar"
					},
					{
						"name": "TableName",
						"type": "nvarchar"
					},
					{
						"name": "TableType",
						"type": "varchar"
					},
					{
						"name": "ColumnNumber",
						"type": "int",
						"precision": 10
					},
					{
						"name": "Column",
						"type": "nvarchar"
					},
					{
						"name": "DataType",
						"type": "nvarchar"
					},
					{
						"name": "Length",
						"type": "varchar"
					},
					{
						"name": "DecimalPlaces",
						"type": "varchar"
					},
					{
						"name": "ColumnDescription",
						"type": "varchar"
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "ECMDataDictionary"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/ecmmigrationdb')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_source_stage_POLLIMITDEDOPTTYPE')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "sourceStageDB",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Source Stage"
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [
					{
						"name": "LIMIT_DED_OPT_TYPE_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "POLICY_YN",
						"type": "nchar"
					},
					{
						"name": "LIMIT_DED_OPT_TYPE",
						"type": "nvarchar"
					},
					{
						"name": "LDO_NAME",
						"type": "nvarchar"
					},
					{
						"name": "LOCATION_YN",
						"type": "nchar"
					},
					{
						"name": "RISK_YN",
						"type": "nchar"
					},
					{
						"name": "SECTION_YN",
						"type": "nchar"
					},
					{
						"name": "COVERAGE_YN",
						"type": "nchar"
					},
					{
						"name": "GRAIN_CD",
						"type": "nchar"
					},
					{
						"name": "IS_KEY_LDO_YN",
						"type": "nchar"
					},
					{
						"name": "LDO_COLUMN_NAME",
						"type": "nvarchar"
					},
					{
						"name": "IS_VALID_YN",
						"type": "nchar"
					},
					{
						"name": "VALID_START_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "VALID_END_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "BATCH_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "UNIQUE_IDENTIFIER",
						"type": "nvarchar"
					},
					{
						"name": "DELETED_YN",
						"type": "nchar"
					},
					{
						"name": "BPAM_LAST_MODIFIED_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "BPAM_LAST_CREATED_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "SOURCE_KEY",
						"type": "nvarchar"
					},
					{
						"name": "DATA_HASH",
						"type": "varbinary"
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "POL_LIMIT_DED_OPT_TYPE"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/sourceStageDB')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_source_stage__emp_riskType_excel')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "AzureBlobStorage1",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Source Stage"
				},
				"annotations": [],
				"type": "Excel",
				"typeProperties": {
					"sheetName": "RISK TYPE CODES",
					"location": {
						"type": "AzureBlobStorageLocation",
						"fileName": "Mortality_Reverse_Migration_Mapping_v22.0_new (1).xlsx",
						"container": "migration"
					},
					"firstRowAsHeader": true
				},
				"schema": [
					{
						"name": "UNIT_TYPE",
						"type": "String"
					},
					{
						"name": "RSKTYPE",
						"type": "String"
					},
					{
						"name": "RISK_TYPE_CODE",
						"type": "String"
					},
					{
						"name": "DIMENSION_NAME",
						"type": "String"
					},
					{
						"name": "RISK_TYPE_CODE_DESC",
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzureBlobStorage1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_source_stage_agency')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "sourceStageDB",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Source Stage"
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [
					{
						"name": "AGENCY_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "AGENCY_VID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "AGENCY_GEN_ADDRESS_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "AGENCY_CODE",
						"type": "nvarchar"
					},
					{
						"name": "AGENCY_NAME",
						"type": "nvarchar"
					},
					{
						"name": "AGENCY_STATUS",
						"type": "nvarchar"
					},
					{
						"name": "AGENCY_CATEGORY",
						"type": "nvarchar"
					},
					{
						"name": "DIRECT_BILL_FLAG_YN",
						"type": "nchar"
					},
					{
						"name": "TELEPHONE",
						"type": "nvarchar"
					},
					{
						"name": "FAX",
						"type": "nvarchar"
					},
					{
						"name": "EMAIL_ID",
						"type": "nvarchar"
					},
					{
						"name": "WEBSITE",
						"type": "nvarchar"
					},
					{
						"name": "IS_VALID_YN",
						"type": "nchar"
					},
					{
						"name": "VALID_START_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "VALID_END_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "BATCH_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "UNIQUE_IDENTIFIER",
						"type": "nvarchar"
					},
					{
						"name": "DELETED_YN",
						"type": "nchar"
					},
					{
						"name": "BPAM_LAST_MODIFIED_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "BPAM_LAST_CREATED_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "ENTITY_TYPE",
						"type": "nvarchar"
					},
					{
						"name": "ENTITY_PARENT_ID",
						"type": "bigint",
						"precision": 19
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "POL_AGENCY"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/sourceStageDB')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_source_stage_company')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "sourceStageDB",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Source Stage"
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [
					{
						"name": "COMPANY_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "COMPANY_VID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "COMPANY_CODE",
						"type": "nvarchar"
					},
					{
						"name": "COMPANY_NAME",
						"type": "nvarchar"
					},
					{
						"name": "IS_VALID_YN",
						"type": "nchar"
					},
					{
						"name": "VALID_START_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "VALID_END_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "BATCH_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "UNIQUE_IDENTIFIER",
						"type": "nvarchar"
					},
					{
						"name": "DELETED_YN",
						"type": "nchar"
					},
					{
						"name": "BPAM_LAST_MODIFIED_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "BPAM_LAST_CREATED_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "CORPORATE_NAME",
						"type": "nvarchar"
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "CO_COMPANY"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/sourceStageDB')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_source_stage_coverage')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "sourceStageDB",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Source Stage"
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [
					{
						"name": "COVERAGE_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "COVERAGE_VID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "COVERAGE_CODE_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "POLICY_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "POLICY_OVID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "COV_STATE_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "COVERAGE_EFFECTIVE_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "COVERAGE_EXPIRATION_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "ASL_CODE",
						"type": "nvarchar"
					},
					{
						"name": "ASSL_CODE",
						"type": "nvarchar"
					},
					{
						"name": "ASL_CODE_GBL",
						"type": "nvarchar"
					},
					{
						"name": "ASSL_CODE_GBL",
						"type": "nvarchar"
					},
					{
						"name": "CLASSIFICATION_CODE_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "CLASSIFICATION_CODE_OVID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "COVERAGE_CODE",
						"type": "nvarchar"
					},
					{
						"name": "RETROACTIVE_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "IS_VALID_YN",
						"type": "nchar"
					},
					{
						"name": "VALID_START_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "VALID_END_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "BATCH_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "UNIQUE_IDENTIFIER",
						"type": "nvarchar"
					},
					{
						"name": "DELETED_YN",
						"type": "nchar"
					},
					{
						"name": "BPAM_LAST_MODIFIED_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "BPAM_LAST_CREATED_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "SOURCE_KEY",
						"type": "nvarchar"
					},
					{
						"name": "DATA_HASH",
						"type": "varbinary"
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "POL_COVERAGE"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/sourceStageDB')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_source_stage_coverageCode')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "sourceStageDB",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Source Stage"
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [
					{
						"name": "COVERAGE_CODE_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "COVERAGE_CODE",
						"type": "nvarchar"
					},
					{
						"name": "COVERAGE_DESCRIPTION",
						"type": "nvarchar"
					},
					{
						"name": "IS_VALID_YN",
						"type": "nchar"
					},
					{
						"name": "VALID_START_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "VALID_END_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "BATCH_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "UNIQUE_IDENTIFIER",
						"type": "nvarchar"
					},
					{
						"name": "DELETED_YN",
						"type": "nchar"
					},
					{
						"name": "BPAM_LAST_MODIFIED_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "BPAM_LAST_CREATED_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "SOURCE_KEY",
						"type": "nvarchar"
					},
					{
						"name": "DATA_HASH",
						"type": "varbinary"
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "POL_COVERAGE_CODE"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/sourceStageDB')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_source_stage_coverageExt')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "sourceStageDB",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Source Stage"
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [
					{
						"name": "COVERAGE_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "COVERAGE_VID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "ARICCoverageSequence",
						"type": "int",
						"precision": 10
					},
					{
						"name": "ARICTaxFeeSurchargeFlag",
						"type": "varchar"
					},
					{
						"name": "PropertyOrCasualty",
						"type": "varchar"
					},
					{
						"name": "ARICGroupCode",
						"type": "varchar"
					},
					{
						"name": "LocationState",
						"type": "varchar"
					},
					{
						"name": "ARICLOB",
						"type": "varchar"
					},
					{
						"name": "CoverageInternalCode",
						"type": "varchar"
					},
					{
						"name": "CoverageAbbreviation",
						"type": "varchar"
					},
					{
						"name": "CoverageDescription",
						"type": "varchar"
					},
					{
						"name": "CoverageArrayNumber",
						"type": "int",
						"precision": 10
					},
					{
						"name": "CoveragePartSequence",
						"type": "int",
						"precision": 10
					},
					{
						"name": "CoveragePart",
						"type": "varchar"
					},
					{
						"name": "CoverageISOLine",
						"type": "int",
						"precision": 10
					},
					{
						"name": "CoverageCATCode",
						"type": "varchar"
					},
					{
						"name": "CoverageFullyEarned",
						"type": "varchar"
					},
					{
						"name": "LiabilityFlag",
						"type": "varchar"
					},
					{
						"name": "CoverageLine4",
						"type": "int",
						"precision": 10
					},
					{
						"name": "CoverageEffectiveDate",
						"type": "datetime",
						"precision": 23,
						"scale": 3
					},
					{
						"name": "CoverageExpirationDate",
						"type": "datetime",
						"precision": 23,
						"scale": 3
					},
					{
						"name": "CoverageAddDate",
						"type": "datetime",
						"precision": 23,
						"scale": 3
					},
					{
						"name": "CoverageAddUser",
						"type": "varchar"
					},
					{
						"name": "CoverageUpdateDate",
						"type": "datetime",
						"precision": 23,
						"scale": 3
					},
					{
						"name": "CoverageUpdateUser",
						"type": "varchar"
					},
					{
						"name": "CoverageLineFlag",
						"type": "varchar"
					},
					{
						"name": "SOURCE_KEY",
						"type": "nvarchar"
					},
					{
						"name": "DATA_HASH",
						"type": "varbinary"
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "POL_COVERAGE_EXT"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/sourceStageDB')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_source_stage_coverage_section_lookup')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "sourceStageDB",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Source Stage"
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [
					{
						"name": "COVERAGE_SECTION_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "PRODUCT_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "COVERAGE_SEQ",
						"type": "int",
						"precision": 10
					},
					{
						"name": "COVERAGE_CODE",
						"type": "int",
						"precision": 10
					},
					{
						"name": "COVERAGE_CODE_DES",
						"type": "nvarchar"
					},
					{
						"name": "COVERAGE_NAME",
						"type": "nvarchar"
					},
					{
						"name": "BPA_SEC_NAME",
						"type": "nvarchar"
					},
					{
						"name": "BPA_SECTION_CODE",
						"type": "nvarchar"
					},
					{
						"name": "BPA_COVERAGES",
						"type": "nvarchar"
					},
					{
						"name": "BPA_COVERAGE_CODES",
						"type": "nvarchar"
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "COVERAGE_SECTION_REF"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/sourceStageDB')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_source_stage_genAddress')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "sourceStageDB",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Source Stage"
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [
					{
						"name": "GEN_ADDRESS_UNIQ_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "ADDRESS_STREET1",
						"type": "nvarchar"
					},
					{
						"name": "ADDRESS_STREET2",
						"type": "nvarchar"
					},
					{
						"name": "COUNTY_CODE",
						"type": "nvarchar"
					},
					{
						"name": "COUNTY",
						"type": "nvarchar"
					},
					{
						"name": "ADDRESS_CITY",
						"type": "nvarchar"
					},
					{
						"name": "ADD_DESCRIPTION",
						"type": "nvarchar"
					},
					{
						"name": "STATE_PROVINCE_CODE",
						"type": "nvarchar"
					},
					{
						"name": "POSTAL_CODE",
						"type": "nvarchar"
					},
					{
						"name": "POSTAL_CODE_EXT",
						"type": "nvarchar"
					},
					{
						"name": "COUNTRY_CODE",
						"type": "nvarchar"
					},
					{
						"name": "SOURCE_INSERTED_ON",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "SOURCE_UPDATED_ON",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "SOURCE_KEY",
						"type": "nvarchar"
					},
					{
						"name": "DATA_HASH",
						"type": "varbinary"
					},
					{
						"name": "TERRITORY",
						"type": "varchar"
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "GEN_ADDRESS"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/sourceStageDB')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_source_stage_insured_location')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "sourceStageDB",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Source Stage"
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [
					{
						"name": "LOCATION_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "LOCATION_VID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "POLICY_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "POLICY_OVID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "LOCATION_IS_ACTIVE_YN",
						"type": "nchar"
					},
					{
						"name": "LOCATION_EFF_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "LOCATION_EXP_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "IS_VALID_YN",
						"type": "nchar"
					},
					{
						"name": "VALID_START_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "VALID_END_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "IS_PRIMARY_LOCATION_YN",
						"type": "nchar"
					},
					{
						"name": "IS_FALSE_ADDRESS",
						"type": "nchar"
					},
					{
						"name": "PROTECTION_CLASS",
						"type": "nvarchar"
					},
					{
						"name": "FIRE_DISTRICT_NAME",
						"type": "nvarchar"
					},
					{
						"name": "BATCH_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "UNIQUE_IDENTIFIER",
						"type": "nvarchar"
					},
					{
						"name": "DELETED_YN",
						"type": "nchar"
					},
					{
						"name": "BPAM_LAST_MODIFIED_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "BPAM_LAST_CREATED_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "GEN_ADDRESS_UNIQ_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "SOURCE_KEY",
						"type": "nvarchar"
					},
					{
						"name": "DATA_HASH",
						"type": "varbinary"
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "POL_INSURED_LOCATION"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/sourceStageDB')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_source_stage_lob')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "sourceStageDB",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Source Stage"
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [
					{
						"name": "LOB_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "LOB_CODE",
						"type": "nvarchar"
					},
					{
						"name": "LOB_NAME",
						"type": "nvarchar"
					},
					{
						"name": "LOB_DESCRIPTION",
						"type": "nvarchar"
					},
					{
						"name": "LOB_IS_VALID_YN",
						"type": "nchar"
					},
					{
						"name": "LOB_VALID_START_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "LOB_VALID_END_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "BATCH_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "UNIQUE_IDENTIFIER",
						"type": "nvarchar"
					},
					{
						"name": "DELETED_YN",
						"type": "nchar"
					},
					{
						"name": "BPAM_LAST_MODIFIED_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "BPAM_LAST_CREATED_DATE",
						"type": "datetime2",
						"scale": 7
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "POL_LOB"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/sourceStageDB')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_source_stage_location')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "sourceStageDB",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Source Stage"
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [
					{
						"name": "LOCATION_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "LOCATION_VID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "LOCATION_NAME",
						"type": "nvarchar"
					},
					{
						"name": "LOCATION_NO",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "POLICY_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "POLICY_OVID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "LOCATION_IS_ACTIVE_YN",
						"type": "nchar"
					},
					{
						"name": "LOCATION_EFF_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "LOCATION_EXP_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "IS_VALID_YN",
						"type": "nchar"
					},
					{
						"name": "VALID_START_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "VALID_END_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "IS_PRIMARY_LOCATION_YN",
						"type": "nchar"
					},
					{
						"name": "IS_FALSE_ADDRESS",
						"type": "nchar"
					},
					{
						"name": "PROTECTION_CLASS",
						"type": "nvarchar"
					},
					{
						"name": "FIRE_DISTRICT_NAME",
						"type": "nvarchar"
					},
					{
						"name": "BATCH_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "UNIQUE_IDENTIFIER",
						"type": "nvarchar"
					},
					{
						"name": "DELETED_YN",
						"type": "nchar"
					},
					{
						"name": "BPAM_LAST_MODIFIED_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "BPAM_LAST_CREATED_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "GEN_ADDRESS_UNIQ_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "SOURCE_KEY",
						"type": "nvarchar"
					},
					{
						"name": "DATA_HASH",
						"type": "varbinary"
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "POL_LOCATION"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/sourceStageDB')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_source_stage_locationRiskBridge')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "sourceStageDB",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Source Stage"
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [
					{
						"name": "LOCATION_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "LOCATION_OVID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "RISK_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "RISK_VID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "IS_VALID_YN",
						"type": "nchar"
					},
					{
						"name": "VALID_START_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "VALID_END_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "BATCH_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "UNIQUE_IDENTIFIER",
						"type": "nvarchar"
					},
					{
						"name": "DELETED_YN",
						"type": "nchar"
					},
					{
						"name": "BPAM_LAST_MODIFIED_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "BPAM_LAST_CREATED_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "DATA_HASH",
						"type": "varbinary"
					},
					{
						"name": "SOURCE_KEY",
						"type": "nvarchar"
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "POL_LOCATION_RISK_BRIDGE"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/sourceStageDB')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_source_stage_party')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "sourceStageDB",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Source Stage"
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [
					{
						"name": "PARTY_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "PARTY_VID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "NAME_PREFIX",
						"type": "nvarchar"
					},
					{
						"name": "FIRST_NAME",
						"type": "nvarchar"
					},
					{
						"name": "MIDDLE_NAME",
						"type": "nvarchar"
					},
					{
						"name": "LAST_NAME",
						"type": "nvarchar"
					},
					{
						"name": "FULL_NAME",
						"type": "nvarchar"
					},
					{
						"name": "DATE_OF_BIRTH",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "GENDER",
						"type": "nvarchar"
					},
					{
						"name": "SSN",
						"type": "nvarchar"
					},
					{
						"name": "HIRE_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "POLICYINATION_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "EMAIL",
						"type": "nvarchar"
					},
					{
						"name": "IS_VALID_YN",
						"type": "nchar"
					},
					{
						"name": "VALID_START_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "VALID_END_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "PARTY_TYPE",
						"type": "nvarchar"
					},
					{
						"name": "PHYSICAL_GEN_ADDRESS_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "HOME_PHONE_NUMBER",
						"type": "nvarchar"
					},
					{
						"name": "FAX_NUMBER",
						"type": "nvarchar"
					},
					{
						"name": "YEARS_WITH_EMPLOYER",
						"type": "int",
						"precision": 10
					},
					{
						"name": "NAME_SUFFIX",
						"type": "nvarchar"
					},
					{
						"name": "MARITAL_STATUS",
						"type": "nvarchar"
					},
					{
						"name": "OCCUPATION",
						"type": "nvarchar"
					},
					{
						"name": "DOING_BUSINESS_AS",
						"type": "nvarchar"
					},
					{
						"name": "DECEASED_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "IS_DECEASED_YN",
						"type": "nchar"
					},
					{
						"name": "GEN_ADDRESS_UNIQ_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "SOURCE_KEY",
						"type": "nvarchar"
					},
					{
						"name": "DATA_HASH",
						"type": "varbinary"
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "POL_PARTY"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/sourceStageDB')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_source_stage_partyrole')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "sourceStageDB",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Source Stage"
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [
					{
						"name": "ROLE_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "ROLE_VID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "ROLE_CODE",
						"type": "nvarchar"
					},
					{
						"name": "ROLE_DESCRIPTION",
						"type": "nvarchar"
					},
					{
						"name": "IS_PRIMARY_INSURED_YN",
						"type": "nchar"
					},
					{
						"name": "IS_DRIVER_YN",
						"type": "nchar"
					},
					{
						"name": "IS_CUSTOMER_YN",
						"type": "nchar"
					},
					{
						"name": "IS_VALID_YN",
						"type": "nchar"
					},
					{
						"name": "VALID_START_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "VALID_END_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "BATCH_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "UNIQUE_IDENTIFIER",
						"type": "nvarchar"
					},
					{
						"name": "DELETED_YN",
						"type": "nchar"
					},
					{
						"name": "BPAM_LAST_MODIFIED_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "BPAM_LAST_CREATED_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "SOURCE_KEY",
						"type": "nvarchar"
					},
					{
						"name": "DATA_HASH",
						"type": "varbinary"
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "POL_PARTY_ROLE"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/sourceStageDB')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_source_stage_polSection')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "sourceStageDB",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Source Stage"
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [
					{
						"name": "SECTION_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "SECTION_VID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "POLICY_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "POLICY_OVID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "COVERAGE_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "COVERAGE_OVID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "LOCATION_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "LOCATION_OVID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "LOB_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "SUB_LOB_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "RATE_SET_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "PRIMARY_POLICY_STATE",
						"type": "nvarchar"
					},
					{
						"name": "BATCH_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "IS_VALID_YN",
						"type": "nchar"
					},
					{
						"name": "VALID_START_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "VALID_END_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "UNIQUE_IDENTIFIER",
						"type": "nvarchar"
					},
					{
						"name": "DELETED_YN",
						"type": "nchar"
					},
					{
						"name": "BPAM_LAST_MODIFIED_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "BPAM_LAST_CREATED_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "DATA_HASH",
						"type": "varbinary"
					},
					{
						"name": "SOURCE_KEY",
						"type": "nvarchar"
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "POL_SECTION"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/sourceStageDB')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_source_stage_polTxn')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "sourceStageDB",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Source Stage"
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [
					{
						"name": "TX_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "POLICY_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "POLICY_OVID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "TX_CODE",
						"type": "nvarchar"
					},
					{
						"name": "SUB_ACTIVITY",
						"type": "nvarchar"
					},
					{
						"name": "ENDORSEMENT_SEQ_NO",
						"type": "int",
						"precision": 10
					},
					{
						"name": "IS_SYSTEM_GENERATED_YN",
						"type": "nchar"
					},
					{
						"name": "ENDORSEMENT_CHANGES",
						"type": "nvarchar"
					},
					{
						"name": "TRANSACTION_EFFECTIVE_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "TRANSACTION_EXPIRY_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "TRANSACTION_BOOK_FLAG_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "PARENT_TRANSACTION_ID",
						"type": "int",
						"precision": 10
					},
					{
						"name": "TRANSACTION_TYPE_CODE",
						"type": "nvarchar"
					},
					{
						"name": "TYPE_OF_CHANGE",
						"type": "nvarchar"
					},
					{
						"name": "TRANSACTION_CREATED_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "TRANSACTION_MODIFIED_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "TRANSACTION_DISPLAY_NAME",
						"type": "nvarchar"
					},
					{
						"name": "TRANSACTION_PERIOD_PRORATION",
						"type": "decimal",
						"precision": 19,
						"scale": 9
					},
					{
						"name": "BATCH_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "UNIQUE_IDENTIFIER",
						"type": "nvarchar"
					},
					{
						"name": "DELETED_YN",
						"type": "nchar"
					},
					{
						"name": "BPAM_LAST_MODIFIED_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "BPAM_LAST_CREATED_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "DATA_HASH",
						"type": "varbinary"
					},
					{
						"name": "SOURCE_KEY",
						"type": "nvarchar"
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "POL_TX"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/sourceStageDB')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_source_stage_polTxnPremium')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "sourceStageDB",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Source Stage"
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [
					{
						"name": "AGENCY_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "AGENCY_VID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "AGENCY_GEN_ADDRESS_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "AGENCY_CODE",
						"type": "nvarchar"
					},
					{
						"name": "AGENCY_NAME",
						"type": "nvarchar"
					},
					{
						"name": "AGENCY_STATUS",
						"type": "nvarchar"
					},
					{
						"name": "AGENCY_CATEGORY",
						"type": "nvarchar"
					},
					{
						"name": "DIRECT_BILL_FLAG_YN",
						"type": "nchar"
					},
					{
						"name": "TELEPHONE",
						"type": "nvarchar"
					},
					{
						"name": "FAX",
						"type": "nvarchar"
					},
					{
						"name": "EMAIL_ID",
						"type": "nvarchar"
					},
					{
						"name": "WEBSITE",
						"type": "nvarchar"
					},
					{
						"name": "IS_VALID_YN",
						"type": "nchar"
					},
					{
						"name": "VALID_START_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "VALID_END_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "BATCH_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "UNIQUE_IDENTIFIER",
						"type": "nvarchar"
					},
					{
						"name": "DELETED_YN",
						"type": "nchar"
					},
					{
						"name": "BPAM_LAST_MODIFIED_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "BPAM_LAST_CREATED_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "ENTITY_TYPE",
						"type": "nvarchar"
					},
					{
						"name": "ENTITY_PARENT_ID",
						"type": "bigint",
						"precision": 19
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "POL_PREMIUM"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/sourceStageDB')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_source_stage_policy')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "sourceStageDB",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Source Stage"
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [
					{
						"name": "POLICY_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "POLICY_VID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "REINSURANCE_DAC",
						"type": "nchar"
					},
					{
						"name": "PREVIOUS_INSURANCE_NO_REMARKS",
						"type": "nvarchar"
					},
					{
						"name": "AGENCY_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "AGENCY_OVID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "PRODUCER_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "PRODUCER_OVID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "PRODUCER_CONTACT_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "PRODUCER_CONTACT_OVID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "POLICY_NUMBER",
						"type": "nvarchar"
					},
					{
						"name": "ENTITY_TYPE",
						"type": "nvarchar"
					},
					{
						"name": "ENTITY_STATUS",
						"type": "nvarchar"
					},
					{
						"name": "IS_RENEWAL_YN",
						"type": "nchar"
					},
					{
						"name": "REVISION_NUMBER",
						"type": "int",
						"precision": 10
					},
					{
						"name": "PRODUCT_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "PRODUCT_OVID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "POLICY_EFFECTIVE_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "POLICY_EXPIRATION_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "NON_RENEWAL_CODE",
						"type": "nvarchar"
					},
					{
						"name": "POLICY_RENEWED_YN",
						"type": "nchar"
					},
					{
						"name": "CANCELLATION_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "IS_RENEWABLE_YN",
						"type": "nchar"
					},
					{
						"name": "PREVIOUS_INSURANCE_NO_REASON",
						"type": "nvarchar"
					},
					{
						"name": "POLICY_STATUS",
						"type": "nvarchar"
					},
					{
						"name": "CANCEL_REASON_CODE",
						"type": "nvarchar"
					},
					{
						"name": "CANCEL_REASON_DESCRIPTION",
						"type": "nvarchar"
					},
					{
						"name": "CANCEL_METHOD",
						"type": "nvarchar"
					},
					{
						"name": "CANCEL_METHOD_DESC",
						"type": "nvarchar"
					},
					{
						"name": "LOSE_REASON_CODE",
						"type": "nvarchar"
					},
					{
						"name": "LOSE_REASON_DESC",
						"type": "nvarchar"
					},
					{
						"name": "DECLINATION_REASON_CODE",
						"type": "nvarchar"
					},
					{
						"name": "DECLINATION_REASON_DESC",
						"type": "nvarchar"
					},
					{
						"name": "NOT_WRITTEN_REASON_CODE",
						"type": "nvarchar"
					},
					{
						"name": "NOT_WRITTEN_REASON_DESC",
						"type": "nvarchar"
					},
					{
						"name": "POLICY_STATE_CODE",
						"type": "nvarchar"
					},
					{
						"name": "PROGRAM_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "PROGRAM_OVID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "BILLING_TYPE_CODE",
						"type": "nvarchar"
					},
					{
						"name": "UNDERWRITING_COMPANY_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "UNDERWRITING_COMPANY_OVID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "SUBMISSION_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "PREVIOUS_INSURANCE_YN",
						"type": "nchar"
					},
					{
						"name": "LEGACY_POLICY_NUMBER",
						"type": "nvarchar"
					},
					{
						"name": "STATE",
						"type": "nvarchar"
					},
					{
						"name": "POLICY_POLICY",
						"type": "smallint",
						"precision": 5
					},
					{
						"name": "PAYMENT_PLAN",
						"type": "nvarchar"
					},
					{
						"name": "APPLICATION_RECEIVED_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "INCEPTION_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "BILL_TYPE",
						"type": "nvarchar"
					},
					{
						"name": "FORMS_LANGUAGE",
						"type": "nvarchar"
					},
					{
						"name": "BASE_CURRENCY",
						"type": "nvarchar"
					},
					{
						"name": "INVOICE_CURRENCY",
						"type": "nvarchar"
					},
					{
						"name": "PREVIOUS_POLICY_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "PREVIOUS_POLICY_OVID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "REVISED_FROM_POLICY_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "REVISED_FROM_POLICY_OVID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "OPERATING_COMPANY_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "OPERATING_COMPANY_OVID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "CONVERTED_FROM_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "CONVERTED_FROM_OVID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "INSTALLMENT_RENEWAL",
						"type": "nvarchar"
					},
					{
						"name": "IS_VALID_YN",
						"type": "nchar"
					},
					{
						"name": "VALID_START_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "BPAM_LAST_MODIFIED_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "VALID_END_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "BATCH_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "UNIQUE_IDENTIFIER",
						"type": "nvarchar"
					},
					{
						"name": "DELETED_YN",
						"type": "nchar"
					},
					{
						"name": "SOURCE_KEY",
						"type": "nvarchar"
					},
					{
						"name": "DATA_HASH",
						"type": "varbinary"
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "POL_POLICY"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/sourceStageDB')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_source_stage_policyRisk')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "sourceStageDB",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Source Stage"
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [
					{
						"name": "RISK_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "RISK_VID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "RISK_NUMBER",
						"type": "nvarchar"
					},
					{
						"name": "POLICY_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "POLICY_OVID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "RISK_IS_ACTIVE_YN",
						"type": "nchar"
					},
					{
						"name": "RISK_EFF_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "RISK_EXP_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "IS_VALID_YN",
						"type": "nchar"
					},
					{
						"name": "VALID_START_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "VALID_END_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "RISK_TYPE_CD",
						"type": "nvarchar"
					},
					{
						"name": "RISK_CODE",
						"type": "nvarchar"
					},
					{
						"name": "BATCH_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "UNIQUE_IDENTIFIER",
						"type": "nvarchar"
					},
					{
						"name": "DELETED_YN",
						"type": "nchar"
					},
					{
						"name": "BPAM_LAST_MODIFIED_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "BPAM_LAST_CREATED_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "SOURCE_KEY",
						"type": "nvarchar"
					},
					{
						"name": "DATA_HASH",
						"type": "varbinary"
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "POL_RISK"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/sourceStageDB')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_source_stage_policyRiskDetails')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "sourceStageDB",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Source Stage"
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [
					{
						"name": "RISK_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "RISK_VID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "RISK_TYPE_CD",
						"type": "nvarchar"
					},
					{
						"name": "RISK_CODE",
						"type": "nvarchar"
					},
					{
						"name": "ATTRIBUTE_NAME",
						"type": "nvarchar"
					},
					{
						"name": "ATTRIBUTE_VALUE",
						"type": "nvarchar"
					},
					{
						"name": "SORT_ORDER",
						"type": "int",
						"precision": 10
					},
					{
						"name": "BATCH_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "DELETED_YN",
						"type": "nchar"
					},
					{
						"name": "BPAM_LAST_MODIFIED_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "BPAM_LAST_CREATED_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "SOURCE_KEY",
						"type": "nvarchar"
					},
					{
						"name": "DATA_HASH",
						"type": "varbinary"
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "POL_RISK_DETAILS"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/sourceStageDB')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_source_stage_policy_partyrole_bridge')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "sourceStageDB",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Source Stage"
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [
					{
						"name": "POLICY_PARTY_ROLE_BRIDGE_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "ROLE_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "ROLE_OVID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "POLICY_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "POLICY_OVID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "PARTY_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "PARTY_OVID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "IS_VALID_YN",
						"type": "nchar"
					},
					{
						"name": "VALID_START_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "VALID_END_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "BATCH_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "SOURCE_SYSTEM",
						"type": "nvarchar"
					},
					{
						"name": "SOURCE_KEY",
						"type": "nvarchar"
					},
					{
						"name": "UNIQUE_IDENTIFIER",
						"type": "nvarchar"
					},
					{
						"name": "DATA_HASH",
						"type": "varbinary"
					},
					{
						"name": "DELETED_YN",
						"type": "nchar"
					},
					{
						"name": "BPAM_LAST_MODIFIED_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "BPAM_LAST_CREATED_DATE",
						"type": "datetime2",
						"scale": 7
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "POL_POLICY_PARTY_ROLE_BRIDGE"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/sourceStageDB')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_source_stage_sub_LOB')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "sourceStageDB",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Source Stage"
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [
					{
						"name": "SUB_LOB_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "SUB_LOB_CODE",
						"type": "nvarchar"
					},
					{
						"name": "SUB_LOB_NAME",
						"type": "nvarchar"
					},
					{
						"name": "SUB_LOB_DESCRIPTION",
						"type": "nvarchar"
					},
					{
						"name": "BATCH_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "UNIQUE_IDENTIFIER",
						"type": "nvarchar"
					},
					{
						"name": "BPAM_LAST_MODIFIED_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "BPAM_LAST_CREATED_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "SOURCE_KEY",
						"type": "nvarchar"
					},
					{
						"name": "DATA_HASH",
						"type": "varbinary"
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "POL_SUB_LOB"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/sourceStageDB')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_source_stage_txnBridge')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "sourceStageDB",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Source Stage"
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [
					{
						"name": "TX_BRIDGE_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "POLICY_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "POLICY_OVID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "TX_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "SECTION_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "SECTION_VID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "RISK_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "RISK_OVID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "CLASSIFICATION_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "CLASSIFICATION_OVID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "BATCH_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "UNIQUE_IDENTIFIER",
						"type": "nvarchar"
					},
					{
						"name": "DELETED_YN",
						"type": "nchar"
					},
					{
						"name": "BPAM_LAST_MODIFIED_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "BPAM_LAST_CREATED_DATE",
						"type": "datetime2",
						"scale": 7
					},
					{
						"name": "DATA_HASH",
						"type": "varbinary"
					},
					{
						"name": "SOURCE_KEY",
						"type": "nvarchar"
					},
					{
						"name": "COVERAGE_ID",
						"type": "bigint",
						"precision": 19
					},
					{
						"name": "COVERAGE_VID",
						"type": "bigint",
						"precision": 19
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "POL_TX_BRIDGE"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/sourceStageDB')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_stage_address')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_DM_Stage_Target",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Stage"
				},
				"annotations": [],
				"type": "AzurePostgreSqlTable",
				"schema": [
					{
						"name": "address_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "json_data",
						"type": "json",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "extendedattributes",
						"type": "json",
						"precision": 0,
						"scale": 0
					}
				],
				"typeProperties": {
					"schema": "public",
					"table": "address"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/ls_DM_Stage_Target')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_stage_agency')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_DM_Stage_Target",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Stage"
				},
				"annotations": [],
				"type": "AzurePostgreSqlTable",
				"schema": [
					{
						"name": "agency_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "json_data",
						"type": "jsonb",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "bpa_party_code",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "bpa_party_id",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "party_name",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					}
				],
				"typeProperties": {
					"schema": "public",
					"table": "agency"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/ls_DM_Stage_Target')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_stage_agent')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_DM_Stage_Target",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Stage"
				},
				"annotations": [],
				"type": "AzurePostgreSqlTable",
				"schema": [
					{
						"name": "agent_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "policy_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "party_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "party_role_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "json_data",
						"type": "json",
						"precision": 0,
						"scale": 0
					}
				],
				"typeProperties": {
					"schema": "public",
					"table": "agent"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/ls_DM_Stage_Target')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_stage_coverage')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_DM_Stage_Target",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Stage"
				},
				"annotations": [],
				"type": "AzurePostgreSqlTable",
				"schema": [
					{
						"name": "coverage_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "policy_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "json_data",
						"type": "json",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "coverage_code",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "risk_id",
						"type": "bigint",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "location_id",
						"type": "bigint",
						"precision": 0,
						"scale": 0
					}
				],
				"typeProperties": {
					"schema": "public",
					"table": "coverage"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/ls_DM_Stage_Target')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_stage_deductible')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_DM_Stage_Target",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Stage"
				},
				"annotations": [],
				"type": "AzurePostgreSqlTable",
				"schema": [
					{
						"name": "deductible_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "coverage_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "json_data",
						"type": "json",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "risk_id",
						"type": "bigint",
						"precision": 0,
						"scale": 0
					}
				],
				"typeProperties": {
					"schema": "public",
					"table": "deductible"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/ls_DM_Stage_Target')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_stage_horseBreed_lookup')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "AzureBlobStorage1",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Stage/lookup"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobStorageLocation",
						"fileName": "HorseBreed.csv",
						"container": "migration"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": [
					{
						"name": "Code",
						"type": "String"
					},
					{
						"name": "Description",
						"type": "String"
					},
					{
						"name": "SubCode",
						"type": "String"
					},
					{
						"name": "Order",
						"type": "String"
					},
					{
						"name": "ExtendedAttributes",
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzureBlobStorage1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_stage_horseDetailsLookup')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_DM_Stage_Target",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Stage"
				},
				"annotations": [],
				"type": "AzurePostgreSqlTable",
				"schema": [
					{
						"name": "lookup_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "bpa_code",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "bpa_code_desc",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					}
				],
				"typeProperties": {
					"schema": "public",
					"table": "bpa_horse_details_lookup"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/ls_DM_Stage_Target')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_stage_horseSex_lookup')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "AzureBlobStorage1",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Stage/lookup"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobStorageLocation",
						"fileName": "HorseGender.csv",
						"container": "migration"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": [
					{
						"name": "Code",
						"type": "String"
					},
					{
						"name": "Description",
						"type": "String"
					},
					{
						"name": "SubCode",
						"type": "String"
					},
					{
						"name": "Order",
						"type": "String"
					},
					{
						"name": "ExtendedAttributes",
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzureBlobStorage1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_stage_horseUse_lookup')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "AzureBlobStorage1",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Stage/lookup"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobStorageLocation",
						"fileName": "HorseUse.csv",
						"container": "migration"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": [
					{
						"name": "Code",
						"type": "String"
					},
					{
						"name": "Description",
						"type": "String"
					},
					{
						"name": "SubCode",
						"type": "String"
					},
					{
						"name": "Order",
						"type": "String"
					},
					{
						"name": "ExtendedAttributes",
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzureBlobStorage1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_stage_limit')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_DM_Stage_Target",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Stage"
				},
				"annotations": [],
				"type": "AzurePostgreSqlTable",
				"schema": [
					{
						"name": "limit_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "coverage_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "json_data",
						"type": "json",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "risk_id",
						"type": "bigint",
						"precision": 0,
						"scale": 0
					}
				],
				"typeProperties": {
					"schema": "public",
					"table": "cov_limit"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/ls_DM_Stage_Target')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_stage_location')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_DM_Stage_Target",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Stage"
				},
				"annotations": [],
				"type": "AzurePostgreSqlTable",
				"schema": [
					{
						"name": "location_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "policy_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "address_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "json_data",
						"type": "json",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "extendedattributes",
						"type": "json",
						"precision": 0,
						"scale": 0
					}
				],
				"typeProperties": {
					"schema": "public",
					"table": "location"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/ls_DM_Stage_Target')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_stage_party')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_DM_Stage_Target",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Stage"
				},
				"annotations": [],
				"type": "AzurePostgreSqlTable",
				"schema": [
					{
						"name": "party_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "party_code",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "parententityid",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "json_data",
						"type": "jsonb",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "bpa_party_code",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "bpa_party_id",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "party_name",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					}
				],
				"typeProperties": {
					"schema": "public",
					"table": "partyidentity"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/ls_DM_Stage_Target')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_stage_policy')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_DM_Stage_Target",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Stage"
				},
				"annotations": [],
				"type": "AzurePostgreSqlTable",
				"schema": [
					{
						"name": "policy_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "policy_number",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "json_data",
						"type": "json",
						"precision": 0,
						"scale": 0
					}
				],
				"typeProperties": {
					"schema": "public",
					"table": "policy"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/ls_DM_Stage_Target')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_stage_policytracker')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_DM_Stage_Target",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Stage"
				},
				"annotations": [],
				"type": "AzurePostgreSqlTable",
				"schema": [
					{
						"name": "policy_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "policy_number",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "bpa_tracking_number",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "bpa_tenant_id",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "bpa_username",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "status",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "created_at",
						"type": "timestamp with time zone",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "updated_at",
						"type": "timestamp with time zone",
						"precision": 0,
						"scale": 0
					}
				],
				"typeProperties": {
					"schema": "public",
					"table": "policy_tracker"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/ls_DM_Stage_Target')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_stage_risk')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_DM_Stage_Target",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Stage"
				},
				"annotations": [],
				"type": "AzurePostgreSqlTable",
				"schema": [
					{
						"name": "risk_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "policy_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "json_data",
						"type": "json",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "location_id",
						"type": "bigint",
						"precision": 0,
						"scale": 0
					}
				],
				"typeProperties": {
					"schema": "public",
					"table": "risk"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/ls_DM_Stage_Target')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_stage_riskDetail')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_DM_Stage_Target",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Stage"
				},
				"annotations": [],
				"type": "AzurePostgreSqlTable",
				"schema": [
					{
						"name": "risk_detail_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "risk_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "policy_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "json_data",
						"type": "json",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "extended_attributes",
						"type": "json",
						"precision": 0,
						"scale": 0
					}
				],
				"typeProperties": {
					"schema": "public",
					"table": "risk_detail"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/ls_DM_Stage_Target')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_targetSectionCopy')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_DM_Stage_Target",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "AzurePostgreSqlTable",
				"schema": [
					{
						"name": "insurableobject_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "limit_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "policy_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "coverage_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "json_data",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "location_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "extendedattributes",
						"type": "text",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "section_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "deductible_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "section_code",
						"type": "text",
						"precision": 0,
						"scale": 0
					}
				],
				"typeProperties": {
					"schema": "public",
					"table": "section_copy"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/ls_DM_Stage_Target')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_target_quoteInfo')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_DM_Stage_Target",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Stage"
				},
				"annotations": [],
				"type": "AzurePostgreSqlTable",
				"schema": [
					{
						"name": "policy_number",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "policy_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "policy_reference",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "quote_number",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "quote",
						"type": "jsonb",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "status",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "response",
						"type": "jsonb",
						"precision": 0,
						"scale": 0
					}
				],
				"typeProperties": {
					"schema": "public",
					"table": "quote_info"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/ls_DM_Stage_Target')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ds_target_rater_report')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_DM_Stage_Target",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Stage"
				},
				"annotations": [],
				"type": "AzurePostgreSqlTable",
				"schema": [
					{
						"name": "source_policy_number",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "stage_policy_number",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "target_policy_number",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "transaction_type",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "source_coverage_code",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "target_coverage_code",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "source_insurable_object",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "target_insurable_object",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "target_section",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "source_premium",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "target_premium",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "batch_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "bpa_tenant_id",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "product_code",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "created_at",
						"type": "timestamp with time zone",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "updated_at",
						"type": "timestamp with time zone",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "horse_breed",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "horse_sex",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "use",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "age_in_years",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "year_born",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "purchase_date",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "purchase_price",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "requested_limit",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "location_state",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "target_section_name",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "target_coverage_name",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "source_coverage_name",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					}
				],
				"typeProperties": {
					"schema": "public",
					"table": "rating_report"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/ls_DM_Stage_Target')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ecmPolicyJson')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ecmmigrationdb",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [
					{
						"name": "id",
						"type": "smallint",
						"precision": 5
					},
					{
						"name": "value",
						"type": "varchar"
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "BPA_policy_Json"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/ecmmigrationdb')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/insuredDetails')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ecmmigrationdb",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [
					{
						"name": "PolicyPrefix",
						"type": "char"
					},
					{
						"name": "Policy",
						"type": "varchar"
					},
					{
						"name": "Policy_Sequence",
						"type": "varchar"
					},
					{
						"name": "RowStatus",
						"type": "char"
					},
					{
						"name": "EffectiveDate",
						"type": "datetime",
						"precision": 23,
						"scale": 3
					},
					{
						"name": "ExpirationDate",
						"type": "datetime",
						"precision": 23,
						"scale": 3
					},
					{
						"name": "LocationNumber",
						"type": "varchar"
					},
					{
						"name": "LocationUnitNumber",
						"type": "varchar"
					},
					{
						"name": "InsuredNumber",
						"type": "smallint",
						"precision": 5
					},
					{
						"name": "InsuredType",
						"type": "char"
					},
					{
						"name": "InsuredSubType",
						"type": "char"
					},
					{
						"name": "LinkToApplicant",
						"type": "varchar"
					},
					{
						"name": "FirstName",
						"type": "varchar"
					},
					{
						"name": "MiddleName",
						"type": "varchar"
					},
					{
						"name": "LastName",
						"type": "varchar"
					},
					{
						"name": "NameSuffix",
						"type": "varchar"
					},
					{
						"name": "CorporateName",
						"type": "varchar"
					},
					{
						"name": "DBACode",
						"type": "char"
					},
					{
						"name": "AlternateName",
						"type": "varchar"
					},
					{
						"name": "MailingAddress1",
						"type": "varchar"
					},
					{
						"name": "MailingAddress2",
						"type": "varchar"
					},
					{
						"name": "MailingCity",
						"type": "varchar"
					},
					{
						"name": "MailingState",
						"type": "varchar"
					},
					{
						"name": "MailingZipCode",
						"type": "varchar"
					},
					{
						"name": "MailingCountryCode",
						"type": "char"
					},
					{
						"name": "DOB",
						"type": "date"
					},
					{
						"name": "Relationship",
						"type": "char"
					},
					{
						"name": "ExcludedDate",
						"type": "date"
					},
					{
						"name": "ActiveMilitary",
						"type": "char"
					},
					{
						"name": "SubTypeOther",
						"type": "varchar"
					},
					{
						"name": "ID",
						"type": "int",
						"precision": 10
					},
					{
						"name": "DataSource",
						"type": "char"
					},
					{
						"name": "DW_InsertDate",
						"type": "date"
					}
				],
				"typeProperties": {
					"schema": "dbo",
					"table": "PolicyInsuredInfo_P"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/ecmmigrationdb')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/joinTablePostgres')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_DM_Stage_Target",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "AzurePostgreSqlTable",
				"schema": [],
				"typeProperties": {}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/ls_DM_Stage_Target')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/joinTableSourceSQL')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ecmmigrationdb",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [],
				"typeProperties": {}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/ecmmigrationdb')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/joinTableStageSQL')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "sourceStageDB",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [],
				"typeProperties": {}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/sourceStageDB')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/lookup')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "sourceStageDB",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [],
				"typeProperties": {
					"schema": "dbo",
					"table": "TestExcel"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/sourceStageDB')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/policyJson')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "AzureBlobStorage1",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "Json",
				"typeProperties": {
					"location": {
						"type": "AzureBlobStorageLocation",
						"fileName": "equine.json",
						"container": "migration"
					}
				},
				"schema": {
					"type": "object",
					"properties": {
						"messageInformation": {
							"type": "object",
							"properties": {
								"businessPurposeTypeCode": {
									"type": "string"
								},
								"trackingNumber": {
									"type": "string"
								},
								"messageStatus": {
									"type": "object",
									"properties": {
										"statusCode": {
											"type": "integer"
										},
										"statusDescription": {
											"type": "string"
										},
										"successStatusCode": {
											"type": "string"
										}
									}
								},
								"userInfo": {
									"type": "object",
									"properties": {
										"userName": {
											"type": "string"
										}
									}
								},
								"userJourneyType": {
									"type": "string"
								}
							}
						},
						"policy": {
							"type": "object",
							"properties": {
								"companyProductCode": {
									"type": "string"
								},
								"lineofBusinessCode": {
									"type": "string"
								},
								"effectiveDate": {
									"type": "string"
								},
								"expirationDate": {
									"type": "string"
								},
								"ratedPremium": {
									"type": "null"
								},
								"quotedPremium": {
									"type": "null"
								},
								"premiumDueDate": {
									"type": "string"
								},
								"amountItem": {
									"type": "array"
								},
								"tax": {
									"type": "array"
								},
								"policyTerm": {
									"type": "string"
								},
								"operatingCompanyCode": {
									"type": "string"
								},
								"agent": {
									"type": "object",
									"properties": {
										"party": {
											"type": "object",
											"properties": {
												"partyCode": {
													"type": "string"
												},
												"partyTypeCode": {
													"type": "string"
												},
												"id": {
													"type": "string"
												},
												"name": {
													"type": "object",
													"properties": {
														"fullName": {
															"type": "string"
														},
														"titlePrefix": {
															"type": "string"
														},
														"givenName": {
															"type": "string"
														},
														"surname": {
															"type": "string"
														},
														"parentEntityId": {
															"type": "string"
														},
														"parentEntityTypeName": {
															"type": "string"
														},
														"sequenceNumber": {
															"type": "integer"
														}
													}
												},
												"partyStatus": {
													"type": "string"
												},
												"sicCode": {
													"type": "array"
												},
												"naicCode": {
													"type": "array"
												},
												"modifiedComments": {
													"type": "string"
												},
												"person": {
													"type": "object",
													"properties": {
														"id": {
															"type": "string"
														},
														"citizenshipCode": {
															"type": "array"
														},
														"languageCode": {
															"type": "array",
															"items": {
																"type": "string"
															}
														}
													}
												},
												"partyRole": {
													"type": "array",
													"items": {
														"type": "object",
														"properties": {
															"id": {
																"type": "string"
															},
															"parentEntityId": {
																"type": "string"
															},
															"parentEntityTypeName": {
																"type": "string"
															},
															"effectiveDate": {
																"type": "string"
															},
															"roleType": {
																"type": "string"
															},
															"roleCode": {
																"type": "string"
															},
															"name": {
																"type": "object",
																"properties": {
																	"fullName": {
																		"type": "string"
																	},
																	"id": {
																		"type": "string"
																	},
																	"parentEntityId": {
																		"type": "string"
																	},
																	"parentEntityTypeName": {
																		"type": "string"
																	},
																	"sequenceNumber": {
																		"type": "integer"
																	}
																}
															},
															"communication": {
																"type": "array"
															}
														}
													}
												},
												"languageCode": {
													"type": "array",
													"items": {
														"type": "string"
													}
												},
												"address": {
													"type": "array"
												},
												"communication": {
													"type": "array"
												},
												"partyAdditionalDetails": {
													"type": "object",
													"properties": {
														"id": {
															"type": "string"
														},
														"partyId": {
															"type": "string"
														}
													}
												},
												"partyRelationships": {
													"type": "array",
													"items": {
														"type": "object",
														"properties": {
															"id": {
																"type": "string"
															},
															"partyCode": {
																"type": "string"
															},
															"relatedPartyCode": {
																"type": "string"
															},
															"partyName": {
																"type": "string"
															},
															"relatedPartyName": {
																"type": "string"
															},
															"relationshipTypeCode": {
																"type": "string"
															},
															"relationshipType": {
																"type": "string"
															},
															"beginDate": {
																"type": "string"
															}
														}
													}
												}
											}
										},
										"id": {
											"type": "string"
										},
										"typeCode": {
											"type": "string"
										},
										"number": {
											"type": "integer"
										},
										"parentEntityId": {
											"type": "string"
										},
										"parentEntityTypeName": {
											"type": "string"
										},
										"partyName": {
											"type": "string"
										},
										"isCancelled": {
											"type": "boolean"
										},
										"partyCode": {
											"type": "string"
										},
										"maintenanceAgency": {
											"type": "string"
										},
										"agencyCode": {
											"type": "string"
										},
										"partyIdentifiers": {
											"type": "array"
										}
									}
								},
								"coverage": {
									"type": "array"
								},
								"coverageGroup": {
									"type": "array"
								},
								"clientParticipant": {
									"type": "array",
									"items": {
										"type": "object",
										"properties": {
											"roleCode": {
												"type": "string"
											},
											"partyCode": {
												"type": "string"
											},
											"partyName": {
												"type": "string"
											},
											"questionAnswer": {
												"type": "array"
											},
											"effectiveDate": {
												"type": "string"
											},
											"expirationDate": {
												"type": "string"
											},
											"isCancelled": {
												"type": "boolean"
											},
											"subRoleCode": {
												"type": "string"
											},
											"professionalRole": {
												"type": "string"
											},
											"originalPartyName": {
												"type": "string"
											},
											"extendedAttributes": {
												"type": "array"
											},
											"party": {
												"type": "object",
												"properties": {
													"partyCode": {
														"type": "string"
													},
													"partyTypeCode": {
														"type": "string"
													},
													"name": {
														"type": "object",
														"properties": {
															"fullName": {
																"type": "string"
															},
															"givenName": {
																"type": "string"
															},
															"surname": {
																"type": "string"
															},
															"parentEntityTypeName": {
																"type": "string"
															},
															"sequenceNumber": {
																"type": "integer"
															}
														}
													},
													"partyStatus": {
														"type": "string"
													},
													"sicCode": {
														"type": "array"
													},
													"naicCode": {
														"type": "array"
													},
													"modifiedComments": {
														"type": "string"
													},
													"person": {
														"type": "object",
														"properties": {
															"genderCode": {
																"type": "string"
															},
															"citizenshipCode": {
																"type": "array"
															},
															"languageCode": {
																"type": "array"
															}
														}
													},
													"partyRole": {
														"type": "array",
														"items": {
															"type": "object",
															"properties": {
																"parentEntityTypeName": {
																	"type": "string"
																},
																"effectiveDate": {
																	"type": "string"
																},
																"roleType": {
																	"type": "string"
																},
																"roleCode": {
																	"type": "string"
																},
																"name": {
																	"type": "object",
																	"properties": {
																		"fullName": {
																			"type": "string"
																		},
																		"parentEntityTypeName": {
																			"type": "string"
																		},
																		"sequenceNumber": {
																			"type": "integer"
																		}
																	}
																},
																"communication": {
																	"type": "array"
																}
															}
														}
													},
													"partyIdentity": {
														"type": "array",
														"items": {
															"type": "object",
															"properties": {
																"id": {
																	"type": "string"
																},
																"parentEntityId": {
																	"type": "string"
																},
																"parentEntityTypeName": {
																	"type": "string"
																},
																"typeCode": {
																	"type": "string"
																},
																"value": {
																	"type": "string"
																}
															}
														}
													},
													"languageCode": {
														"type": "array"
													},
													"address": {
														"type": "array",
														"items": {
															"type": "object",
															"properties": {
																"line1": {
																	"type": "string"
																},
																"city": {
																	"type": "string"
																},
																"stateOrProvinceName": {
																	"type": "string"
																},
																"stateOrProvinceCode": {
																	"type": "string"
																},
																"postalCode": {
																	"type": "string"
																},
																"countryName": {
																	"type": "string"
																},
																"countryCode": {
																	"type": "string"
																},
																"isPrimaryAddress": {
																	"type": "boolean"
																},
																"typeCode": {
																	"type": "string"
																}
															}
														}
													},
													"communication": {
														"type": "array"
													},
													"partySanctionChecks": {
														"type": "array",
														"items": {
															"type": "object",
															"properties": {
																"sanctionCheckDate": {
																	"type": "string"
																},
																"sanctionCheckStatus": {
																	"type": "string"
																},
																"sanctionCheckReferenceId": {
																	"type": "string"
																},
																"sanctionCheckValidUptoDate": {
																	"type": "string"
																}
															}
														}
													},
													"partyRelationships": {
														"type": "array"
													}
												}
											}
										}
									}
								},
								"mgaParticipant": {
									"type": "array"
								},
								"section": {
									"type": "array",
									"items": {
										"type": "object",
										"properties": {
											"lineOfBusinessCode": {
												"type": "string"
											},
											"sequenceNumber": {
												"type": "integer"
											},
											"declinedIndicator": {
												"type": "boolean"
											},
											"coverTypeCode": {
												"type": "string"
											},
											"underwritingYear": {
												"type": "integer"
											},
											"coverage": {
												"type": "array",
												"items": {
													"type": "object",
													"properties": {
														"coverageInfo": {
															"type": "object",
															"properties": {
																"code": {
																	"type": "string"
																},
																"displayName": {
																	"type": "string"
																},
																"coverageType": {
																	"type": "string"
																},
																"limit": {
																	"type": "array",
																	"items": {
																		"type": "object",
																		"properties": {
																			"typeCode": {
																				"type": "string"
																			},
																			"min": {
																				"type": "integer"
																			},
																			"max": {
																				"type": "integer"
																			},
																			"valueType": {
																				"type": "string"
																			},
																			"inputType": {
																				"type": "string"
																			},
																			"name": {
																				"type": "string"
																			}
																		}
																	}
																},
																"level": {
																	"type": "string"
																},
																"isMandatory": {
																	"type": "boolean"
																}
															}
														},
														"typeCode": {
															"type": "string"
														},
														"sequenceNumber": {
															"type": "integer"
														},
														"fullPremium": {
															"type": "string"
														},
														"effectiveDate": {
															"type": "string"
														},
														"expirationDate": {
															"type": "string"
														},
														"limit": {
															"type": "array"
														},
														"deductible": {
															"type": "array"
														},
														"option": {
															"type": "array"
														},
														"isCancelled": {
															"type": "boolean"
														},
														"tax": {
															"type": "array"
														},
														"amountItem": {
															"type": "array"
														},
														"extendedAttributes": {
															"type": "array"
														},
														"appliesToLevel": {
															"type": "string"
														}
													}
												}
											},
											"subjectivity": {
												"type": "array"
											},
											"tax": {
												"type": "array"
											},
											"sectionItem": {
												"type": "array"
											},
											"location": {
												"type": "array",
												"items": {
													"type": "object",
													"properties": {
														"address": {
															"type": "object",
															"properties": {
																"stateOrProvinceCode": {
																	"type": "string"
																},
																"isPrimaryAddress": {
																	"type": "boolean"
																}
															}
														},
														"typeCode": {
															"type": "string"
														},
														"earthquakeZone": {
															"type": "boolean"
														},
														"effectiveDate": {
															"type": "string"
														},
														"expirationDate": {
															"type": "string"
														},
														"isCancelled": {
															"type": "boolean"
														},
														"tax": {
															"type": "array"
														},
														"amountItem": {
															"type": "array"
														},
														"extendedAttributes": {
															"type": "array"
														},
														"insurableObject": {
															"type": "array"
														},
														"businessKey": {
															"type": "string"
														}
													}
												}
											},
											"coverageGroup": {
												"type": "array"
											},
											"effectiveDate": {
												"type": "string"
											},
											"expirationDate": {
												"type": "string"
											},
											"isCancelled": {
												"type": "boolean"
											},
											"triaRate": {
												"type": "integer"
											},
											"amountItem": {
												"type": "array"
											},
											"extendedAttributes": {
												"type": "array"
											},
											"insurableObject": {
												"type": "array",
												"items": {
													"type": "object",
													"properties": {
														"businessKey": {
															"type": "string"
														},
														"typeCode": {
															"type": "string"
														},
														"sequenceNumber": {
															"type": "integer"
														},
														"extendedAttributes": {
															"type": "array",
															"items": {
																"type": "object",
																"properties": {
																	"name": {
																		"type": "string"
																	},
																	"value": {
																		"type": "string"
																	}
																}
															}
														},
														"appliesToLevel": {
															"type": "string"
														},
														"appliesToCode": {
															"type": "string"
														},
														"isCancelled": {
															"type": "boolean"
														},
														"isDeletedOnMta": {
															"type": "boolean"
														}
													}
												}
											},
											"taxesLicensesFees": {
												"type": "number"
											},
											"commission": {
												"type": "integer"
											},
											"profitProvision": {
												"type": "number"
											},
											"carrierParticipant": {
												"type": "array"
											},
											"pricedIndicator": {
												"type": "boolean"
											},
											"isSharedCarrier": {
												"type": "boolean"
											},
											"mappedLocations": {
												"type": "array"
											},
											"insurableObjectParticipant": {
												"type": "array"
											},
											"taxJurisdiction": {
												"type": "array"
											}
										}
									}
								},
								"location": {
									"type": "array"
								},
								"productVersion": {
									"type": "string"
								},
								"claim": {
									"type": "array"
								},
								"paymentInfo": {
									"type": "object",
									"properties": {
										"parentEntityTypeName": {
											"type": "string"
										},
										"billingType": {
											"type": "string"
										},
										"paymentPlan": {
											"type": "string"
										}
									}
								},
								"underwriterDecisionInfo": {
									"type": "array"
								},
								"minorVersion": {
									"type": "integer"
								},
								"majorVersion": {
									"type": "integer"
								},
								"businessPurposeTypeCode": {
									"type": "string"
								},
								"businessPurposeType": {
									"type": "string"
								},
								"statusCodeDisplayName": {
									"type": "string"
								},
								"reasons": {
									"type": "array"
								},
								"policyExpirationDate": {
									"type": "string"
								},
								"policyEffectiveDate": {
									"type": "string"
								},
								"agency": {
									"type": "object",
									"properties": {
										"partyCode": {
											"type": "string"
										},
										"partyTypeCode": {
											"type": "string"
										},
										"name": {
											"type": "object",
											"properties": {
												"fullName": {
													"type": "string"
												},
												"parentEntityTypeName": {
													"type": "string"
												},
												"sequenceNumber": {
													"type": "integer"
												}
											}
										},
										"partyStatus": {
											"type": "string"
										},
										"sicCode": {
											"type": "array"
										},
										"naicCode": {
											"type": "array"
										},
										"modifiedComments": {
											"type": "string"
										},
										"organization": {
											"type": "object",
											"properties": {
												"memberCount": {
													"type": "integer"
												},
												"fullName": {
													"type": "string"
												},
												"languageCode": {
													"type": "array",
													"items": {
														"type": "string"
													}
												}
											}
										},
										"partyRole": {
											"type": "array",
											"items": {
												"type": "object",
												"properties": {
													"effectiveDate": {
														"type": "string"
													},
													"roleType": {
														"type": "string"
													},
													"roleCode": {
														"type": "string"
													},
													"agencyType": {
														"type": "string"
													},
													"tier": {
														"type": "string"
													},
													"name": {
														"type": "object",
														"properties": {
															"fullName": {
																"type": "string"
															},
															"sequenceNumber": {
																"type": "integer"
															}
														}
													},
													"communication": {
														"type": "array"
													}
												}
											}
										},
										"languageCode": {
											"type": "array",
											"items": {
												"type": "string"
											}
										},
										"address": {
											"type": "array"
										},
										"communication": {
											"type": "array",
											"items": {
												"type": "object",
												"properties": {
													"id": {
														"type": "string"
													},
													"parentEntityTypeName": {
														"type": "string"
													},
													"parentEntityId": {
														"type": "string"
													},
													"phoneTypeCode": {
														"type": "string"
													},
													"phoneNumber": {
														"type": "string"
													},
													"emailAddress": {
														"type": "string"
													},
													"doNotContactIndicator": {
														"type": "boolean"
													}
												}
											}
										},
										"partyAdditionalDetails": {
											"type": "object",
											"properties": {
												"id": {
													"type": "string"
												},
												"partyId": {
													"type": "string"
												}
											}
										},
										"partyRelationships": {
											"type": "array",
											"items": {
												"type": "object",
												"properties": {
													"id": {
														"type": "string"
													},
													"partyCode": {
														"type": "string"
													},
													"relatedPartyCode": {
														"type": "string"
													},
													"partyName": {
														"type": "string"
													},
													"relatedPartyName": {
														"type": "string"
													},
													"relationshipTypeCode": {
														"type": "string"
													},
													"relationshipType": {
														"type": "string"
													},
													"beginDate": {
														"type": "string"
													}
												}
											}
										}
									}
								},
								"carrierProcessingType": {
									"type": "string"
								},
								"endorsement": {
									"type": "array"
								},
								"certificateNumber": {
									"type": "string"
								},
								"currencyCode": {
									"type": "string"
								},
								"productTimeZone": {
									"type": "string"
								},
								"priorPolicy": {
									"type": "array"
								},
								"sanctionCheckInfo": {
									"type": "array"
								},
								"underlyingPolicies": {
									"type": "array"
								},
								"forms": {
									"type": "array"
								},
								"masterContractIndicator": {
									"type": "boolean"
								},
								"originalBusinessPurposeTypeCode": {
									"type": "string"
								},
								"originalBusinessPurposeType": {
									"type": "string"
								},
								"sectionWiseLocationAllocation": {
									"type": "boolean"
								}
							}
						}
					}
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzureBlobStorage1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/rater_report')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "AzureBlobStorage1",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobStorageLocation",
						"container": "migration"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": [
					{
						"name": "Code",
						"type": "String"
					},
					{
						"name": "Description",
						"type": "String"
					},
					{
						"name": "SubCode",
						"type": "String"
					},
					{
						"name": "Order",
						"type": "String"
					},
					{
						"name": "ExtendedAttributes",
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzureBlobStorage1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/targetSection')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_DM_Stage_Target",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "AzurePostgreSqlTable",
				"schema": [
					{
						"name": "section_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "policy_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "coverage_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "location_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "limit_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "deductible_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "insurableobject_id",
						"type": "integer",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "json_data",
						"type": "jsonb",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "extendedattributes",
						"type": "json",
						"precision": 0,
						"scale": 0
					},
					{
						"name": "section_code",
						"type": "character varying",
						"precision": 0,
						"scale": 0
					}
				],
				"typeProperties": {
					"schema": "public",
					"table": "bpa_section"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/ls_DM_Stage_Target')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/AzureBlobStorage1')]",
			"type": "Microsoft.DataFactory/factories/linkedServices",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"type": "AzureBlobStorage",
				"typeProperties": {
					"connectionString": "[parameters('AzureBlobStorage1_connectionString')]"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/RestService1')]",
			"type": "Microsoft.DataFactory/factories/linkedServices",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"type": "RestService",
				"typeProperties": {
					"url": "[parameters('RestService1_properties_typeProperties_url')]",
					"enableServerCertificateValidation": true,
					"authenticationType": "OAuth2ClientCredential",
					"clientId": "[parameters('RestService1_properties_typeProperties_clientId')]",
					"clientSecret": {
						"type": "SecureString",
						"value": "[parameters('RestService1_clientSecret')]"
					},
					"tokenEndpoint": "https://bpa-dev.chainthat.net/auth/realms/ecm/protocol/openid-connect/token"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/RestService2')]",
			"type": "Microsoft.DataFactory/factories/linkedServices",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"type": "RestService",
				"typeProperties": {
					"url": "[parameters('RestService2_properties_typeProperties_url')]",
					"enableServerCertificateValidation": true,
					"authenticationType": "OAuth2ClientCredential",
					"clientId": "[parameters('RestService2_properties_typeProperties_clientId')]",
					"clientSecret": {
						"type": "SecureString",
						"value": "[parameters('RestService2_clientSecret')]"
					},
					"tokenEndpoint": "https://bpa-ecm-migration.chainthat.net/auth/realms/ecm/protocol/openid-connect/token"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/ecmmigrationdb')]",
			"type": "Microsoft.DataFactory/factories/linkedServices",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"type": "SqlServer",
				"typeProperties": {
					"connectionString": "[parameters('ecmmigrationdb_connectionString')]"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/ls_DM_Stage_Target')]",
			"type": "Microsoft.DataFactory/factories/linkedServices",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"type": "AzurePostgreSql",
				"typeProperties": {
					"connectionString": "[parameters('ls_DM_Stage_Target_connectionString')]"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/postgresTest')]",
			"type": "Microsoft.DataFactory/factories/linkedServices",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"type": "AzurePostgreSql",
				"typeProperties": {
					"connectionString": "[parameters('postgresTest_connectionString')]"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/sampleLogin')]",
			"type": "Microsoft.DataFactory/factories/linkedServices",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"type": "RestService",
				"typeProperties": {
					"url": "[parameters('sampleLogin_properties_typeProperties_url')]",
					"enableServerCertificateValidation": true,
					"authenticationType": "Anonymous"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/sourceStageDB')]",
			"type": "Microsoft.DataFactory/factories/linkedServices",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"type": "SqlServer",
				"typeProperties": {
					"connectionString": "[parameters('sourceStageDB_connectionString')]"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/ssSqlServer')]",
			"type": "Microsoft.DataFactory/factories/linkedServices",
			"apiVersion": "2018-06-01",
			"properties": {
				"parameters": {
					"dbUrl": {
						"type": "string",
						"defaultValue": "20.84.69.215"
					},
					"dbName": {
						"type": "string",
						"defaultValue": "DM_Source_Stage"
					},
					"dbUsername": {
						"type": "string",
						"defaultValue": "db_admin"
					},
					"dbPassword": {
						"type": "string",
						"defaultValue": "ProVT#2D1!@C"
					}
				},
				"annotations": [],
				"type": "SqlServer",
				"typeProperties": {
					"connectionString": "[parameters('ssSqlServer_connectionString')]"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/submitService')]",
			"type": "Microsoft.DataFactory/factories/linkedServices",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"type": "RestService",
				"typeProperties": {
					"url": "[parameters('submitService_properties_typeProperties_url')]",
					"enableServerCertificateValidation": true,
					"authenticationType": "OAuth2ClientCredential",
					"clientId": "[parameters('submitService_properties_typeProperties_clientId')]",
					"clientSecret": {
						"type": "SecureString",
						"value": "[parameters('submitService_clientSecret')]"
					},
					"tokenEndpoint": "https://bpa-tst.chainthat.net/auth/realms/ecm/protocol/openid-connect/token"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/integrationRuntime1')]",
			"type": "Microsoft.DataFactory/factories/integrationRuntimes",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "Managed",
				"typeProperties": {
					"computeProperties": {
						"location": "AutoResolve",
						"dataFlowProperties": {
							"computeType": "General",
							"coreCount": 8,
							"timeToLive": 10,
							"cleanup": false,
							"customProperties": []
						}
					}
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/integrationRuntime2-selfhosted')]",
			"type": "Microsoft.DataFactory/factories/integrationRuntimes",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "Managed",
				"typeProperties": {
					"computeProperties": {
						"location": "East US",
						"dataFlowProperties": {
							"computeType": "General",
							"coreCount": 16,
							"timeToLive": 10,
							"cleanup": false,
							"customProperties": []
						},
						"pipelineExternalComputeScaleProperties": {
							"timeToLive": 60,
							"numberOfPipelineNodes": 1,
							"numberOfExternalNodes": 1
						}
					}
				},
				"managedVirtualNetwork": {
					"type": "ManagedVirtualNetworkReference",
					"referenceName": "default"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/managedVirtualNetworks/default')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_CFA_coverages_meta')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Target Stage Data Flows/cfa"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "dsCFA",
								"type": "DatasetReference"
							},
							"name": "source1"
						},
						{
							"dataset": {
								"referenceName": "ECMBPA_COV_MAP",
								"type": "DatasetReference"
							},
							"name": "source2"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ECMBPA_COV_MAP",
								"type": "DatasetReference"
							},
							"name": "sink1"
						},
						{
							"name": "sink2"
						}
					],
					"transformations": [
						{
							"name": "derivedColumn1"
						},
						{
							"name": "surrogateKey1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          SI_NO as string,",
						"          id as string,",
						"          COVERAGE_CODE as string,",
						"          COV_SEQ as string,",
						"          COVERAGE_CODE_DES as string,",
						"          COVERAGES as string,",
						"          BPA_COVERAGE_CODES as string,",
						"          BPA_SECTION_CODE as string,",
						"          BPA_SEC_NAME as string,",
						"          BPA_COVERAGES as string,",
						"          {BPA Coverage Groups} as string,",
						"          {BPA Coverage Type} as string,",
						"          BPA_PRODUCT_CODE as string,",
						"          SOURCE_PRODUCT_CODE as string,",
						"          coverage_level as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> source1",
						"source(output(",
						"          id as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select coalesce(MAX(id),0) as id from public.ecm_bpa_cov_mapping',",
						"     format: 'query') ~> source2",
						"surrogateKey1 derive(id = sink2#outputs()[1].id+pkey,",
						"          SI_NO = sink2#outputs()[1].id+pkey,",
						"          bpa_coverage_type = {BPA Coverage Type},",
						"          bpa_coverage_group = {BPA Coverage Groups},",
						"          bpa_coverage_level = coverage_level) ~> derivedColumn1",
						"source1 keyGenerate(output(pkey as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> surrogateKey1",
						"derivedColumn1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          COV_SEQ as string,",
						"          BPA_SECTION_CODE as string,",
						"          COVERAGE_CODE as string,",
						"          COVERAGE_CODE_DES as string,",
						"          BPA_COVERAGE_CODES as string,",
						"          BPA_COVERAGES as string,",
						"          COVERAGES as string,",
						"          BPA_PRODUCT_CODE as string,",
						"          SI_NO as string,",
						"          id as long,",
						"          BPA_SEC_NAME as string,",
						"          SOURCE_PRODUCT_CODE as string,",
						"          bpa_coverage_group as string,",
						"          bpa_coverage_level as string,",
						"          bpa_coverage_type as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink1",
						"source2 sink(validateSchema: false,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     store: 'cache',",
						"     format: 'inline',",
						"     output: false,",
						"     saveOrder: 1) ~> sink2"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/dsCFA')]",
				"[concat(variables('factoryId'), '/datasets/ECMBPA_COV_MAP')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_addDeductible_to_policy_level_coverage')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Target Stage Data Flows/deductibles"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_stage_coverage",
								"type": "DatasetReference"
							},
							"name": "targetCoverage"
						},
						{
							"dataset": {
								"referenceName": "ds_stage_deductible",
								"type": "DatasetReference"
							},
							"name": "osDeductibleLimit"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_stage_coverage",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "join1"
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "derivedColumn2"
						},
						{
							"name": "AlterRow1"
						},
						{
							"name": "filter1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          coverage_id as integer,",
						"          policy_id as integer,",
						"          json_data as string,",
						"          coverage_code as string,",
						"          risk_id as long,",
						"          location_id as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select * from coverage where risk_id is null\\n',",
						"     format: 'query') ~> targetCoverage",
						"source(output(",
						"          deductible_id as integer,",
						"          coverage_id as integer,",
						"          json_data as string,",
						"          risk_id as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> osDeductibleLimit",
						"filter1, derivedColumn1 join(targetCoverage@coverage_id == osDeductibleLimit@coverage_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"osDeductibleLimit derive(deductibleJson = json_data) ~> derivedColumn1",
						"join1 derive(json_data = replace(targetCoverage@json_data, '\"deductible\":[]',concat( '\"deductible\":', deductibleJson))) ~> derivedColumn2",
						"derivedColumn2 alterRow(updateIf(!isNull(targetCoverage@coverage_id))) ~> AlterRow1",
						"targetCoverage filter(isNull (risk_id)) ~> filter1",
						"AlterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          coverage_id as integer,",
						"          policy_id as integer,",
						"          json_data as string,",
						"          coverage_code as string,",
						"          risk_id as long,",
						"          location_id as long",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['policy_id','coverage_id'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink1"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ds_stage_coverage')]",
				"[concat(variables('factoryId'), '/datasets/ds_stage_deductible')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_addDeductible_to_risk_level_coverage')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Target Stage Data Flows/deductibles"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_stage_coverage",
								"type": "DatasetReference"
							},
							"name": "targetCoverage"
						},
						{
							"dataset": {
								"referenceName": "ds_stage_deductible",
								"type": "DatasetReference"
							},
							"name": "osTargetDeductible"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_stage_coverage",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "join1"
						},
						{
							"name": "derivedColumn2"
						},
						{
							"name": "AlterRow1"
						},
						{
							"name": "updatedDeductiblejson"
						},
						{
							"name": "filter1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          coverage_id as integer,",
						"          policy_id as integer,",
						"          json_data as string,",
						"          coverage_code as string,",
						"          risk_id as long,",
						"          location_id as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> targetCoverage",
						"source(output(",
						"          deductible_id as integer,",
						"          coverage_id as integer,",
						"          json_data as string,",
						"          risk_id as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> osTargetDeductible",
						"filter1, updatedDeductiblejson join(targetCoverage@coverage_id == osTargetDeductible@coverage_id",
						"     && targetCoverage@risk_id == osTargetDeductible@risk_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"join1 derive(json_data = replace(targetCoverage@json_data, '\"deductible\":[]',concat( '\"deductible\":', deductibleJson))) ~> derivedColumn2",
						"derivedColumn2 alterRow(updateIf(!isNull(targetCoverage@coverage_id))) ~> AlterRow1",
						"osTargetDeductible derive(deductibleJson = json_data) ~> updatedDeductiblejson",
						"targetCoverage filter(!isNull (risk_id)) ~> filter1",
						"AlterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          coverage_id as integer,",
						"          policy_id as integer,",
						"          json_data as string,",
						"          coverage_code as string,",
						"          risk_id as long,",
						"          location_id as long",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['policy_id','coverage_id','risk_id'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink1"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ds_stage_coverage')]",
				"[concat(variables('factoryId'), '/datasets/ds_stage_deductible')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_addLimit_to_policy_level_coverage')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Target Stage Data Flows/limits"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_stage_coverage",
								"type": "DatasetReference"
							},
							"name": "targetCoverage"
						},
						{
							"dataset": {
								"referenceName": "ds_stage_limit",
								"type": "DatasetReference"
							},
							"name": "osTargeLimit"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_stage_coverage",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "join1"
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "derivedColumn2"
						},
						{
							"name": "AlterRow1"
						},
						{
							"name": "filter1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          coverage_id as integer,",
						"          policy_id as integer,",
						"          json_data as string,",
						"          coverage_code as string,",
						"          risk_id as long,",
						"          location_id as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select * from coverage where risk_id is null\\n',",
						"     format: 'query') ~> targetCoverage",
						"source(output(",
						"          limit_id as integer,",
						"          coverage_id as integer,",
						"          json_data as string,",
						"          risk_id as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> osTargeLimit",
						"filter1, derivedColumn1 join(targetCoverage@coverage_id == osTargeLimit@coverage_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"osTargeLimit derive(limitJson = json_data) ~> derivedColumn1",
						"join1 derive(json_data = replace(targetCoverage@json_data, '\"limit\":[]',concat( '\"limit\":', limitJson))) ~> derivedColumn2",
						"derivedColumn2 alterRow(updateIf(!isNull(targetCoverage@coverage_id))) ~> AlterRow1",
						"targetCoverage filter(isNull (risk_id)) ~> filter1",
						"AlterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          coverage_id as integer,",
						"          policy_id as integer,",
						"          json_data as string,",
						"          coverage_code as string,",
						"          risk_id as long,",
						"          location_id as long",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['policy_id','coverage_id'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink1"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ds_stage_coverage')]",
				"[concat(variables('factoryId'), '/datasets/ds_stage_limit')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_addLimit_to_risk_level_coverage')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Target Stage Data Flows/limits"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_stage_coverage",
								"type": "DatasetReference"
							},
							"name": "targetCoverage"
						},
						{
							"dataset": {
								"referenceName": "ds_stage_limit",
								"type": "DatasetReference"
							},
							"name": "osTargeLimit"
						},
						{
							"dataset": {
								"referenceName": "ds_stage_deductible",
								"type": "DatasetReference"
							},
							"name": "osTargetDeductible"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_stage_coverage",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "join1"
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "derivedColumn2"
						},
						{
							"name": "AlterRow1"
						},
						{
							"name": "updatedDeductiblejson"
						},
						{
							"name": "filter1"
						},
						{
							"name": "derivedColumn3"
						},
						{
							"name": "filter2"
						}
					],
					"scriptLines": [
						"parameters{",
						"     policyPrefix as string ('CFA')",
						"}",
						"source(output(",
						"          coverage_id as integer,",
						"          policy_id as integer,",
						"          json_data as string,",
						"          coverage_code as string,",
						"          risk_id as long,",
						"          location_id as long,",
						"          policy_number as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select cov.coverage_id     ,cov.policy_id     ,cov.json_data,     cov.coverage_code,     cov.risk_id,cov.location_id,p.policy_number\\n from coverage cov join policy p on cov.policy_id = p.policy_id ',",
						"     format: 'query') ~> targetCoverage",
						"source(output(",
						"          limit_id as integer,",
						"          coverage_id as integer,",
						"          json_data as string,",
						"          risk_id as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select * from cov_limit',",
						"     format: 'query') ~> osTargeLimit",
						"source(output(",
						"          deductible_id as integer,",
						"          coverage_id as integer,",
						"          json_data as string,",
						"          risk_id as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> osTargetDeductible",
						"filter1, derivedColumn1 join(targetCoverage@coverage_id == osTargeLimit@coverage_id",
						"     && targetCoverage@risk_id == osTargeLimit@risk_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"osTargeLimit derive(limitJson = json_data) ~> derivedColumn1",
						"join1 derive(json_data = replace(targetCoverage@json_data, '\"limit\":[]',concat( '\"limit\":', limitJson))) ~> derivedColumn2",
						"derivedColumn2 alterRow(updateIf(!isNull(targetCoverage@coverage_id))) ~> AlterRow1",
						"osTargetDeductible derive(deductibleJson = json_data) ~> updatedDeductiblejson",
						"filter2 filter(!isNull (risk_id)) ~> filter1",
						"targetCoverage derive(policyPrefixTemp = substring(policy_number, 1, 3)) ~> derivedColumn3",
						"derivedColumn3 filter(policyPrefixTemp == $policyPrefix) ~> filter2",
						"AlterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          coverage_id as integer,",
						"          policy_id as integer,",
						"          json_data as string,",
						"          coverage_code as string,",
						"          risk_id as long,",
						"          location_id as long",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['policy_id','coverage_id','risk_id'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink1"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ds_stage_coverage')]",
				"[concat(variables('factoryId'), '/datasets/ds_stage_limit')]",
				"[concat(variables('factoryId'), '/datasets/ds_stage_deductible')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_addSec000')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Stage Target Data Flows"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "targetSection",
								"type": "DatasetReference"
							},
							"name": "source1"
						},
						{
							"dataset": {
								"referenceName": "ds_stage_location",
								"type": "DatasetReference"
							},
							"name": "targetLocation"
						},
						{
							"dataset": {
								"referenceName": "ds_stage_risk",
								"type": "DatasetReference"
							},
							"name": "targetRisk"
						},
						{
							"dataset": {
								"referenceName": "targetSection",
								"type": "DatasetReference"
							},
							"name": "source2"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policy",
								"type": "DatasetReference"
							},
							"name": "stgPolicy"
						},
						{
							"dataset": {
								"referenceName": "ds_stage_coverage",
								"type": "DatasetReference"
							},
							"name": "sec000Coverages"
						},
						{
							"dataset": {
								"referenceName": "ECMBPA_COV_MAP",
								"type": "DatasetReference"
							},
							"name": "osBpaCovMap"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "targetSection",
								"type": "DatasetReference"
							},
							"name": "targetSection"
						},
						{
							"name": "sink2"
						}
					],
					"transformations": [
						{
							"name": "flowlet1",
							"flowlet": {
								"referenceName": "df_update_stage_policyWithSection1",
								"type": "DataFlowReference",
								"parameters": {}
							}
						},
						{
							"name": "join1"
						},
						{
							"name": "derivedColumn5"
						},
						{
							"name": "targetRiskDerived"
						},
						{
							"name": "select1"
						},
						{
							"name": "aggregate2"
						},
						{
							"name": "lookup1"
						},
						{
							"name": "derivedColumn7"
						},
						{
							"name": "surrogateKey1"
						},
						{
							"name": "select3"
						},
						{
							"name": "filter1"
						},
						{
							"name": "select4"
						},
						{
							"name": "derivedColumn8"
						},
						{
							"name": "derivedColumn9"
						},
						{
							"name": "policyState"
						},
						{
							"name": "lookup2"
						},
						{
							"name": "derivedColumn10"
						},
						{
							"name": "AlterRow1"
						},
						{
							"name": "sec00CovDervied"
						},
						{
							"name": "select5"
						},
						{
							"name": "join2"
						},
						{
							"name": "aggregate3"
						},
						{
							"name": "derivedColumn11"
						},
						{
							"name": "derivedColumn12"
						},
						{
							"name": "derivedColumn13"
						},
						{
							"name": "byPolicyLevel"
						},
						{
							"name": "join3"
						},
						{
							"name": "derivedColumn14"
						}
					],
					"scriptLines": [
						"parameters{",
						"     policyPrefix as string ('CFA')",
						"}",
						"source(output(",
						"          section_id as integer,",
						"          policy_id as integer,",
						"          coverage_id as integer,",
						"          location_id as integer,",
						"          limit_id as integer,",
						"          deductible_id as integer,",
						"          insurableobject_id as integer,",
						"          json_data as string,",
						"          extendedattributes as string,",
						"          section_code as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select * from bpa_section ',",
						"     format: 'query') ~> source1",
						"source(output(",
						"          location_id as integer,",
						"          policy_id as integer,",
						"          address_id as integer,",
						"          json_data as string,",
						"          extendedattributes as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select * from location ',",
						"     format: 'query') ~> targetLocation",
						"source(output(",
						"          risk_id as integer,",
						"          policy_id as integer,",
						"          json_data as string,",
						"          location_id as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select * from risk ',",
						"     format: 'query') ~> targetRisk",
						"source(output(",
						"          section_id as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select MAX(section_id) as section_id from bpa_section',",
						"     format: 'query') ~> source2",
						"source(output(",
						"          POLICY_ID as long,",
						"          POLICY_VID as long,",
						"          REINSURANCE_DAC as string,",
						"          PREVIOUS_INSURANCE_NO_REMARKS as string,",
						"          AGENCY_ID as long,",
						"          AGENCY_OVID as long,",
						"          PRODUCER_ID as long,",
						"          PRODUCER_OVID as long,",
						"          PRODUCER_CONTACT_ID as long,",
						"          PRODUCER_CONTACT_OVID as long,",
						"          POLICY_NUMBER as string,",
						"          ENTITY_TYPE as string,",
						"          ENTITY_STATUS as string,",
						"          IS_RENEWAL_YN as string,",
						"          REVISION_NUMBER as integer,",
						"          PRODUCT_ID as long,",
						"          PRODUCT_OVID as long,",
						"          POLICY_EFFECTIVE_DATE as timestamp,",
						"          POLICY_EXPIRATION_DATE as timestamp,",
						"          NON_RENEWAL_CODE as string,",
						"          POLICY_RENEWED_YN as string,",
						"          CANCELLATION_DATE as timestamp,",
						"          IS_RENEWABLE_YN as string,",
						"          PREVIOUS_INSURANCE_NO_REASON as string,",
						"          POLICY_STATUS as string,",
						"          CANCEL_REASON_CODE as string,",
						"          CANCEL_REASON_DESCRIPTION as string,",
						"          CANCEL_METHOD as string,",
						"          CANCEL_METHOD_DESC as string,",
						"          LOSE_REASON_CODE as string,",
						"          LOSE_REASON_DESC as string,",
						"          DECLINATION_REASON_CODE as string,",
						"          DECLINATION_REASON_DESC as string,",
						"          NOT_WRITTEN_REASON_CODE as string,",
						"          NOT_WRITTEN_REASON_DESC as string,",
						"          POLICY_STATE_CODE as string,",
						"          PROGRAM_ID as long,",
						"          PROGRAM_OVID as long,",
						"          BILLING_TYPE_CODE as string,",
						"          UNDERWRITING_COMPANY_ID as long,",
						"          UNDERWRITING_COMPANY_OVID as long,",
						"          SUBMISSION_ID as long,",
						"          PREVIOUS_INSURANCE_YN as string,",
						"          LEGACY_POLICY_NUMBER as string,",
						"          STATE as string,",
						"          POLICY_POLICY as integer,",
						"          PAYMENT_PLAN as string,",
						"          APPLICATION_RECEIVED_DATE as timestamp,",
						"          INCEPTION_DATE as timestamp,",
						"          BILL_TYPE as string,",
						"          FORMS_LANGUAGE as string,",
						"          BASE_CURRENCY as string,",
						"          INVOICE_CURRENCY as string,",
						"          PREVIOUS_POLICY_ID as long,",
						"          PREVIOUS_POLICY_OVID as long,",
						"          REVISED_FROM_POLICY_ID as long,",
						"          REVISED_FROM_POLICY_OVID as long,",
						"          OPERATING_COMPANY_ID as long,",
						"          OPERATING_COMPANY_OVID as long,",
						"          CONVERTED_FROM_ID as long,",
						"          CONVERTED_FROM_OVID as long,",
						"          INSTALLMENT_RENEWAL as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> stgPolicy",
						"source(output(",
						"          coverage_id as integer,",
						"          policy_id as integer,",
						"          json_data as string,",
						"          coverage_code as string,",
						"          risk_id as long,",
						"          location_id as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select * from coverage ',",
						"     format: 'query') ~> sec000Coverages",
						"source(output(",
						"          COV_SEQ as string,",
						"          BPA_SECTION_CODE as string,",
						"          COVERAGE_CODE as string,",
						"          COVERAGE_CODE_DES as string,",
						"          BPA_COVERAGE_CODES as string,",
						"          BPA_COVERAGES as string,",
						"          COVERAGES as string,",
						"          BPA_PRODUCT_CODE as string,",
						"          SI_NO as string,",
						"          id as long,",
						"          BPA_SEC_NAME as string,",
						"          SOURCE_PRODUCT_CODE as string,",
						"          bpa_coverage_group as string,",
						"          bpa_coverage_level as string,",
						"          bpa_coverage_type as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> osBpaCovMap",
						"derivedColumn7 compose(mapColumn(",
						"          json = json_data,",
						"          id = policy_id,",
						"          sec_id = section_id,",
						"          sec_code = section_code_000,",
						"          filteredSection",
						"     ),",
						"     composition: 'df_update_stage_policyWithSection1') ~> flowlet1@(output1)",
						"derivedColumn5, targetRiskDerived join(targetLocation@policy_id == targetRisk@policy_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"targetLocation derive(locationJson = unescape(json_data,'json')) ~> derivedColumn5",
						"targetRisk derive(riskJson = unescape(json_data,'json')) ~> targetRiskDerived",
						"join1 select(mapColumn(",
						"          policy_id = targetLocation@policy_id,",
						"          locationJson,",
						"          riskJson",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"select1 aggregate(groupBy(policy_id),",
						"     locationJson = distinct(collect(locationJson)),",
						"          riskJson = distinct(collect(riskJson))) ~> aggregate2",
						"lookup2, aggregate2 lookup(source1@policy_id == aggregate2@policy_id,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lookup1",
						"derivedColumn14 derive(json_data = toString(section_json),",
						"          section_id = iif( isNull(sectionId), pkey + sink2#outputs()[1].section_id,sectionId),",
						"          section_code_000 = 'SEC000') ~> derivedColumn7",
						"derivedColumn12 keyGenerate(output(pkey as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> surrogateKey1",
						"join2 select(mapColumn(",
						"          policy_id = source1@policy_id,",
						"          section_code,",
						"          locationJson,",
						"          riskJson,",
						"          POLICY_STATE_CODE,",
						"          POLICY_NUMBER,",
						"          covJson,",
						"          section_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select3",
						"lookup1 filter(!isNull(aggregate2@policy_id)) ~> filter1",
						"flowlet1@output1 select(mapColumn(",
						"          policy_id = id,",
						"          section_code = sec_code,",
						"          json_data = finalJson,",
						"          section_id = sec_id,",
						"          filteredSection",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select4",
						"select4 derive(json_data = replace(json_data, '\"[', '[')) ~> derivedColumn8",
						"derivedColumn8 derive(json_data = replace(json_data, ']\"', ']')) ~> derivedColumn9",
						"stgPolicy select(mapColumn(",
						"          POLICY_ID,",
						"          POLICY_VID,",
						"          POLICY_NUMBER,",
						"          POLICY_STATE_CODE",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> policyState",
						"source1, policyState lookup(source1@policy_id == policyState@POLICY_ID,",
						"     multiple: false,",
						"     pickup: 'first',",
						"     asc(policyState@POLICY_ID, true),",
						"     broadcast: 'auto')~> lookup2",
						"select3 derive(extendedAttributes = @(name='externalPolicyNumber',",
						"          value=POLICY_NUMBER)) ~> derivedColumn10",
						"derivedColumn9 alterRow(insertIf(isNull(filteredSection)),",
						"     updateIf(!isNull(filteredSection))) ~> AlterRow1",
						"join3 derive(covJson = json_data) ~> sec00CovDervied",
						"sec00CovDervied select(mapColumn(",
						"          policy_id,",
						"          covJson",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select5",
						"filter1, select5 join(source1@policy_id == select5@policy_id,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join2",
						"derivedColumn10 aggregate(groupBy(policy_id,",
						"          POLICY_STATE_CODE,",
						"          riskJson,",
						"          locationJson,",
						"          POLICY_NUMBER,",
						"          covJson,",
						"          extendedAttributes),",
						"     seccode_with_sec_id = collect(concat(section_code,'-',toString(section_id)))) ~> aggregate3",
						"aggregate3 derive(filteredSection = find(seccode_with_sec_id, startsWith(#item, 'SEC000'))) ~> derivedColumn11",
						"derivedColumn11 derive(sectionId = toLong(split(filteredSection,'-')[2]),",
						"          section_code = split(filteredSection,'-')[1]) ~> derivedColumn12",
						"sec000Coverages derive(coverageLine = split(coverage_code, '-')[4],",
						"          coverageSeq = split(coverage_code, '-')[5]) ~> derivedColumn13",
						"osBpaCovMap filter((bpa_coverage_level == 'P' && BPA_PRODUCT_CODE == $policyPrefix && BPA_SECTION_CODE == 'SEC000')) ~> byPolicyLevel",
						"derivedColumn13, byPolicyLevel join(coverageLine == osBpaCovMap@COVERAGE_CODE",
						"     && coverageSeq == COV_SEQ,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join3",
						"surrogateKey1 derive(section_json = @(lineOfBusinessCode='EQMR',",
						"          coverTypeCode='SEC000',",
						"          primaryRatingState=POLICY_STATE_CODE,",
						"          coverage=iif(isNull(covJson),array(),array(covJson)),",
						"          insurableObject=riskJson,",
						"          location=locationJson,",
						"          extendedAttributes=array(extendedAttributes))) ~> derivedColumn14",
						"AlterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          section_id as integer,",
						"          policy_id as integer,",
						"          coverage_id as integer,",
						"          location_id as integer,",
						"          limit_id as integer,",
						"          deductible_id as integer,",
						"          insurableobject_id as integer,",
						"          json_data as string,",
						"          extendedattributes as string,",
						"          section_code as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['policy_id','section_id'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> targetSection",
						"source2 sink(validateSchema: false,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     store: 'cache',",
						"     format: 'inline',",
						"     output: false,",
						"     saveOrder: 1) ~> sink2"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_update_stage_policyWithSection1')]",
				"[concat(variables('factoryId'), '/datasets/targetSection')]",
				"[concat(variables('factoryId'), '/datasets/ds_stage_location')]",
				"[concat(variables('factoryId'), '/datasets/ds_stage_risk')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_policy')]",
				"[concat(variables('factoryId'), '/datasets/ds_stage_coverage')]",
				"[concat(variables('factoryId'), '/datasets/ECMBPA_COV_MAP')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_bpa_cfa_limits')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Target Stage Data Flows/cfa"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "bpa_CFA_product_json",
								"type": "DatasetReference"
							},
							"name": "source2"
						},
						{
							"dataset": {
								"referenceName": "ds_BPA_limit",
								"type": "DatasetReference"
							},
							"name": "pkey"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_BPA_limit",
								"type": "DatasetReference"
							},
							"name": "limitMeta"
						},
						{
							"name": "nextPkey"
						}
					],
					"transformations": [
						{
							"name": "flatten1"
						},
						{
							"name": "derivedColumn3"
						},
						{
							"name": "select2"
						},
						{
							"name": "surrogateKey1"
						},
						{
							"name": "flatten3"
						},
						{
							"name": "derivedColumn4"
						}
					],
					"scriptLines": [
						"source(output(",
						"          BroadLine as string,",
						"          Sections as (Code as string, CoverageGroups as (CoverageLevel as string, Coverages as (Code as string, CoverageType as string, Deductible as (DeductibleValues as (ValueCode as string, ValueText as string)[], DefaultValue as string, InputType as string, Name as string, TypeCode as string, ValueType as string)[], Description as string, DisplayName as string, IsDefault as boolean, IsMandatory as boolean, Level as string, Limit as (DefaultValue as string, InputType as string, LimitValues as (ValueCode as string, ValueText as string)[], Max as double, Min as double, Name as string, PercentageOf as string, TypeCode as string, ValueType as string)[], SequenceNumber as short)[], DisplayName as string, GroupCode as string, IsMandatory as boolean, SequenceNumber as short)[], DisplayName as string, IsMandatory as boolean, IsPrimary as boolean, IsSharedCarrier as boolean, LOB as string, SequenceNumber as short)[]",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     documentForm: 'singleDocument') ~> source2",
						"source(output(",
						"          limit_id as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: ('select COALESCE(MAX(limit_id),0) as limit_id from bpa_limit_detail'),",
						"     format: 'query') ~> pkey",
						"source2 foldDown(unroll(Sections.CoverageGroups, Sections),",
						"     mapColumn(",
						"          BroadLine,",
						"          CoverageGroups = Sections.CoverageGroups,",
						"          Coverages = Sections.CoverageGroups.Coverages,",
						"          covGrpName = Sections.CoverageGroups.DisplayName,",
						"          GroupCode = Sections.CoverageGroups.GroupCode,",
						"          Code = Sections.Code",
						"     ),",
						"     skipDuplicateMapInputs: false,",
						"     skipDuplicateMapOutputs: false) ~> flatten1",
						"flatten3 derive(secCode = secCode,",
						"          limitName = Limit.Name,",
						"          limitTypeCode = Limit.TypeCode,",
						"          limitValueType = Limit.ValueType) ~> derivedColumn3",
						"derivedColumn3 select(mapColumn(",
						"          coverageCode = CoverageCode,",
						"          secCode,",
						"          limitName,",
						"          limitTypeCode,",
						"          limitValueType,",
						"          coverage_group_code = groupCode",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select2",
						"select2 keyGenerate(output(pkey as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> surrogateKey1",
						"flatten1 foldDown(unroll(Coverages.Limit, Coverages),",
						"     mapColumn(",
						"          BroadLine,",
						"          CoverageCode = Coverages.Code,",
						"          Limit = Coverages.Limit,",
						"          secCode = Code,",
						"          coverageName = Coverages.DisplayName,",
						"          covGrpName,",
						"          groupCode = GroupCode",
						"     ),",
						"     skipDuplicateMapInputs: false,",
						"     skipDuplicateMapOutputs: false) ~> flatten3",
						"surrogateKey1 derive(limit_id = nextPkey#outputs()[1].limit_id + pkey) ~> derivedColumn4",
						"derivedColumn4 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          limit_id as long,",
						"          coverageCode as string,",
						"          secCode as string,",
						"          limitValueType as string,",
						"          limitTypeCode as string,",
						"          limitName as string,",
						"          coverage_group_code as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> limitMeta",
						"pkey sink(validateSchema: false,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     store: 'cache',",
						"     format: 'inline',",
						"     output: false,",
						"     saveOrder: 1) ~> nextPkey"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/bpa_CFA_product_json')]",
				"[concat(variables('factoryId'), '/datasets/ds_BPA_limit')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_bpa_product_Ref')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Target Stage Data Flows"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "bpa_emp_product",
								"type": "DatasetReference"
							},
							"name": "source2"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_BPA_limit",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "flatten1"
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "select1"
						},
						{
							"name": "flatten2"
						},
						{
							"name": "derivedColumn2"
						},
						{
							"name": "derivedColumn3"
						},
						{
							"name": "select2"
						},
						{
							"name": "surrogateKey1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          BroadLine as string,",
						"          Sections as (Code as string, DisplayName as string, Description as string, LOB as string, SequenceNumber as integer, IsPrimary as boolean, IsMandatory as boolean, Coverages as (Code as string, DisplayName as string, CoverageType as string, Limit as (TypeCode as string, Min as double, Max as integer, ValueType as string, InputType as string, Name as string)[], Level as string, IsMandatory as boolean, IsDefault as boolean)[], IsSharedCarrier as boolean)[]",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     documentForm: 'singleDocument') ~> source2",
						"source2 foldDown(unroll(Sections.Coverages.Limit, Sections.Coverages),",
						"     mapColumn(",
						"          BroadLine,",
						"          Coverages = Sections.Coverages",
						"     ),",
						"     skipDuplicateMapInputs: false,",
						"     skipDuplicateMapOutputs: false) ~> flatten1",
						"flatten1 derive(derviedCoverages = Coverages) ~> derivedColumn1",
						"derivedColumn1 select(mapColumn(",
						"          coverageCode = derviedCoverages.Code,",
						"          CoverageLimits = derviedCoverages.Limit",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"select1 foldDown(unroll(CoverageLimits, CoverageLimits),",
						"     mapColumn(",
						"          coverageCode,",
						"          CoverageLimits",
						"     ),",
						"     skipDuplicateMapInputs: false,",
						"     skipDuplicateMapOutputs: false) ~> flatten2",
						"flatten2 derive(CoverageLimits = CoverageLimits) ~> derivedColumn2",
						"derivedColumn2 derive(secCode = coverageCode,",
						"          limitName = CoverageLimits.Name,",
						"          limitTypeCode = CoverageLimits.TypeCode,",
						"          limitValueType = CoverageLimits.ValueType) ~> derivedColumn3",
						"derivedColumn3 select(mapColumn(",
						"          coverageCode,",
						"          secCode,",
						"          limitName,",
						"          limitTypeCode,",
						"          limitValueType",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select2",
						"select2 keyGenerate(output(limit_id as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> surrogateKey1",
						"surrogateKey1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          limit_id as long,",
						"          coverageCode as string,",
						"          secCode as string,",
						"          limitValueType as string,",
						"          limitTypeCode as string,",
						"          limitName as string,",
						"          coverage_group_code as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink1"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/bpa_emp_product')]",
				"[concat(variables('factoryId'), '/datasets/ds_BPA_limit')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_clientPartToBlank')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Target Stage Data Flows"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_stage_policy",
								"type": "DatasetReference"
							},
							"name": "policy"
						},
						{
							"dataset": {
								"referenceName": "insuredDetails",
								"type": "DatasetReference"
							},
							"name": "ecmInsured"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_stage_policy",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "AlterRow1"
						},
						{
							"name": "join1"
						},
						{
							"name": "derivedColumn2"
						},
						{
							"name": "derivedColumn3"
						},
						{
							"name": "select1"
						},
						{
							"name": "insuredSelect"
						},
						{
							"name": "derivedColumn4"
						},
						{
							"name": "derivedColumn5"
						}
					],
					"scriptLines": [
						"source(output(",
						"          policy_id as integer,",
						"          policy_number as string,",
						"          json_data as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> policy",
						"source(output(",
						"          PolicyPrefix as string,",
						"          Policy as string,",
						"          Policy_Sequence as string,",
						"          RowStatus as string,",
						"          EffectiveDate as timestamp,",
						"          ExpirationDate as timestamp,",
						"          LocationNumber as string,",
						"          LocationUnitNumber as string,",
						"          InsuredNumber as integer,",
						"          InsuredType as string,",
						"          InsuredSubType as string,",
						"          LinkToApplicant as string,",
						"          FirstName as string,",
						"          MiddleName as string,",
						"          LastName as string,",
						"          NameSuffix as string,",
						"          CorporateName as string,",
						"          DBACode as string,",
						"          AlternateName as string,",
						"          MailingAddress1 as string,",
						"          MailingAddress2 as string,",
						"          MailingCity as string,",
						"          MailingState as string,",
						"          MailingZipCode as string,",
						"          MailingCountryCode as string,",
						"          DOB as date,",
						"          Relationship as string,",
						"          ExcludedDate as date,",
						"          ActiveMilitary as string,",
						"          SubTypeOther as string,",
						"          ID as integer,",
						"          DataSource as string,",
						"          DW_InsertDate as date",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> ecmInsured",
						"select1 alterRow(updateIf(!isNull(policy_id))) ~> AlterRow1",
						"policy, insuredSelect join(policy_number == Policy,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"derivedColumn5 derive(json_data = replace(json_data, '\"clientParticipant\":[]', concat('\"clientParticipant\":',toString(clientArray)))) ~> derivedColumn2",
						"join1 derive(clientParticipant = @(party=@(name=@(givenName=replace(trim(CorporateName),'\"',''),",
						"          surname=replace(trim(CorporateName),'\"','')),",
						"          partyTypeCode='person',",
						"          person=@(name=@(givenName=replace(trim(CorporateName),'\"',''),",
						"          surname=replace(trim(CorporateName),'\"','')))),",
						"          subRoleCode='primaryInsured',",
						"          roleCode='insured')) ~> derivedColumn3",
						"derivedColumn4 select(mapColumn(",
						"          policy_id,",
						"          policy_number,",
						"          json_data",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"ecmInsured select(mapColumn(",
						"          PolicyPrefix,",
						"          Policy,",
						"          FirstName,",
						"          MiddleName,",
						"          LastName,",
						"          NameSuffix,",
						"          CorporateName,",
						"          AlternateName",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> insuredSelect",
						"derivedColumn2 derive(json_data = replace(json_data, '2023-12-12', '2023-12-12')) ~> derivedColumn4",
						"derivedColumn3 derive(clientArray = array(clientParticipant)) ~> derivedColumn5",
						"AlterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          policy_id as integer,",
						"          policy_number as string,",
						"          json_data as string",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['policy_id'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink1"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ds_stage_policy')]",
				"[concat(variables('factoryId'), '/datasets/insuredDetails')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_ratefilingClientReport')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Target Stage Data Flows"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_target_rater_report",
								"type": "DatasetReference"
							},
							"name": "insReport"
						},
						{
							"dataset": {
								"referenceName": "ECMBPA_COV_MAP",
								"type": "DatasetReference"
							},
							"name": "source1"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRisk",
								"type": "DatasetReference"
							},
							"name": "source2"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policy",
								"type": "DatasetReference"
							},
							"name": "source3"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_target_rater_report",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "filter1"
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "join1"
						},
						{
							"name": "join2"
						},
						{
							"name": "join3"
						},
						{
							"name": "select1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          source_policy_number as string,",
						"          bpa_policy_ref as string,",
						"          transaction_type as string,",
						"          source_coverage_code as string,",
						"          target_coverage_code as string,",
						"          source_insurable_object as string,",
						"          source_premium as string,",
						"          bpa_premium as string,",
						"          product_code as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: '\\nselect qf.policy_number source_policy_number,qf.policy_reference as bpa_policy_ref,rp.transaction_type,\\nrp.source_coverage_code ,rp.target_coverage_code,rp.source_insurable_object,rp.source_premium,rp.target_premium as bpa_premium,rp.product_code\\nfrom quote_info qf join  rating_report rp on rp.source_policy_number=qf.policy_number',",
						"     format: 'query') ~> insReport",
						"source(output(",
						"          COV_SEQ as string,",
						"          BPA_SECTION_CODE as string,",
						"          COVERAGE_CODE as string,",
						"          COVERAGE_CODE_DES as string,",
						"          BPA_COVERAGE_CODES as string,",
						"          BPA_COVERAGES as string,",
						"          COVERAGES as string,",
						"          BPA_PRODUCT_CODE as string,",
						"          SI_NO as string,",
						"          id as long,",
						"          BPA_SEC_NAME as string,",
						"          SOURCE_PRODUCT_CODE as string,",
						"          bpa_coverage_group as string,",
						"          bpa_coverage_level as string,",
						"          bpa_coverage_type as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> source1",
						"source(output(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_NUMBER as string,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          RISK_IS_ACTIVE_YN as string,",
						"          RISK_EFF_DATE as timestamp,",
						"          RISK_EXP_DATE as timestamp,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> source2",
						"source(output(",
						"          POLICY_ID as long,",
						"          POLICY_VID as long,",
						"          REINSURANCE_DAC as string,",
						"          PREVIOUS_INSURANCE_NO_REMARKS as string,",
						"          AGENCY_ID as long,",
						"          AGENCY_OVID as long,",
						"          PRODUCER_ID as long,",
						"          PRODUCER_OVID as long,",
						"          PRODUCER_CONTACT_ID as long,",
						"          PRODUCER_CONTACT_OVID as long,",
						"          POLICY_NUMBER as string,",
						"          ENTITY_TYPE as string,",
						"          ENTITY_STATUS as string,",
						"          IS_RENEWAL_YN as string,",
						"          REVISION_NUMBER as integer,",
						"          PRODUCT_ID as long,",
						"          PRODUCT_OVID as long,",
						"          POLICY_EFFECTIVE_DATE as timestamp,",
						"          POLICY_EXPIRATION_DATE as timestamp,",
						"          NON_RENEWAL_CODE as string,",
						"          POLICY_RENEWED_YN as string,",
						"          CANCELLATION_DATE as timestamp,",
						"          IS_RENEWABLE_YN as string,",
						"          PREVIOUS_INSURANCE_NO_REASON as string,",
						"          POLICY_STATUS as string,",
						"          CANCEL_REASON_CODE as string,",
						"          CANCEL_REASON_DESCRIPTION as string,",
						"          CANCEL_METHOD as string,",
						"          CANCEL_METHOD_DESC as string,",
						"          LOSE_REASON_CODE as string,",
						"          LOSE_REASON_DESC as string,",
						"          DECLINATION_REASON_CODE as string,",
						"          DECLINATION_REASON_DESC as string,",
						"          NOT_WRITTEN_REASON_CODE as string,",
						"          NOT_WRITTEN_REASON_DESC as string,",
						"          POLICY_STATE_CODE as string,",
						"          PROGRAM_ID as long,",
						"          PROGRAM_OVID as long,",
						"          BILLING_TYPE_CODE as string,",
						"          UNDERWRITING_COMPANY_ID as long,",
						"          UNDERWRITING_COMPANY_OVID as long,",
						"          SUBMISSION_ID as long,",
						"          PREVIOUS_INSURANCE_YN as string,",
						"          LEGACY_POLICY_NUMBER as string,",
						"          STATE as string,",
						"          POLICY_POLICY as integer,",
						"          PAYMENT_PLAN as string,",
						"          APPLICATION_RECEIVED_DATE as timestamp,",
						"          INCEPTION_DATE as timestamp,",
						"          BILL_TYPE as string,",
						"          FORMS_LANGUAGE as string,",
						"          BASE_CURRENCY as string,",
						"          INVOICE_CURRENCY as string,",
						"          PREVIOUS_POLICY_ID as long,",
						"          PREVIOUS_POLICY_OVID as long,",
						"          REVISED_FROM_POLICY_ID as long,",
						"          REVISED_FROM_POLICY_OVID as long,",
						"          OPERATING_COMPANY_ID as long,",
						"          OPERATING_COMPANY_OVID as long,",
						"          CONVERTED_FROM_ID as long,",
						"          CONVERTED_FROM_OVID as long,",
						"          INSTALLMENT_RENEWAL as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> source3",
						"source1 filter(SOURCE_PRODUCT_CODE == 'EMP') ~> filter1",
						"filter1 derive(COVERAGE_CODE = split(COVERAGE_CODE, '0')[2]+'-'+COV_SEQ) ~> derivedColumn1",
						"insReport, derivedColumn1 join(source_coverage_code == COVERAGE_CODE,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"source2, source3 join(source2@POLICY_ID == source3@POLICY_ID,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join2",
						"join1, join2 join(source_policy_number == POLICY_NUMBER",
						"     && source_insurable_object == toString(RISK_ID),",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join3",
						"join3 select(mapColumn(",
						"          source_policy_number,",
						"          bpa_policy_ref,",
						"          transaction_type,",
						"          COVERAGES,",
						"          RISK_NUMBER,",
						"          source_coverage_code,",
						"          target_coverage_code,",
						"          source_insurable_object,",
						"          source_premium,",
						"          bpa_premium,",
						"          product_code,",
						"          COV_SEQ,",
						"          BPA_SECTION_CODE,",
						"          COVERAGE_CODE,",
						"          COVERAGE_CODE_DES,",
						"          BPA_COVERAGE_CODES,",
						"          BPA_COVERAGES,",
						"          BPA_PRODUCT_CODE,",
						"          BPA_SEC_NAME,",
						"          RISK_TYPE_CD",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"select1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          source_policy_number as string,",
						"          stage_policy_number as string,",
						"          target_policy_number as string,",
						"          transaction_type as string,",
						"          source_coverage_code as string,",
						"          target_coverage_code as string,",
						"          source_insurable_object as string,",
						"          target_insurable_object as string,",
						"          target_section as string,",
						"          source_premium as string,",
						"          target_premium as string,",
						"          batch_id as integer,",
						"          bpa_tenant_id as string,",
						"          product_code as string,",
						"          created_at as timestamp,",
						"          updated_at as timestamp,",
						"          horse_breed as string,",
						"          horse_sex as string,",
						"          use as string,",
						"          age_in_years as string,",
						"          year_born as string,",
						"          purchase_date as string,",
						"          purchase_price as string,",
						"          requested_limit as string,",
						"          location_state as string,",
						"          target_section_name as string,",
						"          target_coverage_name as string,",
						"          source_coverage_name as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink1"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ds_target_rater_report')]",
				"[concat(variables('factoryId'), '/datasets/ECMBPA_COV_MAP')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_policyRisk')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_policy')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_source_POL_TX_Deductible')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Source Stage Data Flows/txnDataFlow"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_txnBridge",
								"type": "DatasetReference"
							},
							"name": "StagingTxnBridge"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_polTxn",
								"type": "DatasetReference"
							},
							"name": "stgPolTxn"
						},
						{
							"dataset": {
								"referenceName": "ds_source_FactCoverageDeductible",
								"type": "DatasetReference"
							},
							"name": "fcp"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policy",
								"type": "DatasetReference"
							},
							"name": "polPolicy"
						},
						{
							"dataset": {
								"referenceName": "ds_source_POL_TX_LIMIT_DED_OPT",
								"type": "DatasetReference"
							},
							"name": "PolTxnLimitDedMaxId"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_source_POL_TX_LIMIT_DED_OPT",
								"type": "DatasetReference"
							},
							"name": "PolTxLimitDedOptLimit2"
						},
						{
							"name": "polTxnLDCache"
						}
					],
					"transformations": [
						{
							"name": "flowlet3",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "ded1"
						},
						{
							"name": "derivedColumn2"
						},
						{
							"name": "select1"
						},
						{
							"name": "select2"
						},
						{
							"name": "derivedColumn4"
						},
						{
							"name": "filter1"
						},
						{
							"name": "surrogateKey1"
						},
						{
							"name": "join1"
						},
						{
							"name": "derivedColumn5"
						},
						{
							"name": "join2"
						},
						{
							"name": "distinctRows"
						}
					],
					"scriptLines": [
						"parameters{",
						"     policyPrefix as string,",
						"     policies as string[]",
						"}",
						"source(output(",
						"          TX_BRIDGE_ID as long,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          RISK_ID as long,",
						"          RISK_OVID as long,",
						"          COVERAGE_ID as long,",
						"          COVERAGE_VID as long,",
						"          TX_ID as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select distinct TX_BRIDGE_ID,POLICY_ID,POLICY_OVID,RISK_ID,RISK_OVID,COVERAGE_ID,COVERAGE_VID,TX_ID from POL_TX_BRIDGE',",
						"     format: 'query') ~> StagingTxnBridge",
						"source(output(",
						"          TX_ID as long,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          TX_CODE as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select distinct TX_ID,POLICY_ID,POLICY_OVID,TX_CODE from POL_TX  ',",
						"     format: 'query') ~> stgPolTxn",
						"source(output(",
						"          Policy as string,",
						"          Policy_Sequence as string,",
						"          PolicyPrefix as string,",
						"          ARICCoverageCode as string,",
						"          ARICCoverageDescription as string,",
						"          CoverageDescription as string,",
						"          CoverageInternalCode as string,",
						"          LocationState as string,",
						"          ARICLOB as string,",
						"          LocationNumber as string,",
						"          LocationUnitNumber as string,",
						"          ARICCoverageSequence as integer,",
						"          CoveragePart as string,",
						"          CoverageAddDate as timestamp,",
						"          DESDSC as string,",
						"          DEDESC as string,",
						"          DeductibleCode as string,",
						"          DeductibleAmount1Type as string,",
						"          DeductibleAmount1 as decimal(7,0),",
						"          DeductibleAmount2Type as string,",
						"          DeductibleAmount2 as decimal(7,0)",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from [Fact_Coverage_Deductible] where PolicyPrefix='{$policyPrefix}'\"  +iif(size($policies) >0&& size($policies) ==1&&$policies[1] =='','','and policy in ('+dropLeft(toString(reduce($policies, \"'\", #acc + \",'\" + #item +\"'\", #result)), 2)+')')),",
						"     format: 'query') ~> fcp",
						"source(output(",
						"          POLICY_ID as long,",
						"          POLICY_VID as long,",
						"          REINSURANCE_DAC as string,",
						"          PREVIOUS_INSURANCE_NO_REMARKS as string,",
						"          AGENCY_ID as long,",
						"          AGENCY_OVID as long,",
						"          PRODUCER_ID as long,",
						"          PRODUCER_OVID as long,",
						"          PRODUCER_CONTACT_ID as long,",
						"          PRODUCER_CONTACT_OVID as long,",
						"          POLICY_NUMBER as string,",
						"          ENTITY_TYPE as string,",
						"          ENTITY_STATUS as string,",
						"          IS_RENEWAL_YN as string,",
						"          REVISION_NUMBER as integer,",
						"          PRODUCT_ID as long,",
						"          PRODUCT_OVID as long,",
						"          POLICY_EFFECTIVE_DATE as timestamp,",
						"          POLICY_EXPIRATION_DATE as timestamp,",
						"          NON_RENEWAL_CODE as string,",
						"          POLICY_RENEWED_YN as string,",
						"          CANCELLATION_DATE as timestamp,",
						"          IS_RENEWABLE_YN as string,",
						"          PREVIOUS_INSURANCE_NO_REASON as string,",
						"          POLICY_STATUS as string,",
						"          CANCEL_REASON_CODE as string,",
						"          CANCEL_REASON_DESCRIPTION as string,",
						"          CANCEL_METHOD as string,",
						"          CANCEL_METHOD_DESC as string,",
						"          LOSE_REASON_CODE as string,",
						"          LOSE_REASON_DESC as string,",
						"          DECLINATION_REASON_CODE as string,",
						"          DECLINATION_REASON_DESC as string,",
						"          NOT_WRITTEN_REASON_CODE as string,",
						"          NOT_WRITTEN_REASON_DESC as string,",
						"          POLICY_STATE_CODE as string,",
						"          PROGRAM_ID as long,",
						"          PROGRAM_OVID as long,",
						"          BILLING_TYPE_CODE as string,",
						"          UNDERWRITING_COMPANY_ID as long,",
						"          UNDERWRITING_COMPANY_OVID as long,",
						"          SUBMISSION_ID as long,",
						"          PREVIOUS_INSURANCE_YN as string,",
						"          LEGACY_POLICY_NUMBER as string,",
						"          STATE as string,",
						"          POLICY_POLICY as integer,",
						"          PAYMENT_PLAN as string,",
						"          APPLICATION_RECEIVED_DATE as timestamp,",
						"          INCEPTION_DATE as timestamp,",
						"          BILL_TYPE as string,",
						"          FORMS_LANGUAGE as string,",
						"          BASE_CURRENCY as string,",
						"          INVOICE_CURRENCY as string,",
						"          PREVIOUS_POLICY_ID as long,",
						"          PREVIOUS_POLICY_OVID as long,",
						"          REVISED_FROM_POLICY_ID as long,",
						"          REVISED_FROM_POLICY_OVID as long,",
						"          OPERATING_COMPANY_ID as long,",
						"          OPERATING_COMPANY_OVID as long,",
						"          CONVERTED_FROM_ID as long,",
						"          CONVERTED_FROM_OVID as long,",
						"          INSTALLMENT_RENEWAL as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select * from POL_POLICY ',",
						"     format: 'query') ~> polPolicy",
						"source(output(",
						"          limit_id as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select MAX (TX_LIMIT_DED_OPT_ID)  as limit_id  from POL_TX_LIMIT_DED_OPT',",
						"     format: 'query') ~> PolTxnLimitDedMaxId",
						"derivedColumn4 compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet3@(output1)",
						"distinctRows derive(TX_ID = TX_ID,",
						"          RISK_ID = RISK_ID,",
						"          TX_BRIDGE_ID = TX_BRIDGE_ID,",
						"          RISK_OVID = RISK_OVID,",
						"          POLICY_ID = POLICY_ID,",
						"          POLICY_OVID = POLICY_OVID,",
						"          COVERAGE_ID = COVERAGE_ID,",
						"          COVERAGE_OVID = COVERAGE_VID) ~> ded1",
						"join1 derive(Policy_Sequence_tx = split(TX_CODE,'-')[1],",
						"          LocationNumber_tx = split(TX_CODE,'-')[2],",
						"          LocationUnitNumber_tx = split(TX_CODE,'-')[3],",
						"          ARICGroupCode_tx = split(TX_CODE,'-')[4],",
						"          PrimaryPremiumStateCode_tx = split(TX_CODE,'-')[5],",
						"          ARICLOB_tx = split(TX_CODE,'-')[6],",
						"          ARICCoverageCode_tx = split(TX_CODE,'-')[7],",
						"          ARICCoverageSequence_tx = split(TX_CODE,'-')[8]) ~> derivedColumn2",
						"derivedColumn2 select(mapColumn(",
						"          TX_BRIDGE_ID,",
						"          POLICY_ID = StagingTxnBridge@POLICY_ID,",
						"          POLICY_OVID = StagingTxnBridge@POLICY_OVID,",
						"          TX_ID = StagingTxnBridge@TX_ID,",
						"          RISK_ID,",
						"          RISK_OVID,",
						"          COVERAGE_ID,",
						"          COVERAGE_VID,",
						"          TX_ID = stgPolTxn@TX_ID,",
						"          POLICY_ID = stgPolTxn@POLICY_ID,",
						"          POLICY_OVID = stgPolTxn@POLICY_OVID,",
						"          TX_CODE,",
						"          Policy_Sequence_tx,",
						"          LocationNumber_tx,",
						"          LocationUnitNumber_tx,",
						"          ARICGroupCode_tx,",
						"          PrimaryPremiumStateCode_tx,",
						"          ARICLOB_tx,",
						"          ARICCoverageCode_tx,",
						"          ARICCoverageSequence_tx",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"fcp select(mapColumn(",
						"          Policy,",
						"          Policy_Sequence,",
						"          PolicyPrefix,",
						"          ARICCoverageCode,",
						"          ARICCoverageDescription,",
						"          CoverageDescription,",
						"          CoverageInternalCode,",
						"          LocationState,",
						"          ARICLOB,",
						"          LocationNumber,",
						"          LocationUnitNumber,",
						"          ARICCoverageSequence,",
						"          CoveragePart,",
						"          CoverageAddDate,",
						"          DESDSC,",
						"          DEDESC,",
						"          DeductibleCode,",
						"          DeductibleAmount1Type,",
						"          DeductibleAmount1,",
						"          DeductibleAmount2Type,",
						"          DeductibleAmount2",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select2",
						"surrogateKey1 derive(LIMIT_DED_OPT_TYPE_ID = 1,",
						"          LDO_CODE = DeductibleCode,",
						"          LDO_VALUE = DeductibleAmount1,",
						"          LDO_TXT = DEDESC,",
						"          TX_LIMIT_DED_OPT_ID = pkey + polTxnLDCache#outputs()[1].limit_id,",
						"          LDO_FLAG = 'D') ~> derivedColumn4",
						"join2 filter(!isNull(Policy)) ~> filter1",
						"ded1 keyGenerate(output(pkey as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> surrogateKey1",
						"StagingTxnBridge, stgPolTxn join(StagingTxnBridge@TX_ID == stgPolTxn@TX_ID,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"PolTxnLimitDedMaxId derive(limit_id = iifNull(limit_id, 0, limit_id)) ~> derivedColumn5",
						"select1, select2 join(Policy_Sequence_tx == Policy_Sequence",
						"     && LocationNumber_tx == LocationNumber",
						"     && LocationUnitNumber_tx == LocationUnitNumber",
						"     && ARICLOB_tx == ARICLOB",
						"     && ARICCoverageCode_tx == ARICCoverageCode",
						"     && ARICCoverageSequence_tx == toString(ARICCoverageSequence),",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join2",
						"filter1 aggregate(groupBy(TX_BRIDGE_ID),",
						"     each(match(name!='TX_BRIDGE_ID'), $$ = first($$))) ~> distinctRows",
						"flowlet3@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          TX_LIMIT_DED_OPT_ID as long,",
						"          TX_ID as long,",
						"          LOCATION_ID as long,",
						"          LOCATION_OVID as long,",
						"          SECTION_ID as long,",
						"          SECTION_OVID as long,",
						"          TX_BRIDGE_ID as long,",
						"          RISK_ID as long,",
						"          RISK_OVID as long,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          LIMIT_DED_OPT_TYPE_ID as long,",
						"          LDO_FLAG as string,",
						"          LDO_CODE as string,",
						"          LIMIT_OCCURRENCE_FLAG as string,",
						"          LDO_VALUE as long,",
						"          LDO_VALUE_CCY_CODE as string,",
						"          LDO_PERCENTAGE as decimal(6,4),",
						"          LDO_TEXT as string,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          DATA_HASH as binary,",
						"          SOURCE_KEY as string,",
						"          COVERAGE_ID as long,",
						"          COVERAGE_OVID as long",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> PolTxLimitDedOptLimit2",
						"derivedColumn5 sink(validateSchema: false,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     store: 'cache',",
						"     format: 'inline',",
						"     output: false,",
						"     saveOrder: 1) ~> polTxnLDCache"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/fl_source_addDefaultColumnFlowlet')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_txnBridge')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_polTxn')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_FactCoverageDeductible')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_policy')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_POL_TX_LIMIT_DED_OPT')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_source_POL_TX_LIMIT1')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Source Stage Data Flows/txnDataFlow"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_txnBridge",
								"type": "DatasetReference"
							},
							"name": "StagingTxnBridge"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_polTxn",
								"type": "DatasetReference"
							},
							"name": "stgPolTxn"
						},
						{
							"dataset": {
								"referenceName": "ds_source_Fact_Coverage_Premium",
								"type": "DatasetReference"
							},
							"name": "fcp"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policy",
								"type": "DatasetReference"
							},
							"name": "polPolicy"
						},
						{
							"dataset": {
								"referenceName": "ds_source_POL_TX_LIMIT_DED_OPT",
								"type": "DatasetReference"
							},
							"name": "source1"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_source_POL_TX_LIMIT_DED_OPT",
								"type": "DatasetReference"
							},
							"name": "PolTxLimitDedOptLimit2"
						},
						{
							"name": "limitKeyCache"
						}
					],
					"transformations": [
						{
							"name": "flowlet3",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "limit1"
						},
						{
							"name": "lookup2"
						},
						{
							"name": "derivedColumn2"
						},
						{
							"name": "select1"
						},
						{
							"name": "select2"
						},
						{
							"name": "derivedColumn4"
						},
						{
							"name": "select3"
						},
						{
							"name": "derivedColumn5"
						},
						{
							"name": "surrogateKey1"
						},
						{
							"name": "filter1"
						},
						{
							"name": "join1"
						},
						{
							"name": "join2"
						}
					],
					"scriptLines": [
						"parameters{",
						"     policyPrefix as string,",
						"     policies as string[]",
						"}",
						"source(output(",
						"          TX_BRIDGE_ID as long,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          RISK_ID as long,",
						"          RISK_OVID as long,",
						"          COVERAGE_ID as long,",
						"          COVERAGE_VID as long,",
						"          TX_ID as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select distinct TX_BRIDGE_ID,POLICY_ID,POLICY_OVID,RISK_ID,RISK_OVID,COVERAGE_ID,COVERAGE_VID,TX_ID from POL_TX_BRIDGE\\n',",
						"     format: 'query') ~> StagingTxnBridge",
						"source(output(",
						"          TX_ID as long,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          TX_CODE as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select distinct TX_ID,POLICY_ID,POLICY_OVID,TX_CODE from POL_TX ',",
						"     format: 'query') ~> stgPolTxn",
						"source(output(",
						"          Policy as string,",
						"          Policy_Sequence as string,",
						"          PolicyPrefix as string,",
						"          ARICLOB as string,",
						"          ARICGroupCode as string,",
						"          Description as string,",
						"          Product as string,",
						"          ARICCoverageCode as string,",
						"          ARICCoverageDescription as string,",
						"          PrimaryPremiumStateCode as string,",
						"          LocationNumber as string,",
						"          LocationUnitNumber as string,",
						"          ARICCoverageSequence as integer,",
						"          CoveragePart as string,",
						"          CoverageAddDate as timestamp,",
						"          CoverageDescription as string,",
						"          Limit1 as decimal(38,0),",
						"          Limit2 as decimal(38,0),",
						"          PremiumAmount as decimal(38,2)",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from Fact_Coverage_Premium where PolicyPrefix='{$policyPrefix}'\"),",
						"     format: 'query') ~> fcp",
						"source(output(",
						"          POLICY_ID as long,",
						"          POLICY_VID as long,",
						"          REINSURANCE_DAC as string,",
						"          PREVIOUS_INSURANCE_NO_REMARKS as string,",
						"          AGENCY_ID as long,",
						"          AGENCY_OVID as long,",
						"          PRODUCER_ID as long,",
						"          PRODUCER_OVID as long,",
						"          PRODUCER_CONTACT_ID as long,",
						"          PRODUCER_CONTACT_OVID as long,",
						"          POLICY_NUMBER as string,",
						"          ENTITY_TYPE as string,",
						"          ENTITY_STATUS as string,",
						"          IS_RENEWAL_YN as string,",
						"          REVISION_NUMBER as integer,",
						"          PRODUCT_ID as long,",
						"          PRODUCT_OVID as long,",
						"          POLICY_EFFECTIVE_DATE as timestamp,",
						"          POLICY_EXPIRATION_DATE as timestamp,",
						"          NON_RENEWAL_CODE as string,",
						"          POLICY_RENEWED_YN as string,",
						"          CANCELLATION_DATE as timestamp,",
						"          IS_RENEWABLE_YN as string,",
						"          PREVIOUS_INSURANCE_NO_REASON as string,",
						"          POLICY_STATUS as string,",
						"          CANCEL_REASON_CODE as string,",
						"          CANCEL_REASON_DESCRIPTION as string,",
						"          CANCEL_METHOD as string,",
						"          CANCEL_METHOD_DESC as string,",
						"          LOSE_REASON_CODE as string,",
						"          LOSE_REASON_DESC as string,",
						"          DECLINATION_REASON_CODE as string,",
						"          DECLINATION_REASON_DESC as string,",
						"          NOT_WRITTEN_REASON_CODE as string,",
						"          NOT_WRITTEN_REASON_DESC as string,",
						"          POLICY_STATE_CODE as string,",
						"          PROGRAM_ID as long,",
						"          PROGRAM_OVID as long,",
						"          BILLING_TYPE_CODE as string,",
						"          UNDERWRITING_COMPANY_ID as long,",
						"          UNDERWRITING_COMPANY_OVID as long,",
						"          SUBMISSION_ID as long,",
						"          PREVIOUS_INSURANCE_YN as string,",
						"          LEGACY_POLICY_NUMBER as string,",
						"          POLICY_POLICY as short,",
						"          PAYMENT_PLAN as string,",
						"          APPLICATION_RECEIVED_DATE as timestamp,",
						"          INCEPTION_DATE as timestamp,",
						"          BILL_TYPE as string,",
						"          FORMS_LANGUAGE as string,",
						"          BASE_CURRENCY as string,",
						"          INVOICE_CURRENCY as string,",
						"          PREVIOUS_POLICY_ID as long,",
						"          PREVIOUS_POLICY_OVID as long,",
						"          REVISED_FROM_POLICY_ID as long,",
						"          REVISED_FROM_POLICY_OVID as long,",
						"          OPERATING_COMPANY_ID as long,",
						"          OPERATING_COMPANY_OVID as long,",
						"          CONVERTED_FROM_ID as long,",
						"          CONVERTED_FROM_OVID as long,",
						"          INSTALLMENT_RENEWAL as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from [dbo].[POL_POLICY] where ENTITY_TYPE ='{$policyPrefix}' \"+iif(size($policies) >0&& size($policies) ==1&&$policies[1] =='','','and policy_number in ('+dropLeft(toString(reduce($policies, \"'\", #acc + \",'\" + #item +\"'\", #result)), 2)+')')),",
						"     format: 'query') ~> polPolicy",
						"source(output(",
						"          limit_id as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select MAX (TX_LIMIT_DED_OPT_ID)  as limit_id  from POL_TX_LIMIT_DED_OPT',",
						"     format: 'query') ~> source1",
						"derivedColumn4 compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet3@(output1)",
						"filter1 derive(TX_ID = TX_ID,",
						"          RISK_ID = RISK_ID,",
						"          TX_BRIDGE_ID = TX_BRIDGE_ID,",
						"          POLICY_ID = POLICY_ID,",
						"          POLICY_OVID = POLICY_OVID,",
						"          COVERAGE_ID = COVERAGE_ID,",
						"          COVERAGE_OVID = COVERAGE_VID,",
						"          RISK_OVID = RISK_OVID) ~> limit1",
						"select1, fcp lookup(select1@Policy_Sequence == fcp@Policy_Sequence",
						"     && POLICY_NUMBER == Policy",
						"     && select1@LocationNumber == fcp@LocationNumber",
						"     && select1@LocationUnitNumber == fcp@LocationUnitNumber",
						"     && select1@PrimaryPremiumStateCode == fcp@PrimaryPremiumStateCode",
						"     && select1@ARICLOB == fcp@ARICLOB",
						"     && select1@ARICCoverageCode == fcp@ARICCoverageCode",
						"     && select1@ARICCoverageSequence == toString(fcp@ARICCoverageSequence)",
						"     && select1@ARICGroupCode == fcp@ARICGroupCode,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lookup2",
						"join2 derive(Policy_Sequence = split(TX_CODE,'-')[1],",
						"          LocationNumber = split(TX_CODE,'-')[2],",
						"          LocationUnitNumber = split(TX_CODE,'-')[3],",
						"          ARICGroupCode = split(TX_CODE,'-')[4],",
						"          PrimaryPremiumStateCode = split(TX_CODE,'-')[5],",
						"          ARICLOB = split(TX_CODE,'-')[6],",
						"          ARICCoverageCode = split(TX_CODE,'-')[7],",
						"          ARICCoverageSequence = split(TX_CODE,'-')[8]) ~> derivedColumn2",
						"derivedColumn2 select(mapColumn(",
						"          TX_BRIDGE_ID,",
						"          POLICY_ID = StagingTxnBridge@POLICY_ID,",
						"          POLICY_OVID = StagingTxnBridge@POLICY_OVID,",
						"          TX_ID = StagingTxnBridge@TX_ID,",
						"          RISK_ID,",
						"          RISK_OVID,",
						"          COVERAGE_ID,",
						"          COVERAGE_VID,",
						"          TX_ID = stgPolTxn@TX_ID,",
						"          POLICY_ID = stgPolTxn@POLICY_ID,",
						"          POLICY_OVID = stgPolTxn@POLICY_OVID,",
						"          TX_CODE,",
						"          POLICY_ID = polPolicy@POLICY_ID,",
						"          POLICY_VID,",
						"          POLICY_NUMBER,",
						"          Policy_Sequence,",
						"          LocationNumber,",
						"          LocationUnitNumber,",
						"          ARICGroupCode,",
						"          PrimaryPremiumStateCode,",
						"          ARICLOB,",
						"          ARICCoverageCode,",
						"          ARICCoverageSequence",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"fcp select(mapColumn(",
						"          Policy,",
						"          Policy_Sequence,",
						"          ARICLOB,",
						"          ARICGroupCode,",
						"          ARICCoverageCode,",
						"          ARICCoverageDescription,",
						"          PrimaryPremiumStateCode,",
						"          LocationNumber,",
						"          LocationUnitNumber,",
						"          ARICCoverageSequence,",
						"          CoverageDescription,",
						"          Limit1,",
						"          Limit2,",
						"          PremiumAmount",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select2",
						"surrogateKey1 derive(LIMIT_DED_OPT_TYPE_ID = 3,",
						"          LDO_CODE = 'Limit1',",
						"          LDO_VALUE = Limit1,",
						"          TX_LIMIT_DED_OPT_ID = pkey+limitKeyCache#outputs()[1].limit_id,",
						"          LDO_FLAG = '') ~> derivedColumn4",
						"limit1 select(mapColumn(",
						"          TX_BRIDGE_ID,",
						"          POLICY_ID,",
						"          POLICY_OVID,",
						"          TX_ID,",
						"          RISK_ID,",
						"          RISK_OVID,",
						"          COVERAGE_ID,",
						"          COVERAGE_VID,",
						"          TX_CODE,",
						"          POLICY_VID,",
						"          POLICY_NUMBER,",
						"          Policy,",
						"          Policy_Sequence = fcp@Policy_Sequence,",
						"          PolicyPrefix,",
						"          Description,",
						"          Product,",
						"          ARICCoverageDescription,",
						"          CoveragePart,",
						"          CoverageAddDate,",
						"          CoverageDescription,",
						"          Limit1,",
						"          Limit2,",
						"          PremiumAmount,",
						"          COVERAGE_OVID",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select3",
						"source1 derive(limit_id = iifNull(limit_id, 0, limit_id),",
						"          pkkey := limit_id) ~> derivedColumn5",
						"select3 keyGenerate(output(pkey as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> surrogateKey1",
						"lookup2 filter(!isNull(Policy)) ~> filter1",
						"StagingTxnBridge, stgPolTxn join(StagingTxnBridge@TX_ID == stgPolTxn@TX_ID,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"join1, polPolicy join(StagingTxnBridge@POLICY_ID == polPolicy@POLICY_ID,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join2",
						"flowlet3@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          TX_LIMIT_DED_OPT_ID as long,",
						"          TX_ID as long,",
						"          LOCATION_ID as long,",
						"          LOCATION_OVID as long,",
						"          SECTION_ID as long,",
						"          SECTION_OVID as long,",
						"          TX_BRIDGE_ID as long,",
						"          RISK_ID as long,",
						"          RISK_OVID as long,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          LIMIT_DED_OPT_TYPE_ID as long,",
						"          LDO_FLAG as string,",
						"          LDO_CODE as string,",
						"          LIMIT_OCCURRENCE_FLAG as string,",
						"          LDO_VALUE as long,",
						"          LDO_VALUE_CCY_CODE as string,",
						"          LDO_PERCENTAGE as decimal(6,4),",
						"          LDO_TEXT as string,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          DATA_HASH as binary,",
						"          SOURCE_KEY as string,",
						"          COVERAGE_ID as long,",
						"          COVERAGE_OVID as long",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> PolTxLimitDedOptLimit2",
						"derivedColumn5 sink(validateSchema: false,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     store: 'cache',",
						"     format: 'inline',",
						"     output: false,",
						"     saveOrder: 1) ~> limitKeyCache"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/fl_source_addDefaultColumnFlowlet')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_txnBridge')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_polTxn')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_Fact_Coverage_Premium')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_policy')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_POL_TX_LIMIT_DED_OPT')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_source_POL_TX_LIMIT2')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Source Stage Data Flows/txnDataFlow"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_txnBridge",
								"type": "DatasetReference"
							},
							"name": "StagingTxnBridge"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_polTxn",
								"type": "DatasetReference"
							},
							"name": "stgPolTxn"
						},
						{
							"dataset": {
								"referenceName": "ds_source_Fact_Coverage_Premium",
								"type": "DatasetReference"
							},
							"name": "fcp"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policy",
								"type": "DatasetReference"
							},
							"name": "polPolicy"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_locationRiskBridge",
								"type": "DatasetReference"
							},
							"name": "risklocationBridge"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_source_POL_TX_LIMIT_DED_OPT",
								"type": "DatasetReference"
							},
							"name": "PolTxLimitDedOptLimit2"
						}
					],
					"transformations": [
						{
							"name": "flowlet3",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "limit1"
						},
						{
							"name": "lookup2"
						},
						{
							"name": "lookup3"
						},
						{
							"name": "derivedColumn2"
						},
						{
							"name": "select1"
						},
						{
							"name": "select2"
						},
						{
							"name": "derivedColumn4"
						},
						{
							"name": "surrogateKey1"
						},
						{
							"name": "select3"
						},
						{
							"name": "filter1"
						},
						{
							"name": "select4"
						},
						{
							"name": "lookup4"
						},
						{
							"name": "join1"
						}
					],
					"scriptLines": [
						"parameters{",
						"     policyPrefix as string",
						"}",
						"source(output(",
						"          TX_BRIDGE_ID as long,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          TX_ID as long,",
						"          SECTION_ID as long,",
						"          SECTION_VID as long,",
						"          RISK_ID as long,",
						"          RISK_OVID as long,",
						"          CLASSIFICATION_ID as long,",
						"          CLASSIFICATION_OVID as long,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          DATA_HASH as binary,",
						"          SOURCE_KEY as string,",
						"          COVERAGE_ID as long,",
						"          COVERAGE_VID as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> StagingTxnBridge",
						"source(output(",
						"          TX_ID as long,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          TX_CODE as string,",
						"          SUB_ACTIVITY as string,",
						"          ENDORSEMENT_SEQ_NO as integer,",
						"          IS_SYSTEM_GENERATED_YN as string,",
						"          ENDORSEMENT_CHANGES as string,",
						"          TRANSACTION_EFFECTIVE_DATE as timestamp,",
						"          TRANSACTION_EXPIRY_DATE as timestamp,",
						"          TRANSACTION_BOOK_FLAG_DATE as timestamp,",
						"          PARENT_TRANSACTION_ID as integer,",
						"          TRANSACTION_TYPE_CODE as string,",
						"          TYPE_OF_CHANGE as string,",
						"          TRANSACTION_CREATED_DATE as timestamp,",
						"          TRANSACTION_MODIFIED_DATE as timestamp,",
						"          TRANSACTION_DISPLAY_NAME as string,",
						"          TRANSACTION_PERIOD_PRORATION as decimal(19,9),",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          DATA_HASH as binary,",
						"          SOURCE_KEY as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> stgPolTxn",
						"source(output(",
						"          Policy as string,",
						"          Policy_Sequence as string,",
						"          PolicyPrefix as string,",
						"          ARICLOB as string,",
						"          ARICGroupCode as string,",
						"          Description as string,",
						"          Product as string,",
						"          ARICCoverageCode as string,",
						"          ARICCoverageDescription as string,",
						"          PrimaryPremiumStateCode as string,",
						"          LocationNumber as string,",
						"          LocationUnitNumber as string,",
						"          ARICCoverageSequence as integer,",
						"          CoveragePart as string,",
						"          CoverageAddDate as timestamp,",
						"          CoverageDescription as string,",
						"          Limit1 as decimal(38,0),",
						"          Limit2 as decimal(38,0),",
						"          PremiumAmount as decimal(38,2)",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from Fact_Coverage_Premium where PolicyPrefix='{$policyPrefix}'\"),",
						"     format: 'query') ~> fcp",
						"source(output(",
						"          POLICY_ID as long,",
						"          POLICY_VID as long,",
						"          REINSURANCE_DAC as string,",
						"          PREVIOUS_INSURANCE_NO_REMARKS as string,",
						"          AGENCY_ID as long,",
						"          AGENCY_OVID as long,",
						"          PRODUCER_ID as long,",
						"          PRODUCER_OVID as long,",
						"          PRODUCER_CONTACT_ID as long,",
						"          PRODUCER_CONTACT_OVID as long,",
						"          POLICY_NUMBER as string,",
						"          ENTITY_TYPE as string,",
						"          ENTITY_STATUS as string,",
						"          IS_RENEWAL_YN as string,",
						"          REVISION_NUMBER as integer,",
						"          PRODUCT_ID as long,",
						"          PRODUCT_OVID as long,",
						"          POLICY_EFFECTIVE_DATE as timestamp,",
						"          POLICY_EXPIRATION_DATE as timestamp,",
						"          NON_RENEWAL_CODE as string,",
						"          POLICY_RENEWED_YN as string,",
						"          CANCELLATION_DATE as timestamp,",
						"          IS_RENEWABLE_YN as string,",
						"          PREVIOUS_INSURANCE_NO_REASON as string,",
						"          POLICY_STATUS as string,",
						"          CANCEL_REASON_CODE as string,",
						"          CANCEL_REASON_DESCRIPTION as string,",
						"          CANCEL_METHOD as string,",
						"          CANCEL_METHOD_DESC as string,",
						"          LOSE_REASON_CODE as string,",
						"          LOSE_REASON_DESC as string,",
						"          DECLINATION_REASON_CODE as string,",
						"          DECLINATION_REASON_DESC as string,",
						"          NOT_WRITTEN_REASON_CODE as string,",
						"          NOT_WRITTEN_REASON_DESC as string,",
						"          POLICY_STATE_CODE as string,",
						"          PROGRAM_ID as long,",
						"          PROGRAM_OVID as long,",
						"          BILLING_TYPE_CODE as string,",
						"          UNDERWRITING_COMPANY_ID as long,",
						"          UNDERWRITING_COMPANY_OVID as long,",
						"          SUBMISSION_ID as long,",
						"          PREVIOUS_INSURANCE_YN as string,",
						"          LEGACY_POLICY_NUMBER as string,",
						"          STATE as string,",
						"          POLICY_POLICY as integer,",
						"          PAYMENT_PLAN as string,",
						"          APPLICATION_RECEIVED_DATE as timestamp,",
						"          INCEPTION_DATE as timestamp,",
						"          BILL_TYPE as string,",
						"          FORMS_LANGUAGE as string,",
						"          BASE_CURRENCY as string,",
						"          INVOICE_CURRENCY as string,",
						"          PREVIOUS_POLICY_ID as long,",
						"          PREVIOUS_POLICY_OVID as long,",
						"          REVISED_FROM_POLICY_ID as long,",
						"          REVISED_FROM_POLICY_OVID as long,",
						"          OPERATING_COMPANY_ID as long,",
						"          OPERATING_COMPANY_OVID as long,",
						"          CONVERTED_FROM_ID as long,",
						"          CONVERTED_FROM_OVID as long,",
						"          INSTALLMENT_RENEWAL as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select * from POL_POLICY',",
						"     format: 'query') ~> polPolicy",
						"source(output(",
						"          LOCATION_ID as long,",
						"          LOCATION_OVID as long,",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          DATA_HASH as binary,",
						"          SOURCE_KEY as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> risklocationBridge",
						"derivedColumn4 compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet3@(output1)",
						"lookup4 derive(TX_ID = TX_ID,",
						"          RISK_ID = select1@RISK_ID,",
						"          TX_BRIDGE_ID = TX_BRIDGE_ID,",
						"          RISK_OVID = RISK_OVID,",
						"          POLICY_ID = POLICY_ID,",
						"          POLICY_OVID = POLICY_OVID,",
						"          COVERAGE_ID = COVERAGE_ID,",
						"          COVERAGE_OVID = COVERAGE_VID) ~> limit1",
						"select1, fcp lookup(select1@Policy_Sequence == fcp@Policy_Sequence",
						"     && select1@LocationNumber == fcp@LocationNumber",
						"     && select1@LocationUnitNumber == fcp@LocationUnitNumber",
						"     && select1@PrimaryPremiumStateCode == fcp@PrimaryPremiumStateCode",
						"     && select1@ARICLOB == fcp@ARICLOB",
						"     && select1@ARICCoverageCode == fcp@ARICCoverageCode",
						"     && select1@ARICCoverageSequence == toString(fcp@ARICCoverageSequence)",
						"     && select1@ARICGroupCode == fcp@ARICGroupCode,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lookup2",
						"join1, polPolicy lookup(StagingTxnBridge@POLICY_ID == polPolicy@POLICY_ID,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lookup3",
						"lookup3 derive(Policy_Sequence = split(TX_CODE,'-')[1],",
						"          LocationNumber = split(TX_CODE,'-')[2],",
						"          LocationUnitNumber = split(TX_CODE,'-')[3],",
						"          ARICGroupCode = split(TX_CODE,'-')[4],",
						"          PrimaryPremiumStateCode = split(TX_CODE,'-')[5],",
						"          ARICLOB = split(TX_CODE,'-')[6],",
						"          ARICCoverageCode = split(TX_CODE,'-')[7],",
						"          ARICCoverageSequence = split(TX_CODE,'-')[8]) ~> derivedColumn2",
						"derivedColumn2 select(mapColumn(",
						"          TX_BRIDGE_ID,",
						"          POLICY_ID = StagingTxnBridge@POLICY_ID,",
						"          POLICY_OVID = StagingTxnBridge@POLICY_OVID,",
						"          TX_ID = StagingTxnBridge@TX_ID,",
						"          SECTION_ID,",
						"          SECTION_VID,",
						"          RISK_ID,",
						"          RISK_OVID,",
						"          COVERAGE_ID,",
						"          COVERAGE_VID,",
						"          TX_ID = stgPolTxn@TX_ID,",
						"          POLICY_ID = stgPolTxn@POLICY_ID,",
						"          POLICY_OVID = stgPolTxn@POLICY_OVID,",
						"          TX_CODE,",
						"          TRANSACTION_TYPE_CODE,",
						"          TYPE_OF_CHANGE,",
						"          POLICY_ID = polPolicy@POLICY_ID,",
						"          POLICY_VID,",
						"          POLICY_NUMBER,",
						"          Policy_Sequence,",
						"          LocationNumber,",
						"          LocationUnitNumber,",
						"          ARICGroupCode,",
						"          PrimaryPremiumStateCode,",
						"          ARICLOB,",
						"          ARICCoverageCode,",
						"          ARICCoverageSequence",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"fcp select(mapColumn(",
						"          Policy,",
						"          Policy_Sequence,",
						"          ARICLOB,",
						"          ARICGroupCode,",
						"          ARICCoverageCode,",
						"          ARICCoverageDescription,",
						"          PrimaryPremiumStateCode,",
						"          LocationNumber,",
						"          LocationUnitNumber,",
						"          ARICCoverageSequence,",
						"          CoverageDescription,",
						"          Limit1,",
						"          Limit2,",
						"          PremiumAmount",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select2",
						"surrogateKey1 derive(LIMIT_DED_OPT_TYPE_ID = 4,",
						"          LDO_CODE = 'Limit2',",
						"          LDO_VALUE = Limit2,",
						"          LDO_FLAG = '') ~> derivedColumn4",
						"select3 keyGenerate(output(TX_LIMIT_DED_OPT_ID as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> surrogateKey1",
						"limit1 select(mapColumn(",
						"          TX_BRIDGE_ID,",
						"          POLICY_ID,",
						"          POLICY_OVID,",
						"          TX_ID,",
						"          SECTION_ID,",
						"          SECTION_VID,",
						"          RISK_ID,",
						"          RISK_OVID,",
						"          COVERAGE_ID,",
						"          COVERAGE_VID,",
						"          TX_CODE,",
						"          TRANSACTION_TYPE_CODE,",
						"          TYPE_OF_CHANGE,",
						"          POLICY_VID,",
						"          POLICY_NUMBER,",
						"          Policy,",
						"          PolicyPrefix,",
						"          Description,",
						"          Product,",
						"          ARICCoverageDescription,",
						"          Limit1,",
						"          Limit2,",
						"          PremiumAmount,",
						"          COVERAGE_OVID,",
						"          LOCATION_ID,",
						"          LOCATION_OVID",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select3",
						"lookup2 filter(!isNull(Policy)) ~> filter1",
						"risklocationBridge select(mapColumn(",
						"          LOCATION_ID,",
						"          LOCATION_OVID,",
						"          RISK_ID,",
						"          RISK_VID",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select4",
						"filter1, risklocationBridge lookup(select1@RISK_ID == risklocationBridge@RISK_ID",
						"     && RISK_OVID == RISK_VID,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lookup4",
						"StagingTxnBridge, stgPolTxn join(StagingTxnBridge@TX_ID == stgPolTxn@TX_ID,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"flowlet3@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          TX_LIMIT_DED_OPT_ID as long,",
						"          TX_ID as long,",
						"          LOCATION_ID as long,",
						"          LOCATION_OVID as long,",
						"          SECTION_ID as long,",
						"          SECTION_OVID as long,",
						"          TX_BRIDGE_ID as long,",
						"          RISK_ID as long,",
						"          RISK_OVID as long,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          LIMIT_DED_OPT_TYPE_ID as long,",
						"          LDO_FLAG as string,",
						"          LDO_CODE as string,",
						"          LIMIT_OCCURRENCE_FLAG as string,",
						"          LDO_VALUE as long,",
						"          LDO_VALUE_CCY_CODE as string,",
						"          LDO_PERCENTAGE as decimal(6,4),",
						"          LDO_TEXT as string,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          DATA_HASH as binary,",
						"          SOURCE_KEY as string,",
						"          COVERAGE_ID as long,",
						"          COVERAGE_OVID as long",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> PolTxLimitDedOptLimit2"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/fl_source_addDefaultColumnFlowlet')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_txnBridge')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_polTxn')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_Fact_Coverage_Premium')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_policy')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_locationRiskBridge')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_POL_TX_LIMIT_DED_OPT')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_source_POL__LIMIT_DED_OPT_TYPE')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Source Stage Data Flows/txnDataFlow"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_ECMDataDictionary",
								"type": "DatasetReference"
							},
							"name": "source1"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_POLLIMITDEDOPTTYPE",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "flowlet1",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "surrogateKey1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          amountType as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select [Column] as amountType from ECMDataDictionary where TableName = \\'PolicyCoveragePremium_P\\' and( [Column] =\\'limit1\\'or [Column] =\\'limit2\\')\\nunion\\nselect [Column] from ECMDataDictionary where TableName = \\'PolicyDeductible_P\\' and( [Column] =\\'DeductibleAmount1Type\\'or [Column] =\\'DeductibleAmount2Type\\')',",
						"     format: 'query') ~> source1",
						"derivedColumn1 compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet1@(output1)",
						"surrogateKey1 derive(POLICY_YN = 'N',",
						"          LIMIT_DED_OPT_TYPE = case(startsWith(amountType, 'DeductibleAmount'), 'Deductible',",
						"case(startsWith(amountType, 'limit'), 'limit','limit')),",
						"          LDO_NAME = case(startsWith(amountType, 'DeductibleAmount1Type'), 'DeductibleAmount1Type',",
						"case(startsWith(amountType, 'DeductibleAmount2Type'), 'DeductibleAmount2Type',",
						"case(startsWith(amountType, 'Limit1'), 'Limit1','Limit2'))),",
						"          COVERAGE_YN = 'Y') ~> derivedColumn1",
						"source1 keyGenerate(output(LIMIT_DED_OPT_TYPE_ID as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> surrogateKey1",
						"flowlet1@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          LIMIT_DED_OPT_TYPE_ID as long,",
						"          POLICY_YN as string,",
						"          LIMIT_DED_OPT_TYPE as string,",
						"          LDO_NAME as string,",
						"          LOCATION_YN as string,",
						"          RISK_YN as string,",
						"          SECTION_YN as string,",
						"          COVERAGE_YN as string,",
						"          GRAIN_CD as string,",
						"          IS_KEY_LDO_YN as string,",
						"          LDO_COLUMN_NAME as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink1"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/fl_source_addDefaultColumnFlowlet')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_ECMDataDictionary')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_POLLIMITDEDOPTTYPE')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_source_agency')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Source Stage Data Flows/referenceDataFlow"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_agent",
								"type": "DatasetReference"
							},
							"name": "agencySource"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_agency",
								"type": "DatasetReference"
							},
							"name": "agencySourceLookup"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_agency",
								"type": "DatasetReference"
							},
							"name": "agencyStaging"
						}
					],
					"transformations": [
						{
							"name": "metadataflowlet",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "requiredSourceAgencyColumns"
						},
						{
							"name": "derivedOtherRequiredColumns"
						},
						{
							"name": "agencySurrogateKey"
						},
						{
							"name": "requiredStagingAgencyColumns"
						},
						{
							"name": "deriveAgencyName"
						},
						{
							"name": "groupByAgencyName"
						}
					],
					"scriptLines": [
						"parameters{",
						"     DF_max_id as integer (1)",
						"}",
						"source(output(",
						"          AgentCode as string,",
						"          AgentName as string,",
						"          GroupCode as string,",
						"          AgentStatus as string,",
						"          StartDate as date,",
						"          EndDate as date,",
						"          AgentOffice as string,",
						"          RenewalNoticeDays as integer,",
						"          AuditExclusion as string,",
						"          AuditThreshold as decimal(8,0),",
						"          IssuanceGroup as string,",
						"          DefaultBusinessDivisionID as integer,",
						"          DefaultPricingProductID as integer,",
						"          OfficeID as integer,",
						"          EMail as string,",
						"          AgentAddress1 as string,",
						"          AgentAddress2 as string,",
						"          AgentAddress3 as string,",
						"          AgentCity as string,",
						"          AgentState as string,",
						"          AgentZipCode as string,",
						"          AgentPhone as string,",
						"          AgentCounty as string,",
						"          AgentContact as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> agencySource",
						"source(output(",
						"          AGENCY_ID as long,",
						"          AGENCY_VID as long,",
						"          AGENCY_GEN_ADDRESS_ID as long,",
						"          AGENCY_CODE as string,",
						"          AGENCY_NAME as string,",
						"          AGENCY_STATUS as string,",
						"          AGENCY_CATEGORY as string,",
						"          DIRECT_BILL_FLAG_YN as string,",
						"          TELEPHONE as string,",
						"          FAX as string,",
						"          EMAIL_ID as string,",
						"          WEBSITE as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          ENTITY_TYPE as string,",
						"          ENTITY_PARENT_ID as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> agencySourceLookup",
						"derivedOtherRequiredColumns compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> metadataflowlet@(output1)",
						"agencySource select(mapColumn(",
						"          AGENCY_CODE = AgentCode,",
						"          GIVEN_AGENCY_NAME = AgentName,",
						"          AGENCY_CATEGORY = GroupCode,",
						"          AGENCY_STATUS = AgentStatus,",
						"          EMAIL_ID = EMail,",
						"          TELEPHONE = AgentPhone",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> requiredSourceAgencyColumns",
						"agencySurrogateKey derive(ENTITY_TYPE = \"AGENCY\",",
						"          AGENCY_ID = skey + $DF_max_id,",
						"          AGENCY_VID = 1) ~> derivedOtherRequiredColumns",
						"groupByAgencyName keyGenerate(output(skey as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> agencySurrogateKey",
						"agencySourceLookup select(mapColumn(",
						"          AGENCY_CODE",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> requiredStagingAgencyColumns",
						"requiredSourceAgencyColumns derive(AGENCY_NAME = trim(GIVEN_AGENCY_NAME)) ~> deriveAgencyName",
						"deriveAgencyName aggregate(groupBy(AGENCY_NAME),",
						"     each(match(name!='AGENCY_NAME'), $$ = first($$))) ~> groupByAgencyName",
						"metadataflowlet@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          AGENCY_ID as long,",
						"          AGENCY_VID as long,",
						"          AGENCY_GEN_ADDRESS_ID as long,",
						"          AGENCY_CODE as string,",
						"          AGENCY_NAME as string,",
						"          AGENCY_STATUS as string,",
						"          AGENCY_CATEGORY as string,",
						"          DIRECT_BILL_FLAG_YN as string,",
						"          TELEPHONE as string,",
						"          FAX as string,",
						"          EMAIL_ID as string,",
						"          WEBSITE as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          ENTITY_TYPE as string,",
						"          ENTITY_PARENT_ID as long",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> agencyStaging"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/fl_source_addDefaultColumnFlowlet')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_agent')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_agency')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_source_cfaInsObj')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Source Stage Data Flows/txnDataFlow"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRisk",
								"type": "DatasetReference"
							},
							"name": "StagingPolicyRisk"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policy",
								"type": "DatasetReference"
							},
							"name": "StagingPolicy"
						},
						{
							"dataset": {
								"referenceName": "ds_source_PolicyAutoUnit",
								"type": "DatasetReference"
							},
							"name": "autoUnitsSource"
						},
						{
							"dataset": {
								"referenceName": "ds_source_locationAddress",
								"type": "DatasetReference"
							},
							"name": "locationAddressSource"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "StagingPolicyRiskTypeBreed"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "StagingPolicyRiskTypeName"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "StagingPolicyRiskTypeSex"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "StagingPolicyRiskTypePurchaseDate"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "StagingPolicyRiskTypeMortality"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "StagingPolicyRiskTypeUse"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "StagingPolicyRiskTypePrice"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "StagingPolicyRiskTypeRequestedLimit"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "StagingPolicyRiskTypeAge"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "StagingPolicyRiskTypeVehicleOwned"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "StagingPolicyRiskTypeRadiusClass"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "StagingPolicyRiskTypePrimaryClass"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "StagingPolicyRiskTypeSecondaryClass"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "sink3"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "sink4"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "sink5"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "sink6"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "StagingPolicyRiskTypeFleet"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "sink7"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "sink8"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "sink9"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "sink10"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "sink11"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "sink13"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "sink14"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "sink15"
						}
					],
					"transformations": [
						{
							"name": "flowlet1",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet2",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet3",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet4",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet5",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet6",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet7",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet9",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet10",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet11",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet12",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet14",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet15",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet16",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet17",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet18",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet19",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet20",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet21",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet22",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet23",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet24",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet25",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet27",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet28",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet29",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "filter1"
						},
						{
							"name": "registeredStateName"
						},
						{
							"name": "originalCostNewOfVehicle"
						},
						{
							"name": "model"
						},
						{
							"name": "autoUnitLookup"
						},
						{
							"name": "make"
						},
						{
							"name": "statedAmount"
						},
						{
							"name": "vin"
						},
						{
							"name": "registeredState"
						},
						{
							"name": "classCode"
						},
						{
							"name": "year"
						},
						{
							"name": "vehicleIsOwnedOrLeased"
						},
						{
							"name": "radiusClass"
						},
						{
							"name": "filter2"
						},
						{
							"name": "primaryClassCode"
						},
						{
							"name": "secondaryClassCode"
						},
						{
							"name": "filter3"
						},
						{
							"name": "filter4"
						},
						{
							"name": "operatorExperience"
						},
						{
							"name": "type"
						},
						{
							"name": "use"
						},
						{
							"name": "fleetPP"
						},
						{
							"name": "fleetTK"
						},
						{
							"name": "addressLookup"
						},
						{
							"name": "zipcode"
						},
						{
							"name": "territory"
						},
						{
							"name": "filter5"
						},
						{
							"name": "supplementaryType"
						},
						{
							"name": "businessUseClass"
						},
						{
							"name": "vehicleSizeClass"
						},
						{
							"name": "vehicleTypeCode"
						},
						{
							"name": "classCodeST"
						},
						{
							"name": "classCodePP"
						},
						{
							"name": "join1"
						}
					],
					"scriptLines": [
						"parameters{",
						"     policyPrefix as string (\"CFA\"),",
						"     policies as string[] (['CFA002097'])",
						"}",
						"source(output(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_NUMBER as string,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          RISK_IS_ACTIVE_YN as string,",
						"          RISK_EFF_DATE as timestamp,",
						"          RISK_EXP_DATE as timestamp,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select * from POL_RISK ',",
						"     format: 'query') ~> StagingPolicyRisk",
						"source(output(",
						"          POLICY_ID as long,",
						"          POLICY_VID as long,",
						"          REINSURANCE_DAC as string,",
						"          PREVIOUS_INSURANCE_NO_REMARKS as string,",
						"          AGENCY_ID as long,",
						"          AGENCY_OVID as long,",
						"          PRODUCER_ID as long,",
						"          PRODUCER_OVID as long,",
						"          PRODUCER_CONTACT_ID as long,",
						"          PRODUCER_CONTACT_OVID as long,",
						"          POLICY_NUMBER as string,",
						"          ENTITY_TYPE as string,",
						"          ENTITY_STATUS as string,",
						"          IS_RENEWAL_YN as string,",
						"          REVISION_NUMBER as integer,",
						"          PRODUCT_ID as long,",
						"          PRODUCT_OVID as long,",
						"          POLICY_EFFECTIVE_DATE as timestamp,",
						"          POLICY_EXPIRATION_DATE as timestamp,",
						"          NON_RENEWAL_CODE as string,",
						"          POLICY_RENEWED_YN as string,",
						"          CANCELLATION_DATE as timestamp,",
						"          IS_RENEWABLE_YN as string,",
						"          PREVIOUS_INSURANCE_NO_REASON as string,",
						"          POLICY_STATUS as string,",
						"          CANCEL_REASON_CODE as string,",
						"          CANCEL_REASON_DESCRIPTION as string,",
						"          CANCEL_METHOD as string,",
						"          CANCEL_METHOD_DESC as string,",
						"          LOSE_REASON_CODE as string,",
						"          LOSE_REASON_DESC as string,",
						"          DECLINATION_REASON_CODE as string,",
						"          DECLINATION_REASON_DESC as string,",
						"          NOT_WRITTEN_REASON_CODE as string,",
						"          NOT_WRITTEN_REASON_DESC as string,",
						"          POLICY_STATE_CODE as string,",
						"          PROGRAM_ID as long,",
						"          PROGRAM_OVID as long,",
						"          BILLING_TYPE_CODE as string,",
						"          UNDERWRITING_COMPANY_ID as long,",
						"          UNDERWRITING_COMPANY_OVID as long,",
						"          SUBMISSION_ID as long,",
						"          PREVIOUS_INSURANCE_YN as string,",
						"          LEGACY_POLICY_NUMBER as string,",
						"          STATE as string,",
						"          POLICY_POLICY as integer,",
						"          PAYMENT_PLAN as string,",
						"          APPLICATION_RECEIVED_DATE as timestamp,",
						"          INCEPTION_DATE as timestamp,",
						"          BILL_TYPE as string,",
						"          FORMS_LANGUAGE as string,",
						"          BASE_CURRENCY as string,",
						"          INVOICE_CURRENCY as string,",
						"          PREVIOUS_POLICY_ID as long,",
						"          PREVIOUS_POLICY_OVID as long,",
						"          REVISED_FROM_POLICY_ID as long,",
						"          REVISED_FROM_POLICY_OVID as long,",
						"          OPERATING_COMPANY_ID as long,",
						"          OPERATING_COMPANY_OVID as long,",
						"          CONVERTED_FROM_ID as long,",
						"          CONVERTED_FROM_OVID as long,",
						"          INSTALLMENT_RENEWAL as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from POL_POLICY where policy_number like '{$policyPrefix}%'\"+iif(size($policies) >0&& size($policies) ==1&&$policies[1] =='','','and policy_number in ('+dropLeft(toString(reduce($policies, \"'\", #acc + \",'\" + #item +\"'\", #result)), 2)+')')),",
						"     format: 'query') ~> StagingPolicy",
						"source(output(",
						"          PolicyPrefix as string,",
						"          Policy as string,",
						"          Policy_Sequence as string,",
						"          RowStatus as string,",
						"          EffectiveDate as timestamp,",
						"          ExpirationDate as timestamp,",
						"          LocationNumber as string,",
						"          LocationUnitNumber as string,",
						"          {UnitType/ModificationType} as string,",
						"          YearBuild as short,",
						"          UnitValue as decimal(13,0),",
						"          RiskUseCode as string,",
						"          Make as string,",
						"          Model as string,",
						"          UnitWidth as short,",
						"          ISOClassCode as string,",
						"          RiskType as string,",
						"          UnitLength as short,",
						"          PurchaseDate as timestamp,",
						"          AppraisalYear as short,",
						"          UnitDescription as string,",
						"          AnimalUseCode as string,",
						"          LeaseFlag as string,",
						"          AppraisalFlag as string,",
						"          RegistrationState as string,",
						"          VehicleID as string,",
						"          EngineDisplacement as short,",
						"          FuelTypeCode as string,",
						"          Layup as string,",
						"          ID as integer,",
						"          DataSource as string,",
						"          DW_InsertDate as date",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from [dbo].[PolicyAutoUnit_P]  where PolicyPrefix='{$policyPrefix}'\"+iif(size($policies) >0&& size($policies) ==1&&$policies[1] =='','','and policy in ('+dropLeft(toString(reduce($policies, \"'\", #acc + \",'\" + #item +\"'\", #result)), 2)+')')),",
						"     format: 'query') ~> autoUnitsSource",
						"source(output(",
						"          Policy as string,",
						"          Policy_Sequence as string,",
						"          PolicyPrefix as string,",
						"          ProductCode as string,",
						"          LocationNumber as string,",
						"          BuildingNumber as string,",
						"          LocationName as string,",
						"          LocationAddress1 as string,",
						"          LocationAddress2 as string,",
						"          LocationAddress3 as string,",
						"          LocationCity as string,",
						"          LocationZipCode as string,",
						"          LocationCounty as string,",
						"          Territory as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from [dbo].[Location_Address]  where PolicyPrefix='{$policyPrefix}'\"+iif(size($policies) >0&& size($policies) ==1&&$policies[1] =='','','and policy in ('+dropLeft(toString(reduce($policies, \"'\", #acc + \",'\" + #item +\"'\", #result)), 2)+')')),",
						"     format: 'query') ~> locationAddressSource",
						"registeredStateName compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet1@(output1)",
						"originalCostNewOfVehicle compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet2@(output1)",
						"model compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet3@(output1)",
						"make compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet4@(output1)",
						"vin compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet5@(output1)",
						"statedAmount compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet6@(output1)",
						"classCode compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet7@(output1)",
						"registeredState compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet9@(output1)",
						"year compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet10@(output1)",
						"vehicleIsOwnedOrLeased compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet11@(output1)",
						"radiusClass compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet12@(output1)",
						"primaryClassCode compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet14@(output1)",
						"secondaryClassCode compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet15@(output1)",
						"use compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet16@(output1)",
						"type compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet17@(output1)",
						"operatorExperience compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet18@(output1)",
						"fleetPP compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet19@(output1)",
						"fleetTK compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet20@(output1)",
						"territory compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet21@(output1)",
						"zipcode compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet22@(output1)",
						"supplementaryType compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet23@(output1)",
						"businessUseClass compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet24@(output1)",
						"vehicleSizeClass compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet25@(output1)",
						"vehicleTypeCode compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet27@(output1)",
						"classCodeST compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet28@(output1)",
						"classCodePP compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet29@(output1)",
						"addressLookup filter(not(isNull(POLICY_NUMBER))) ~> filter1",
						"filter1 derive(RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = RISK_CODE,",
						"          ATTRIBUTE_NAME = \"registeredState_Name\",",
						"          ATTRIBUTE_VALUE = RegistrationState) ~> registeredStateName",
						"filter1 derive(RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = AnimalUseCode,",
						"          ATTRIBUTE_NAME = 'OriginalCostNewOfVehicle',",
						"          ATTRIBUTE_VALUE = UnitValue) ~> originalCostNewOfVehicle",
						"filter1 derive(RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISKCODE = RiskUseCode,",
						"          ATTRIBUTE_NAME = \"Model\",",
						"          ATTRIBUTE_VALUE = trim(Model)) ~> model",
						"join1, autoUnitsSource lookup(POLICY_NUMBER == Policy",
						"     && split(RISK_NUMBER,'-')[1] == LocationNumber",
						"     && split(RISK_NUMBER,'-')[2] == LocationUnitNumber,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> autoUnitLookup",
						"filter1 derive(RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = '',",
						"          ATTRIBUTE_NAME = 'Make',",
						"          ATTRIBUTE_VALUE = trim(Make)) ~> make",
						"filter1 derive(RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = '',",
						"          ATTRIBUTE_NAME = 'StatedAmount',",
						"          ATTRIBUTE_VALUE = 0) ~> statedAmount",
						"filter1 derive(RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = '',",
						"          ATTRIBUTE_NAME = 'Vin',",
						"          ATTRIBUTE_VALUE = VehicleID) ~> vin",
						"filter1 derive(RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = '',",
						"          ATTRIBUTE_NAME = 'RegisteredState',",
						"          ATTRIBUTE_VALUE = RegistrationState) ~> registeredState",
						"filter1 derive(RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = '',",
						"          ATTRIBUTE_NAME = 'ClassCode',",
						"          ATTRIBUTE_VALUE = ISOClassCode) ~> classCode",
						"filter1 derive(RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = \"\",",
						"          ATTRIBUTE_NAME = \"Year\",",
						"          ATTRIBUTE_VALUE = YearBuild) ~> year",
						"filter1 derive(RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = \"\",",
						"          ATTRIBUTE_NAME = 'VehicleIsOwnedOrLeased',",
						"          ATTRIBUTE_VALUE = iif(isNull(LeaseFlag) || trim(LeaseFlag)=='', '', LeaseFlag)) ~> vehicleIsOwnedOrLeased",
						"filter2 derive(ATTRIBUTE_NAME = 'RadiusClass',",
						"          ATTRIBUTE_VALUE = substring(ISOClassCode, 3,1),",
						"          RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = '') ~> radiusClass",
						"filter3 filter(in(['HT','LT','MT','MH','TR','TK','TT','VP','TC','TL','XT'], RiskType)) ~> filter2",
						"filter2 derive(ATTRIBUTE_NAME = 'PrimaryClassCode',",
						"          ATTRIBUTE_VALUE = substring(ISOClassCode, 1,3),",
						"          RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = '') ~> primaryClassCode",
						"filter2 derive(ATTRIBUTE_NAME = 'SecondaryClassCode',",
						"          ATTRIBUTE_VALUE = substring(ISOClassCode, 4,5),",
						"          RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = '') ~> secondaryClassCode",
						"filter1 filter(not(isNull(POLICY_NUMBER))) ~> filter3",
						"filter3 filter(in(['SU', 'PV'], RiskType)) ~> filter4",
						"filter4 derive(RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = '',",
						"          ATTRIBUTE_NAME = 'OperatorExperience',",
						"          ATTRIBUTE_VALUE = 'No Operator Licensed Less Than Five Years') ~> operatorExperience",
						"filter4 derive(RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = '',",
						"          ATTRIBUTE_NAME = 'Type',",
						"          ATTRIBUTE_VALUE = 'Personal Use or Farm Use - Nonfleet Vehicle') ~> type",
						"filter4 derive(RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = '',",
						"          ATTRIBUTE_NAME = 'Use',",
						"          ATTRIBUTE_VALUE = RiskUseCode) ~> use",
						"filter4 derive(ATTRIBUTE_NAME = 'Fleet',",
						"          ATTRIBUTE_VALUE = 'No',",
						"          RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = '') ~> fleetPP",
						"filter2 derive(ATTRIBUTE_NAME = 'Fleet',",
						"          ATTRIBUTE_VALUE = iif(toInteger(substring(ISOClassCode, 3,1))>3, 'Yes', 'No')) ~> fleetTK",
						"autoUnitLookup, locationAddressSource lookup(POLICY_NUMBER == locationAddressSource@Policy",
						"     && autoUnitsSource@LocationNumber == locationAddressSource@LocationNumber,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> addressLookup",
						"filter1 derive(ATTRIBUTE_NAME = 'Zipcode',",
						"          ATTRIBUTE_VALUE = LocationZipCode,",
						"          RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = '') ~> zipcode",
						"filter1 derive(ATTRIBUTE_NAME = 'Territory',",
						"          ATTRIBUTE_VALUE = Territory,",
						"          RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = '') ~> territory",
						"filter3 filter(!in(['HT','LT','MT','MH','TR','TK','TT','VP','TC','TL','XT', 'PV', 'SU'], RiskType)) ~> filter5",
						"filter5 derive(ATRRIBUTE_NAME = 'SupplementaryType',",
						"          ATRRIBUTE_VALUE = '',",
						"          RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = '') ~> supplementaryType",
						"filter2 derive(ATTRIBUTE_NAME = 'BusinessUseClass',",
						"          ATTRIBUTE_VALUE = RiskUseCode,",
						"          RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = '') ~> businessUseClass",
						"filter2 derive(ATTRIBUTE_NAME = 'vehicleSizeClass',",
						"          ATTRIBUTE_VALUE = RiskType,",
						"          RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = '') ~> vehicleSizeClass",
						"filter1 derive(RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = '',",
						"          ATTRIBUTE_NAME = 'VehicleTypeCode',",
						"          ATTRIBUTE_VALUE = RiskType) ~> vehicleTypeCode",
						"filter5 derive(RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = '',",
						"          ATTRIBUTE_NAME = 'ClassCode',",
						"          ATTRIBUTE_VALUE = ISOClassCode) ~> classCodeST",
						"filter4 derive(RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = '',",
						"          ATTRIBUTE_NAME = 'ClassCode',",
						"          ATTRIBUTE_VALUE = ISOClassCode) ~> classCodePP",
						"StagingPolicyRisk, StagingPolicy join(StagingPolicyRisk@POLICY_ID == StagingPolicy@POLICY_ID,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"flowlet1@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> StagingPolicyRiskTypeBreed",
						"flowlet2@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> StagingPolicyRiskTypeName",
						"flowlet3@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> StagingPolicyRiskTypeSex",
						"flowlet5@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> StagingPolicyRiskTypePurchaseDate",
						"flowlet6@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> StagingPolicyRiskTypeMortality",
						"flowlet4@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> StagingPolicyRiskTypeUse",
						"flowlet9@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> StagingPolicyRiskTypePrice",
						"flowlet7@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> StagingPolicyRiskTypeRequestedLimit",
						"flowlet10@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> StagingPolicyRiskTypeAge",
						"flowlet11@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> StagingPolicyRiskTypeVehicleOwned",
						"flowlet12@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> StagingPolicyRiskTypeRadiusClass",
						"flowlet14@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> StagingPolicyRiskTypePrimaryClass",
						"flowlet15@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> StagingPolicyRiskTypeSecondaryClass",
						"flowlet18@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink3",
						"flowlet17@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink4",
						"flowlet16@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink5",
						"flowlet19@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink6",
						"flowlet20@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> StagingPolicyRiskTypeFleet",
						"flowlet22@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink7",
						"flowlet21@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink8",
						"flowlet23@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink9",
						"flowlet24@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink10",
						"flowlet25@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink11",
						"flowlet27@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink13",
						"flowlet28@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink14",
						"flowlet29@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink15"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/fl_source_addDefaultColumnFlowlet')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_policyRisk')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_policy')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_PolicyAutoUnit')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_locationAddress')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_policyRiskDetails')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_source_coverage')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Source Stage Data Flows/txnDataFlow"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_policyCoverage",
								"type": "DatasetReference"
							},
							"name": "policyCoverageSource"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policy",
								"type": "DatasetReference"
							},
							"name": "policyStaging"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_coverageCode",
								"type": "DatasetReference"
							},
							"name": "coverageCodeStaging"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_coverage",
								"type": "DatasetReference"
							},
							"name": "coverageStagingLookup"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_coverage",
								"type": "DatasetReference"
							},
							"name": "coverageStagingMaxId"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_coverage",
								"type": "DatasetReference"
							},
							"name": "coverageStaging"
						},
						{
							"name": "maxIdCache"
						}
					],
					"transformations": [
						{
							"name": "flowlet1",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "select1"
						},
						{
							"name": "select2"
						},
						{
							"name": "policyJoin"
						},
						{
							"name": "select3"
						},
						{
							"name": "coverageCodeJoin"
						},
						{
							"name": "select4"
						},
						{
							"name": "surrogateKey1"
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "exists1"
						}
					],
					"scriptLines": [
						"parameters{",
						"     policyPrefix as string,",
						"     policies as string[]",
						"}",
						"source(output(",
						"          Policy as string,",
						"          ARICCoverageDescription as string,",
						"          Cov_effective_Date as timestamp,",
						"          Cov_Expiry_Date as timestamp,",
						"          CoverageDescription as string,",
						"          ARICLOB as string,",
						"          ARICCOverageCode as string,",
						"          ARICCoverageSequence as integer,",
						"          ARICGroupCode as string,",
						"          PrimaryPremiumStateCode as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select distinct Policy, ARICCoverageDescription ,Cov_effective_Date, Cov_Expiry_Date, CoverageDescription, ARICLOB, ARICCOverageCode, ARICCoverageSequence, ARICGroupCode, PrimaryPremiumStateCode from [dbo].[Policy_Coverage] where PolicyPrefix = '{$policyPrefix}'\"+iif(size($policies) >0&& size($policies) ==1&&$policies[1] =='','','and policy in ('+dropLeft(toString(reduce($policies, \"'\", #acc + \",'\" + #item +\"'\", #result)), 2)+')')),",
						"     format: 'query') ~> policyCoverageSource",
						"source(output(",
						"          POLICY_ID as long,",
						"          POLICY_VID as long,",
						"          REINSURANCE_DAC as string,",
						"          PREVIOUS_INSURANCE_NO_REMARKS as string,",
						"          AGENCY_ID as long,",
						"          AGENCY_OVID as long,",
						"          PRODUCER_ID as long,",
						"          PRODUCER_OVID as long,",
						"          PRODUCER_CONTACT_ID as long,",
						"          PRODUCER_CONTACT_OVID as long,",
						"          POLICY_NUMBER as string,",
						"          ENTITY_TYPE as string,",
						"          ENTITY_STATUS as string,",
						"          IS_RENEWAL_YN as string,",
						"          REVISION_NUMBER as integer,",
						"          PRODUCT_ID as long,",
						"          PRODUCT_OVID as long,",
						"          POLICY_EFFECTIVE_DATE as timestamp,",
						"          POLICY_EXPIRATION_DATE as timestamp,",
						"          NON_RENEWAL_CODE as string,",
						"          POLICY_RENEWED_YN as string,",
						"          CANCELLATION_DATE as timestamp,",
						"          IS_RENEWABLE_YN as string,",
						"          PREVIOUS_INSURANCE_NO_REASON as string,",
						"          POLICY_STATUS as string,",
						"          CANCEL_REASON_CODE as string,",
						"          CANCEL_REASON_DESCRIPTION as string,",
						"          CANCEL_METHOD as string,",
						"          CANCEL_METHOD_DESC as string,",
						"          LOSE_REASON_CODE as string,",
						"          LOSE_REASON_DESC as string,",
						"          DECLINATION_REASON_CODE as string,",
						"          DECLINATION_REASON_DESC as string,",
						"          NOT_WRITTEN_REASON_CODE as string,",
						"          NOT_WRITTEN_REASON_DESC as string,",
						"          POLICY_STATE_CODE as string,",
						"          PROGRAM_ID as long,",
						"          PROGRAM_OVID as long,",
						"          BILLING_TYPE_CODE as string,",
						"          UNDERWRITING_COMPANY_ID as long,",
						"          UNDERWRITING_COMPANY_OVID as long,",
						"          SUBMISSION_ID as long,",
						"          PREVIOUS_INSURANCE_YN as string,",
						"          LEGACY_POLICY_NUMBER as string,",
						"          STATE as string,",
						"          POLICY_POLICY as integer,",
						"          PAYMENT_PLAN as string,",
						"          APPLICATION_RECEIVED_DATE as timestamp,",
						"          INCEPTION_DATE as timestamp,",
						"          BILL_TYPE as string,",
						"          FORMS_LANGUAGE as string,",
						"          BASE_CURRENCY as string,",
						"          INVOICE_CURRENCY as string,",
						"          PREVIOUS_POLICY_ID as long,",
						"          PREVIOUS_POLICY_OVID as long,",
						"          REVISED_FROM_POLICY_ID as long,",
						"          REVISED_FROM_POLICY_OVID as long,",
						"          OPERATING_COMPANY_ID as long,",
						"          OPERATING_COMPANY_OVID as long,",
						"          CONVERTED_FROM_ID as long,",
						"          CONVERTED_FROM_OVID as long,",
						"          INSTALLMENT_RENEWAL as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> policyStaging",
						"source(output(",
						"          COVERAGE_CODE_ID as long,",
						"          COVERAGE_CODE as string,",
						"          COVERAGE_DESCRIPTION as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> coverageCodeStaging",
						"source(output(",
						"          COVERAGE_ID as long,",
						"          COVERAGE_VID as long,",
						"          COVERAGE_CODE_ID as long,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          COV_STATE_ID as long,",
						"          COVERAGE_EFFECTIVE_DATE as timestamp,",
						"          COVERAGE_EXPIRATION_DATE as timestamp,",
						"          ASL_CODE as string,",
						"          ASSL_CODE as string,",
						"          ASL_CODE_GBL as string,",
						"          ASSL_CODE_GBL as string,",
						"          CLASSIFICATION_CODE_ID as long,",
						"          CLASSIFICATION_CODE_OVID as long,",
						"          COVERAGE_CODE as string,",
						"          RETROACTIVE_DATE as timestamp,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> coverageStagingLookup",
						"source(output(",
						"          maxId as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT isnull(MAX(COVERAGE_ID), 0) as maxId\\nFROM dbo.POL_COVERAGE',",
						"     format: 'query') ~> coverageStagingMaxId",
						"derivedColumn1 compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet1@(output1)",
						"policyCoverageSource select(mapColumn(",
						"          Policy,",
						"          ARICCoverageDescription,",
						"          COVERAGE_LINE = CoverageDescription,",
						"          COVERAGE_EFFECTIVE_DATE = Cov_effective_Date,",
						"          COVERAGE_EXPIRATION_DATE = Cov_Expiry_Date,",
						"          ARICLOB,",
						"          ARICCoverageCode = ARICCOverageCode,",
						"          ARICCoverageSequence,",
						"          ARICGroupCode,",
						"          PrimaryPremiumStateCode",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"policyStaging select(mapColumn(",
						"          POLICY_ID,",
						"          POLICY_OVID = POLICY_VID,",
						"          POLICY_NUMBER",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select2",
						"exists1, select2 join(Policy == POLICY_NUMBER,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> policyJoin",
						"coverageCodeStaging select(mapColumn(",
						"          COVERAGE_CODE_ID,",
						"          COVERAGE_CODE,",
						"          COVERAGE_DESCRIPTION",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select3",
						"policyJoin, select3 join(ARICCoverageDescription == COVERAGE_DESCRIPTION,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> coverageCodeJoin",
						"coverageCodeJoin select(mapColumn(",
						"          COVERAGE_EFFECTIVE_DATE,",
						"          COVERAGE_EXPIRATION_DATE,",
						"          POLICY_ID,",
						"          POLICY_OVID,",
						"          COVERAGE_CODE_ID,",
						"          ARICLOB,",
						"          ARICCoverageCode,",
						"          ARICCoverageSequence,",
						"          ARICGroupCode,",
						"          PrimaryPremiumStateCode,",
						"          Policy",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select4",
						"select4 keyGenerate(output(skey as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> surrogateKey1",
						"surrogateKey1 derive(COVERAGE_ID = skey + maxIdCache#outputs()[1].maxId,",
						"          COVERAGE_VID = 1,",
						"          COVERAGE_CODE = concatWS('-', iif(isNull(ARICGroupCode), '', replace(ARICGroupCode, ' ', '')), iif(isNull(PrimaryPremiumStateCode), '', replace(PrimaryPremiumStateCode, ' ', '')) , iif(isNull(ARICLOB), '', replace(ARICLOB, ' ', '')), iif(isNull(ARICCoverageCode), '', replace(ARICCoverageCode, ' ', '')), toString(ARICCoverageSequence)),",
						"          SOURCE_KEY = concatWS('', Policy, iif(isNull(ARICGroupCode), '', replace(ARICGroupCode, ' ', '')), iif(isNull(PrimaryPremiumStateCode), '', replace(PrimaryPremiumStateCode, ' ', '')) , iif(isNull(ARICLOB), '', replace(ARICLOB, ' ', '')), iif(isNull(ARICCoverageCode), '', replace(ARICCoverageCode, ' ', '')), toString(ARICCoverageSequence))) ~> derivedColumn1",
						"select1, coverageStagingLookup exists(concatWS('', Policy, iif(isNull(ARICGroupCode), '', replace(ARICGroupCode, ' ', '')), iif(isNull(PrimaryPremiumStateCode), '', replace(PrimaryPremiumStateCode, ' ', '')) , iif(isNull(ARICLOB), '', replace(ARICLOB, ' ', '')), iif(isNull(ARICCoverageCode), '', replace(ARICCoverageCode, ' ', '')), toString(ARICCoverageSequence)) == SOURCE_KEY,",
						"     negate:true,",
						"     broadcast: 'auto')~> exists1",
						"flowlet1@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          COVERAGE_ID as long,",
						"          COVERAGE_VID as long,",
						"          COVERAGE_CODE_ID as long,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          COV_STATE_ID as long,",
						"          COVERAGE_EFFECTIVE_DATE as timestamp,",
						"          COVERAGE_EXPIRATION_DATE as timestamp,",
						"          ASL_CODE as string,",
						"          ASSL_CODE as string,",
						"          ASL_CODE_GBL as string,",
						"          ASSL_CODE_GBL as string,",
						"          CLASSIFICATION_CODE_ID as long,",
						"          CLASSIFICATION_CODE_OVID as long,",
						"          COVERAGE_CODE as string,",
						"          RETROACTIVE_DATE as timestamp,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> coverageStaging",
						"coverageStagingMaxId sink(validateSchema: false,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     store: 'cache',",
						"     format: 'inline',",
						"     output: false,",
						"     saveOrder: 1) ~> maxIdCache"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/fl_source_addDefaultColumnFlowlet')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_policyCoverage')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_policy')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_coverageCode')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_coverage')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_source_coverageCode')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Source Stage Data Flows/txnDataFlow"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_policyCoverage",
								"type": "DatasetReference"
							},
							"name": "policyCoverageSource"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_coverageCode",
								"type": "DatasetReference"
							},
							"name": "pkey"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_coverageCode",
								"type": "DatasetReference"
							},
							"name": "coverageCodeStaging"
						},
						{
							"name": "ssCoverCodPkeyCache"
						}
					],
					"transformations": [
						{
							"name": "flowlet1",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "select1"
						},
						{
							"name": "surrogateKey1"
						},
						{
							"name": "derivedColumn1"
						}
					],
					"scriptLines": [
						"parameters{",
						"     policyPrefix as string ('CFA')",
						"}",
						"source(output(",
						"          Policy as string,",
						"          Policy_Sequence as string,",
						"          ARICLOB as string,",
						"          ARICGroupCode as string,",
						"          Description as string,",
						"          Product as string,",
						"          ARICCoverageCode as string,",
						"          ARICCoverageDescription as string,",
						"          EndorsementNumber as integer,",
						"          LocationNumber as string,",
						"          LocationUnitNumber as string,",
						"          BuildingNumber as string,",
						"          LocationName as string,",
						"          LocationAddress1 as string,",
						"          LocationAddress2 as string,",
						"          LocationAddress3 as string,",
						"          Occupancy as string,",
						"          LocationCity as string,",
						"          LocationZipCode as string,",
						"          LocationCounty as string,",
						"          Territory as string,",
						"          ConstructionCode as string,",
						"          ConstructionYear as integer,",
						"          NumberOfFloors as integer,",
						"          ProtectionClass as string,",
						"          GEOLatitude as decimal(11,8),",
						"          GEOLongitude as decimal(11,8),",
						"          CauseOfLoss as string,",
						"          BCEGClassCode as string,",
						"          CoverageForm as string,",
						"          DesignatedPremisis as string,",
						"          WindIndicatorFlag as string,",
						"          PurchaseCost as decimal(8,2),",
						"          dbo as string,",
						"          CoInsuranceBuilding as integer,",
						"          CoInsurancePersonalProperty as integer,",
						"          CoInsuranceBodilyInjury as integer,",
						"          CountryCode as string,",
						"          MunicipalityCode as string,",
						"          ParkName as string,",
						"          CountyCode as integer,",
						"          NumberParkSpaces as integer,",
						"          NumberOfAcres as integer,",
						"          OwnOrRent as string,",
						"          ResidenceTypeCode as string,",
						"          LocationZone as string,",
						"          ARICCoverageSequence as integer,",
						"          CoveragePart as string,",
						"          CoverageAddDate as timestamp,",
						"          CoverageDescription as string,",
						"          ISOClassCode as string,",
						"          RetroEndorsementNumber as integer,",
						"          PolicyPrefix as string,",
						"          EffectiveDate as timestamp,",
						"          Policy_Accounting_date as timestamp,",
						"          ExpirationDate as timestamp,",
						"          CancelDate as timestamp,",
						"          CancelReason as string,",
						"          CancelReasonDescription as string,",
						"          PolicyTermMonths as integer,",
						"          InsuredName as string,",
						"          InsuredAddress1 as string,",
						"          InsuredAddress2 as string,",
						"          InsuredCity as string,",
						"          InsuredState as string,",
						"          InsuredZipCode as string,",
						"          CompanyCode as string,",
						"          CompanyName as string,",
						"          GroupName as string,",
						"          GBLICompanyCode as string,",
						"          AgentCode as string,",
						"          AgentName as string,",
						"          AgentOffice as string,",
						"          GroupCode as string,",
						"          AgentCity as string,",
						"          EMail as string,",
						"          AgentPhone as string,",
						"          AgentCounty as string,",
						"          AgentZipCode as string,",
						"          AgentAddress1 as string,",
						"          AgentAddress2 as string,",
						"          AgentState as string,",
						"          SubProducerNumber as string,",
						"          SubProducerCode as string,",
						"          SubProducerName as string,",
						"          SubproducerState as string,",
						"          SubProducerType as string,",
						"          ProductCode as string,",
						"          ProductCodeDescription as string,",
						"          PreviousPolicy as string,",
						"          OriginalPolicyYear as integer,",
						"          NonRenewalReason as string,",
						"          NonRenewalNoticeDate as timestamp,",
						"          DatabaseCode as string,",
						"          Policy_ID as integer,",
						"          MinimumPremium as decimal(13,0),",
						"          POlicy_Receive_date as timestamp,",
						"          MasterPolicy as string,",
						"          BillingType as string,",
						"          RowStatus as string,",
						"          OriginalInceptionDate as timestamp,",
						"          MultiplePolicyFlag as string,",
						"          ARICBusinessUnit as string,",
						"          HonorCurrentRateFlag as string,",
						"          FarmType as string,",
						"          PrimaryPremiumStateCode as string,",
						"          StateName as string,",
						"          Policy_Insert_Date as date,",
						"          BillingSystem as string,",
						"          Cov_effective_Date as timestamp,",
						"          Cov_Expiry_Date as timestamp,",
						"          ReceivedDate as date,",
						"          CoverageArrayNumber as integer,",
						"          LiabilityFlag as string,",
						"          ExperienceModFactor as decimal(7,4),",
						"          Exposure as decimal(8,0),",
						"          TaxFeeSurchargeFlag as string,",
						"          CancelReinstateFlag as string,",
						"          ReleasedFlag as string,",
						"          ReleaseDate as date,",
						"          Rate as decimal(12,6),",
						"          PremiumStateCode as string,",
						"          Coverage_ID as integer,",
						"          Coverage_accounting_date as timestamp,",
						"          Coverage_Insert_Date as date",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"SELECT distinct ARICCoverageCode,ARICCoverageDescription FROM [DataStoreARICECM].[dbo].[Policy_Coverage] where PolicyPrefix ='{$policyPrefix}'\"),",
						"     format: 'query') ~> policyCoverageSource",
						"source(output(",
						"          cid as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select MAX(COVERAGE_CODE_ID) as cid from POL_COVERAGE_CODE',",
						"     format: 'query') ~> pkey",
						"derivedColumn1 compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet1@(output1)",
						"policyCoverageSource select(mapColumn(",
						"          COVERAGE_CODE = ARICCoverageCode,",
						"          COVERAGE_DESCRIPTION = ARICCoverageDescription",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"select1 keyGenerate(output(skey as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> surrogateKey1",
						"surrogateKey1 derive(COVERAGE_CODE_ID = skey + ssCoverCodPkeyCache#outputs()[1].cid) ~> derivedColumn1",
						"flowlet1@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          COVERAGE_CODE_ID as long,",
						"          COVERAGE_CODE as string,",
						"          COVERAGE_DESCRIPTION as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> coverageCodeStaging",
						"pkey sink(validateSchema: false,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     store: 'cache',",
						"     format: 'inline',",
						"     output: false,",
						"     saveOrder: 1) ~> ssCoverCodPkeyCache"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/fl_source_addDefaultColumnFlowlet')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_policyCoverage')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_coverageCode')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_source_coverageExt')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Source Stage Data Flows/txnDataFlow"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_coverage",
								"type": "DatasetReference"
							},
							"name": "coverageStaging"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policy",
								"type": "DatasetReference"
							},
							"name": "policyStaging"
						},
						{
							"dataset": {
								"referenceName": "ds_source_policyCoverage",
								"type": "DatasetReference"
							},
							"name": "policySource"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_coverageExt",
								"type": "DatasetReference"
							},
							"name": "coverageExtStaging"
						}
					],
					"transformations": [
						{
							"name": "select1"
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "sourcePolicyCoveragelookup"
						},
						{
							"name": "policyStagingSelect"
						},
						{
							"name": "policyCoverageMapping"
						},
						{
							"name": "policySourceSelect"
						},
						{
							"name": "stagingCoveragePolicyJoin"
						}
					],
					"scriptLines": [
						"parameters{",
						"     policyPrefix as string ('CFA'),",
						"     policies as string[]",
						"}",
						"source(output(",
						"          COVERAGE_ID as long,",
						"          COVERAGE_VID as long,",
						"          COVERAGE_CODE_ID as long,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          COV_STATE_ID as long,",
						"          COVERAGE_EFFECTIVE_DATE as timestamp,",
						"          COVERAGE_EXPIRATION_DATE as timestamp,",
						"          ASL_CODE as string,",
						"          ASSL_CODE as string,",
						"          ASL_CODE_GBL as string,",
						"          ASSL_CODE_GBL as string,",
						"          CLASSIFICATION_CODE_ID as long,",
						"          CLASSIFICATION_CODE_OVID as long,",
						"          COVERAGE_CODE as string,",
						"          RETROACTIVE_DATE as timestamp,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select * from [DM_Source_Stage].[dbo].[POL_COVERAGE] ',",
						"     format: 'query') ~> coverageStaging",
						"source(output(",
						"          POLICY_ID as long,",
						"          POLICY_VID as long,",
						"          REINSURANCE_DAC as string,",
						"          PREVIOUS_INSURANCE_NO_REMARKS as string,",
						"          AGENCY_ID as long,",
						"          AGENCY_OVID as long,",
						"          PRODUCER_ID as long,",
						"          PRODUCER_OVID as long,",
						"          PRODUCER_CONTACT_ID as long,",
						"          PRODUCER_CONTACT_OVID as long,",
						"          POLICY_NUMBER as string,",
						"          ENTITY_TYPE as string,",
						"          ENTITY_STATUS as string,",
						"          IS_RENEWAL_YN as string,",
						"          REVISION_NUMBER as integer,",
						"          PRODUCT_ID as long,",
						"          PRODUCT_OVID as long,",
						"          POLICY_EFFECTIVE_DATE as timestamp,",
						"          POLICY_EXPIRATION_DATE as timestamp,",
						"          NON_RENEWAL_CODE as string,",
						"          POLICY_RENEWED_YN as string,",
						"          CANCELLATION_DATE as timestamp,",
						"          IS_RENEWABLE_YN as string,",
						"          PREVIOUS_INSURANCE_NO_REASON as string,",
						"          POLICY_STATUS as string,",
						"          CANCEL_REASON_CODE as string,",
						"          CANCEL_REASON_DESCRIPTION as string,",
						"          CANCEL_METHOD as string,",
						"          CANCEL_METHOD_DESC as string,",
						"          LOSE_REASON_CODE as string,",
						"          LOSE_REASON_DESC as string,",
						"          DECLINATION_REASON_CODE as string,",
						"          DECLINATION_REASON_DESC as string,",
						"          NOT_WRITTEN_REASON_CODE as string,",
						"          NOT_WRITTEN_REASON_DESC as string,",
						"          POLICY_STATE_CODE as string,",
						"          PROGRAM_ID as long,",
						"          PROGRAM_OVID as long,",
						"          BILLING_TYPE_CODE as string,",
						"          UNDERWRITING_COMPANY_ID as long,",
						"          UNDERWRITING_COMPANY_OVID as long,",
						"          SUBMISSION_ID as long,",
						"          PREVIOUS_INSURANCE_YN as string,",
						"          LEGACY_POLICY_NUMBER as string,",
						"          STATE as string,",
						"          POLICY_POLICY as integer,",
						"          PAYMENT_PLAN as string,",
						"          APPLICATION_RECEIVED_DATE as timestamp,",
						"          INCEPTION_DATE as timestamp,",
						"          BILL_TYPE as string,",
						"          FORMS_LANGUAGE as string,",
						"          BASE_CURRENCY as string,",
						"          INVOICE_CURRENCY as string,",
						"          PREVIOUS_POLICY_ID as long,",
						"          PREVIOUS_POLICY_OVID as long,",
						"          REVISED_FROM_POLICY_ID as long,",
						"          REVISED_FROM_POLICY_OVID as long,",
						"          OPERATING_COMPANY_ID as long,",
						"          OPERATING_COMPANY_OVID as long,",
						"          CONVERTED_FROM_ID as long,",
						"          CONVERTED_FROM_OVID as long,",
						"          INSTALLMENT_RENEWAL as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from [dbo].[POL_POLICY] where ENTITY_TYPE ='{$policyPrefix}' \"+iif(size($policies) >0&& size($policies) ==1&&$policies[1] =='','','and policy_number in ('+dropLeft(toString(reduce($policies, \"'\", #acc + \",'\" + #item +\"'\", #result)), 2)+')')),",
						"     format: 'query') ~> policyStaging",
						"source(output(",
						"          Policy as string,",
						"          Policy_Sequence as string,",
						"          ARICLOB as string,",
						"          ARICGroupCode as string,",
						"          Description as string,",
						"          Product as string,",
						"          ARICCoverageCode as string,",
						"          ARICCoverageDescription as string,",
						"          EndorsementNumber as short,",
						"          LocationNumber as string,",
						"          LocationUnitNumber as string,",
						"          BuildingNumber as string,",
						"          LocationName as string,",
						"          LocationAddress1 as string,",
						"          LocationAddress2 as string,",
						"          LocationAddress3 as string,",
						"          Occupancy as string,",
						"          LocationCity as string,",
						"          LocationZipCode as string,",
						"          LocationCounty as string,",
						"          Territory as string,",
						"          ConstructionCode as string,",
						"          ConstructionYear as integer,",
						"          NumberOfFloors as integer,",
						"          ProtectionClass as string,",
						"          GEOLatitude as decimal(11,8),",
						"          GEOLongitude as decimal(11,8),",
						"          CauseOfLoss as string,",
						"          BCEGClassCode as string,",
						"          CoverageForm as string,",
						"          DesignatedPremisis as string,",
						"          WindIndicatorFlag as string,",
						"          PurchaseCost as decimal(8,2),",
						"          dbo as string,",
						"          CoInsuranceBuilding as integer,",
						"          CoInsurancePersonalProperty as integer,",
						"          CoInsuranceBodilyInjury as integer,",
						"          CountryCode as string,",
						"          MunicipalityCode as string,",
						"          ParkName as string,",
						"          CountyCode as short,",
						"          NumberParkSpaces as integer,",
						"          NumberOfAcres as integer,",
						"          OwnOrRent as string,",
						"          ResidenceTypeCode as string,",
						"          LocationZone as string,",
						"          ARICCoverageSequence as integer,",
						"          CoveragePart as string,",
						"          CoverageAddDate as timestamp,",
						"          CoverageDescription as string,",
						"          CoverageInternalCode as string,",
						"          CoverageAbbreviation as string,",
						"          CoveragePartSequence as integer,",
						"          CoverageISOLine as integer,",
						"          CoverageCATCode as string,",
						"          CoverageLine4 as integer,",
						"          CoverageAddUser as string,",
						"          CoverageUpdateDate as timestamp,",
						"          CoverageUpdateUser as string,",
						"          CoverageLineFlag as string,",
						"          LocationState as string,",
						"          ISOClassCode as string,",
						"          RetroEndorsementNumber as integer,",
						"          PolicyPrefix as string,",
						"          EffectiveDate as timestamp,",
						"          Policy_Accounting_date as timestamp,",
						"          ExpirationDate as timestamp,",
						"          CancelDate as timestamp,",
						"          CancelReason as string,",
						"          CancelReasonDescription as string,",
						"          PolicyTermMonths as integer,",
						"          InsuredName as string,",
						"          InsuredAddress1 as string,",
						"          InsuredAddress2 as string,",
						"          InsuredCity as string,",
						"          InsuredState as string,",
						"          InsuredZipCode as string,",
						"          CompanyCode as string,",
						"          CompanyName as string,",
						"          GroupName as string,",
						"          GBLICompanyCode as string,",
						"          AgentCode as string,",
						"          AgentName as string,",
						"          AgentOffice as string,",
						"          GroupCode as string,",
						"          AgentCity as string,",
						"          EMail as string,",
						"          AgentPhone as string,",
						"          AgentCounty as string,",
						"          AgentZipCode as string,",
						"          AgentAddress1 as string,",
						"          AgentAddress2 as string,",
						"          AgentState as string,",
						"          SubProducerNumber as string,",
						"          SubProducerCode as string,",
						"          SubProducerName as string,",
						"          SubproducerState as string,",
						"          SubProducerType as string,",
						"          ProductCode as string,",
						"          ProductCodeDescription as string,",
						"          PreviousPolicy as string,",
						"          OriginalPolicyYear as integer,",
						"          NonRenewalReason as string,",
						"          NonRenewalNoticeDate as timestamp,",
						"          DatabaseCode as string,",
						"          Policy_ID as integer,",
						"          MinimumPremium as decimal(13,0),",
						"          POlicy_Receive_date as timestamp,",
						"          MasterPolicy as string,",
						"          BillingType as string,",
						"          RowStatus as string,",
						"          OriginalInceptionDate as timestamp,",
						"          MultiplePolicyFlag as string,",
						"          ARICBusinessUnit as string,",
						"          HonorCurrentRateFlag as string,",
						"          FarmType as string,",
						"          PrimaryPremiumStateCode as string,",
						"          StateName as string,",
						"          Policy_Insert_Date as date,",
						"          BillingSystem as string,",
						"          Cov_effective_Date as timestamp,",
						"          Cov_Expiry_Date as timestamp,",
						"          ReceivedDate as date,",
						"          CoverageArrayNumber as short,",
						"          LiabilityFlag as string,",
						"          ExperienceModFactor as decimal(7,4),",
						"          Exposure as decimal(8,0),",
						"          TaxFeeSurchargeFlag as string,",
						"          CancelReinstateFlag as string,",
						"          ReleasedFlag as string,",
						"          ReleaseDate as date,",
						"          Rate as decimal(12,6),",
						"          PremiumStateCode as string,",
						"          Coverage_ID as integer,",
						"          Coverage_accounting_date as timestamp,",
						"          Coverage_Insert_Date as date",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from [dbo].[Policy_Coverage] where PolicyPrefix = '{$policyPrefix}'\"+iif(size($policies) >0&& size($policies) ==1&&$policies[1] =='','','and policy in ('+dropLeft(toString(reduce($policies, \"'\", #acc + \",'\" + #item +\"'\", #result)), 2)+')')),",
						"     format: 'query') ~> policySource",
						"coverageStaging select(mapColumn(",
						"          COVERAGE_ID,",
						"          COVERAGE_CODE_ID,",
						"          POLICY_ID,",
						"          COVERAGE_EFFECTIVE_DATE,",
						"          COVERAGE_EXPIRATION_DATE,",
						"          COVERAGE_CODE,",
						"          COVERAGE_VID",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"stagingCoveragePolicyJoin derive(aricGrpCode = split(COVERAGE_CODE,'-')[1],",
						"          pimarypremiumstate = split(COVERAGE_CODE,'-')[2],",
						"          aricLob = split(COVERAGE_CODE,'-')[3],",
						"          aricCoverageCode = split(COVERAGE_CODE,'-')[4],",
						"          Ariccoveragecodesequnce = toString(split(COVERAGE_CODE,'-')[5]),",
						"          POLICY_NUMBER = POLICY_NUMBER) ~> derivedColumn1",
						"derivedColumn1, policySourceSelect lookup(POLICY_NUMBER == Policy",
						"     && aricGrpCode == ARICGroupCode",
						"     && pimarypremiumstate == PrimaryPremiumStateCode",
						"     && derivedColumn1@aricCoverageCode == policySourceSelect@ARICCoverageCode",
						"     && Ariccoveragecodesequnce == toString(ARICCoverageSequence),",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> sourcePolicyCoveragelookup",
						"policyStaging select(mapColumn(",
						"          POLICY_ID,",
						"          POLICY_VID,",
						"          POLICY_NUMBER",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> policyStagingSelect",
						"sourcePolicyCoveragelookup derive(COVERAGE_ID = select1@COVERAGE_ID,",
						"          COVERAGE_VID = COVERAGE_VID,",
						"          AricCoverageSequence = Ariccoveragecodesequnce,",
						"          AricGroupCode = ARICGroupCode,",
						"          CoverageDescription = CoverageDescription,",
						"          ARICLOB = policySourceSelect@ARICLOB,",
						"          CoverageInternalCode = CoverageInternalCode,",
						"          CoverageAbbreviation = CoverageAbbreviation,",
						"          CoverageArrayNumber = CoverageArrayNumber,",
						"          CoveragePart = CoveragePart,",
						"          CoverageISOLine = CoverageISOLine,",
						"          CoverageCATCode = CoverageCATCode) ~> policyCoverageMapping",
						"policySource select(skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> policySourceSelect",
						"select1, policyStagingSelect join(select1@POLICY_ID == policyStagingSelect@POLICY_ID,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> stagingCoveragePolicyJoin",
						"policyCoverageMapping sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          COVERAGE_ID as long,",
						"          COVERAGE_VID as long,",
						"          ARICCoverageSequence as integer,",
						"          ARICTaxFeeSurchargeFlag as string,",
						"          PropertyOrCasualty as string,",
						"          ARICGroupCode as string,",
						"          LocationState as string,",
						"          ARICLOB as string,",
						"          CoverageInternalCode as string,",
						"          CoverageAbbreviation as string,",
						"          CoverageDescription as string,",
						"          CoverageArrayNumber as integer,",
						"          CoveragePartSequence as integer,",
						"          CoveragePart as string,",
						"          CoverageISOLine as integer,",
						"          CoverageCATCode as string,",
						"          CoverageFullyEarned as string,",
						"          LiabilityFlag as string,",
						"          CoverageLine4 as integer,",
						"          CoverageEffectiveDate as timestamp,",
						"          CoverageExpirationDate as timestamp,",
						"          CoverageAddDate as timestamp,",
						"          CoverageAddUser as string,",
						"          CoverageUpdateDate as timestamp,",
						"          CoverageUpdateUser as string,",
						"          CoverageLineFlag as string,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> coverageExtStaging"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_coverage')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_policy')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_policyCoverage')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_coverageExt')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_source_empInsObj')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Source Stage Data Flows/txnDataFlow"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRisk",
								"type": "DatasetReference"
							},
							"name": "StagingPolicyRisk"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policy",
								"type": "DatasetReference"
							},
							"name": "StagingPolicy"
						},
						{
							"dataset": {
								"referenceName": "ds_source_propertyUnits",
								"type": "DatasetReference"
							},
							"name": "EcmPropertyUnits"
						},
						{
							"dataset": {
								"referenceName": "ds_source_propertyUnits",
								"type": "DatasetReference"
							},
							"name": "ecmWithLimits"
						},
						{
							"dataset": {
								"referenceName": "joinTableStageSQL",
								"type": "DatasetReference"
							},
							"name": "sourceRefLookUp"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "StagingPolicyRiskTypeBreed"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "StagingPolicyRiskTypeName"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "StagingPolicyRiskTypeSex"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "StagingPolicyRiskTypePurchaseDate"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "StagingPolicyRiskTypeMortality"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "StagingPolicyRiskTypeUse"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "StagingPolicyRiskTypePrice"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "StagingPolicyRiskTypeYearBorn"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "StagingPolicyRiskTypeRequestedLimit"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "StagingPolicyRiskTypeAge"
						}
					],
					"transformations": [
						{
							"name": "flowlet1",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet2",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet3",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet4",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet5",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet6",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet7",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet8",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet9",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet10",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "filter1"
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "horseBreed"
						},
						{
							"name": "horseSex"
						},
						{
							"name": "lookup1"
						},
						{
							"name": "use"
						},
						{
							"name": "mortality"
						},
						{
							"name": "purchaseDate"
						},
						{
							"name": "purchasePrcie"
						},
						{
							"name": "yearBorn"
						},
						{
							"name": "requestedLimit"
						},
						{
							"name": "ageInYears"
						},
						{
							"name": "lookup2"
						},
						{
							"name": "derivedColumn2"
						},
						{
							"name": "lookup3"
						},
						{
							"name": "derivedColumn3"
						},
						{
							"name": "select1"
						},
						{
							"name": "join1"
						}
					],
					"scriptLines": [
						"parameters{",
						"     policyPrefix as string (\"\"),",
						"     policies as string[] ([''])",
						"}",
						"source(output(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_NUMBER as string,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          RISK_IS_ACTIVE_YN as string,",
						"          RISK_EFF_DATE as timestamp,",
						"          RISK_EXP_DATE as timestamp,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> StagingPolicyRisk",
						"source(output(",
						"          POLICY_ID as long,",
						"          POLICY_VID as long,",
						"          REINSURANCE_DAC as string,",
						"          PREVIOUS_INSURANCE_NO_REMARKS as string,",
						"          AGENCY_ID as long,",
						"          AGENCY_OVID as long,",
						"          PRODUCER_ID as long,",
						"          PRODUCER_OVID as long,",
						"          PRODUCER_CONTACT_ID as long,",
						"          PRODUCER_CONTACT_OVID as long,",
						"          POLICY_NUMBER as string,",
						"          ENTITY_TYPE as string,",
						"          ENTITY_STATUS as string,",
						"          IS_RENEWAL_YN as string,",
						"          REVISION_NUMBER as integer,",
						"          PRODUCT_ID as long,",
						"          PRODUCT_OVID as long,",
						"          POLICY_EFFECTIVE_DATE as timestamp,",
						"          POLICY_EXPIRATION_DATE as timestamp,",
						"          NON_RENEWAL_CODE as string,",
						"          POLICY_RENEWED_YN as string,",
						"          CANCELLATION_DATE as timestamp,",
						"          IS_RENEWABLE_YN as string,",
						"          PREVIOUS_INSURANCE_NO_REASON as string,",
						"          POLICY_STATUS as string,",
						"          CANCEL_REASON_CODE as string,",
						"          CANCEL_REASON_DESCRIPTION as string,",
						"          CANCEL_METHOD as string,",
						"          CANCEL_METHOD_DESC as string,",
						"          LOSE_REASON_CODE as string,",
						"          LOSE_REASON_DESC as string,",
						"          DECLINATION_REASON_CODE as string,",
						"          DECLINATION_REASON_DESC as string,",
						"          NOT_WRITTEN_REASON_CODE as string,",
						"          NOT_WRITTEN_REASON_DESC as string,",
						"          POLICY_STATE_CODE as string,",
						"          PROGRAM_ID as long,",
						"          PROGRAM_OVID as long,",
						"          BILLING_TYPE_CODE as string,",
						"          UNDERWRITING_COMPANY_ID as long,",
						"          UNDERWRITING_COMPANY_OVID as long,",
						"          SUBMISSION_ID as long,",
						"          PREVIOUS_INSURANCE_YN as string,",
						"          LEGACY_POLICY_NUMBER as string,",
						"          STATE as string,",
						"          POLICY_POLICY as integer,",
						"          PAYMENT_PLAN as string,",
						"          APPLICATION_RECEIVED_DATE as timestamp,",
						"          INCEPTION_DATE as timestamp,",
						"          BILL_TYPE as string,",
						"          FORMS_LANGUAGE as string,",
						"          BASE_CURRENCY as string,",
						"          INVOICE_CURRENCY as string,",
						"          PREVIOUS_POLICY_ID as long,",
						"          PREVIOUS_POLICY_OVID as long,",
						"          REVISED_FROM_POLICY_ID as long,",
						"          REVISED_FROM_POLICY_OVID as long,",
						"          OPERATING_COMPANY_ID as long,",
						"          OPERATING_COMPANY_OVID as long,",
						"          CONVERTED_FROM_ID as long,",
						"          CONVERTED_FROM_OVID as long,",
						"          INSTALLMENT_RENEWAL as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from POL_POLICY where policy_number like '{$policyPrefix}%'\"+iif(size($policies) >0&& size($policies) ==1&&$policies[1] =='','','and policy_number in ('+dropLeft(toString(reduce($policies, \"'\", #acc + \",'\" + #item +\"'\", #result)), 2)+')')),",
						"     format: 'query') ~> StagingPolicy",
						"source(output(",
						"          PolicyPrefix as string,",
						"          Policy as string,",
						"          Policy_Sequence as string,",
						"          RowStatus as string,",
						"          EffectiveDate as timestamp,",
						"          ExpirationDate as timestamp,",
						"          LocationNumber as string,",
						"          LocationUnitNumber as string,",
						"          {UnitType/ModificationType} as string,",
						"          YearBuild as integer,",
						"          UnitValue as decimal(13,0),",
						"          SquareFootage as integer,",
						"          RiskUseCode as string,",
						"          Occupancy as string,",
						"          RoofTypeCode as string,",
						"          RoofYear as integer,",
						"          Make as string,",
						"          Model as string,",
						"          SerialNumber as string,",
						"          UnitWidth as integer,",
						"          RiskType as string,",
						"          UnitLength as integer,",
						"          PurchasePrice as decimal(9,0),",
						"          PurchaseDate as timestamp,",
						"          NewUsed as string,",
						"          ProtectionClass as string,",
						"          NumberOfSections as decimal(1,0),",
						"          AppraisalYear as integer,",
						"          AppraisedValue as decimal(9,0),",
						"          ConstructionTypeCode as string,",
						"          ParkCode as string,",
						"          OrdinanceLawPercent as decimal(5,2),",
						"          PropertyLossScore as string,",
						"          ProtectedRiskFlag as string,",
						"          PreferredRiskFlag as string,",
						"          ReplaceOrFullRepair as string,",
						"          MineSubsidenceFlag as string,",
						"          NumberOfStories as decimal(3,0),",
						"          InZoneFlag as string,",
						"          BasicFlag as string,",
						"          DwellingUnits as string,",
						"          ElectricSystemTypeCode as string,",
						"          PlumbingSystemTypeCode as string,",
						"          ExtentOfRoofUpdateCode as string,",
						"          ElectricSystemYear as integer,",
						"          ExtentOfElectricSystemUpdate as string,",
						"          PlumbingSystemYear as integer,",
						"          ExtentOfPlumbingSystemUpdate as string,",
						"          HeatingSystemYear as integer,",
						"          ExtentOfHeatingSystemUpdate as string,",
						"          MilesToFireDepartmentCode as string,",
						"          FeetToHydrantCode as string,",
						"          UnitDescription as string,",
						"          InflationGuardPercent as decimal(6,3),",
						"          NumberOfHouseholds as integer,",
						"          AnimalUseCode as string,",
						"          AnimalOtherUse as string,",
						"          LeaseFlag as string,",
						"          ID as integer,",
						"          DataSource as string,",
						"          FirelineScore as string,",
						"          FirelineStatus as string,",
						"          FirelineDate as timestamp,",
						"          AnimalDOB as timestamp,",
						"          AnimalName as string,",
						"          AnimalBreed as string,",
						"          AnimalBreedOtherDescription as string,",
						"          AnimalSireName as string,",
						"          AnimalDamName as string,",
						"          AnimalSex as string,",
						"          DW_InsertDate as date,",
						"          CoveragePart as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from [dbo].[PolicyPropertyUnit_P]  where TRIM(AnimalUseCode) != '?' and TRIM(RowStatus) != 'D' and (TRIM(AnimalBreed) != '' or TRIM(AnimalUseCode) != '') and PolicyPrefix='{$policyPrefix}'\"+iif(size($policies) >0&& size($policies) ==1&&$policies[1] =='','','and policy in ('+dropLeft(toString(reduce($policies, \"'\", #acc + \",'\" + #item +\"'\", #result)), 2)+')')),",
						"     format: 'query') ~> EcmPropertyUnits",
						"source(output(",
						"          Policy as string,",
						"          PolicyPrefix as string,",
						"          LocationNumber as string,",
						"          LocationUnitNumber as string,",
						"          ARICCoverageSequence as integer,",
						"          CoverageDescription as string,",
						"          Limit1 as decimal(38,0)",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: ' select eq.Policy,eq.PolicyPrefix,\\n      eq.LocationNumber,eq.LocationUnitNumber,fcp.ARICCoverageSequence,fcp.CoverageDescription,fcp.Limit1 from PolicyPropertyUnit_P eq \\n      join  Fact_Coverage_Premium  \\n      fcp \\n      on eq.Policy = fcp.Policy \\n      and eq.LocationNumber=fcp.LocationNumber and eq.LocationUnitNumber=fcp.LocationUnitNumber\\n      where eq.PolicyPrefix = \\'EMP\\' and ( ARICCoverageSequence=1 or ARICCoverageSequence=2) ',",
						"     format: 'query') ~> ecmWithLimits",
						"source(output(",
						"          LOOKUP_CODE as string,",
						"          LOOKUP_DESCRIPTION as string,",
						"          LOOKUP_TYPE_ID as long,",
						"          LOOKUP_TYPE_DOMAIN as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select rl.LOOKUP_CODE, rl.LOOKUP_DESCRIPTION, rlt.LOOKUP_TYPE_ID, rlt.LOOKUP_TYPE_DOMAIN from REF_LOOKUP rl join REF_LOOKUP_TYPE rlt on rl.LOOKUP_TYPE_ID = rlt.LOOKUP_TYPE_ID where rlt.LOOKUP_TYPE_ID = 1',",
						"     format: 'query') ~> sourceRefLookUp",
						"derivedColumn1 compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet1@(output1)",
						"horseBreed compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet2@(output1)",
						"horseSex compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet3@(output1)",
						"use compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet4@(output1)",
						"purchaseDate compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet5@(output1)",
						"derivedColumn2 compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet6@(output1)",
						"derivedColumn3 compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet7@(output1)",
						"yearBorn compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet8@(output1)",
						"purchasePrcie compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet9@(output1)",
						"ageInYears compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet10@(output1)",
						"lookup1 filter(not(isNull(POLICY_NUMBER))) ~> filter1",
						"filter1 derive(RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = RISK_CODE,",
						"          ATTRIBUTE_NAME = \"horseName\",",
						"          ATTRIBUTE_VALUE = AnimalName) ~> derivedColumn1",
						"filter1 derive(RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = AnimalUseCode,",
						"          ATTRIBUTE_NAME = 'horseBreed',",
						"          ATTRIBUTE_VALUE = AnimalBreed) ~> horseBreed",
						"filter1 derive(RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISKCODE = RiskUseCode,",
						"          ATTRIBUTE_NAME = \"horseSex\",",
						"          ATTRIBUTE_VALUE = AnimalSex) ~> horseSex",
						"join1, EcmPropertyUnits lookup(POLICY_NUMBER == Policy",
						"     && split(RISK_NUMBER,'-')[1] == LocationNumber",
						"     && split(RISK_NUMBER,'-')[2] == LocationUnitNumber,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lookup1",
						"filter1 derive(RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = '',",
						"          ATTRIBUTE_NAME = 'use',",
						"          ATTRIBUTE_VALUE = AnimalUseCode) ~> use",
						"filter1 derive(RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = '',",
						"          ATTRIBUTE_NAME = 'mortality') ~> mortality",
						"filter1 derive(RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = '',",
						"          ATTRIBUTE_NAME = 'purchaseDate',",
						"          ATTRIBUTE_VALUE = iif(isNull(PurchaseDate), '', toString(year(PurchaseDate)))) ~> purchaseDate",
						"filter1 derive(RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = '',",
						"          ATTRIBUTE_NAME = 'purchasePrice',",
						"          ATTRIBUTE_VALUE = toString(PurchasePrice)) ~> purchasePrcie",
						"filter1 derive(RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = '',",
						"          ATTRIBUTE_NAME = 'yearBorn',",
						"          ATTRIBUTE_VALUE = iif(isNull(AnimalDOB), '', toString(year(AnimalDOB)))) ~> yearBorn",
						"filter1 derive(RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = '',",
						"          ATTRIBUTE_NAME = 'requestedLimit') ~> requestedLimit",
						"filter1 derive(RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = \"\",",
						"          ATTRIBUTE_NAME = \"ageInYears\",",
						"          ATTRIBUTE_VALUE = iif(isNull(AnimalDOB), '', toString(year(currentDate()) - year(AnimalDOB)))) ~> ageInYears",
						"mortality, ecmWithLimits lookup(EcmPropertyUnits@Policy == ecmWithLimits@Policy",
						"     && EcmPropertyUnits@LocationNumber == ecmWithLimits@LocationNumber",
						"     && EcmPropertyUnits@LocationUnitNumber == ecmWithLimits@LocationUnitNumber,",
						"     multiple: false,",
						"     pickup: 'first',",
						"     asc(ecmWithLimits@Policy, true),",
						"     broadcast: 'auto')~> lookup2",
						"lookup2 derive(ATTRIBUTE_VALUE = iif(ARICCoverageSequence==1, 'MO01', 'MO02')) ~> derivedColumn2",
						"select1, ecmWithLimits lookup(POLICY_NUMBER == Policy",
						"     && split(RISK_NUMBER,'-')[1] == LocationNumber",
						"     && split(RISK_NUMBER,'-')[2] == LocationUnitNumber,",
						"     multiple: false,",
						"     pickup: 'first',",
						"     asc(ecmWithLimits@Policy, true),",
						"     broadcast: 'auto')~> lookup3",
						"lookup3 derive(ATTRIBUTE_VALUE = Limit1) ~> derivedColumn3",
						"requestedLimit select(mapColumn(",
						"          RISK_ID,",
						"          RISK_VID,",
						"          RISK_TYPE_CD,",
						"          POLICY_NUMBER,",
						"          RISK_NUMBER,",
						"          RISK_CODE,",
						"          ATTRIBUTE_NAME",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"StagingPolicyRisk, StagingPolicy join(StagingPolicyRisk@POLICY_ID == StagingPolicy@POLICY_ID,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"flowlet1@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> StagingPolicyRiskTypeBreed",
						"flowlet2@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> StagingPolicyRiskTypeName",
						"flowlet3@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> StagingPolicyRiskTypeSex",
						"flowlet5@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> StagingPolicyRiskTypePurchaseDate",
						"flowlet6@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> StagingPolicyRiskTypeMortality",
						"flowlet4@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> StagingPolicyRiskTypeUse",
						"flowlet9@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> StagingPolicyRiskTypePrice",
						"flowlet8@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> StagingPolicyRiskTypeYearBorn",
						"flowlet7@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> StagingPolicyRiskTypeRequestedLimit",
						"flowlet10@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> StagingPolicyRiskTypeAge"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/fl_source_addDefaultColumnFlowlet')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_policyRisk')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_policy')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_propertyUnits')]",
				"[concat(variables('factoryId'), '/datasets/joinTableStageSQL')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_policyRiskDetails')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_source_emp_lookupType')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Source Stage Data Flows/lookupDataFlow"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_stage__emp_riskType_excel",
								"type": "DatasetReference"
							},
							"name": "empRiskTypeCodes"
						},
						{
							"dataset": {
								"referenceName": "StgLookUpType",
								"type": "DatasetReference"
							},
							"name": "lookupTypeSource"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "StgLookUpType",
								"type": "DatasetReference"
							},
							"name": "LookUpTypeSink"
						},
						{
							"name": "lookupTypeCache"
						}
					],
					"transformations": [
						{
							"name": "flowlet1",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "derivedColumn2"
						},
						{
							"name": "surrogateKey1"
						},
						{
							"name": "aggregate1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          UNIT_TYPE as string,",
						"          RSKTYPE as string,",
						"          RISK_TYPE_CODE as string,",
						"          DIMENSION_NAME as string,",
						"          RISK_TYPE_CODE_DESC as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> empRiskTypeCodes",
						"source(output(",
						"          id as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select MAX(LOOKUP_TYPE_ID)  as id from dbo.REF_LOOKUP_TYPE',",
						"     format: 'query') ~> lookupTypeSource",
						"derivedColumn1 compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet1@(output1)",
						"surrogateKey1 derive(LOOKUP_TYPE_ID = pkey + lookupTypeCache#outputs()[1].id,",
						"          LOOKUP_TYPE_DOMAIN = DIMENSION_NAME) ~> derivedColumn1",
						"lookupTypeSource derive(id = iifNull(id, 0, id)) ~> derivedColumn2",
						"aggregate1 keyGenerate(output(pkey as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> surrogateKey1",
						"empRiskTypeCodes aggregate(groupBy(DIMENSION_NAME),",
						"     count = count(DIMENSION_NAME)) ~> aggregate1",
						"flowlet1@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          LOOKUP_TYPE_ID as long,",
						"          LOOKUP_TYPE_DOMAIN as string,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          DATA_HASH as binary,",
						"          SOURCE_KEY as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> LookUpTypeSink",
						"derivedColumn2 sink(validateSchema: false,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     store: 'cache',",
						"     format: 'inline',",
						"     output: false,",
						"     saveOrder: 1) ~> lookupTypeCache"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/fl_source_addDefaultColumnFlowlet')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage__emp_riskType_excel')]",
				"[concat(variables('factoryId'), '/datasets/StgLookUpType')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_source_emp_lookupTypeDetails')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Source Stage Data Flows/lookupDataFlow"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_stage__emp_riskType_excel",
								"type": "DatasetReference"
							},
							"name": "empRiskTypeCodes"
						},
						{
							"dataset": {
								"referenceName": "StgRefLookUp",
								"type": "DatasetReference"
							},
							"name": "lookupTypeSource"
						},
						{
							"dataset": {
								"referenceName": "StgLookUpType",
								"type": "DatasetReference"
							},
							"name": "lookupType"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "StgRefLookUp",
								"type": "DatasetReference"
							},
							"name": "LookUpDetailsSink"
						},
						{
							"name": "lookupTypeCache"
						}
					],
					"transformations": [
						{
							"name": "flowlet1",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "derivedColumn2"
						},
						{
							"name": "lookupByLookupType"
						},
						{
							"name": "lookupTypeSelect"
						},
						{
							"name": "select1"
						},
						{
							"name": "surrogateKey1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          UNIT_TYPE as string,",
						"          RSKTYPE as string,",
						"          RISK_TYPE_CODE as string,",
						"          DIMENSION_NAME as string,",
						"          RISK_TYPE_CODE_DESC as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> empRiskTypeCodes",
						"source(output(",
						"          LOOKUP_ID as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select MAX(LOOKUP_ID)  as LOOKUP_ID from dbo.REF_LOOKUP',",
						"     format: 'query') ~> lookupTypeSource",
						"source(output(",
						"          LOOKUP_TYPE_ID as long,",
						"          LOOKUP_TYPE_DOMAIN as string,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          DATA_HASH as binary,",
						"          SOURCE_KEY as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> lookupType",
						"select1 compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet1@(output1)",
						"surrogateKey1 derive(LOOKUP_ID = pkey + lookupTypeCache#outputs()[1].LOOKUP_ID,",
						"          LOOKUP_TYPE_ID = LOOKUP_TYPE_ID,",
						"          LOOKUP_CODE = RISK_TYPE_CODE,",
						"          LOOKUP_SHORT_DESCRIPTION = RISK_TYPE_CODE_DESC,",
						"          LOOKUP_DESCRIPTION = RISK_TYPE_CODE_DESC) ~> derivedColumn1",
						"lookupTypeSource derive(LOOKUP_ID = iifNull(LOOKUP_ID, 0, LOOKUP_ID)) ~> derivedColumn2",
						"empRiskTypeCodes, lookupType lookup(DIMENSION_NAME == LOOKUP_TYPE_DOMAIN,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lookupByLookupType",
						"lookupType select(mapColumn(",
						"          LOOKUP_TYPE_ID,",
						"          LOOKUP_TYPE_DOMAIN",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> lookupTypeSelect",
						"derivedColumn1 select(mapColumn(",
						"          LOOKUP_TYPE_ID,",
						"          LOOKUP_ID,",
						"          LOOKUP_CODE,",
						"          LOOKUP_SHORT_DESCRIPTION,",
						"          LOOKUP_DESCRIPTION",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"lookupByLookupType keyGenerate(output(pkey as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> surrogateKey1",
						"flowlet1@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          LOOKUP_ID as long,",
						"          LOOKUP_TYPE_ID as long,",
						"          LOOKUP_CODE as string,",
						"          LOOKUP_SHORT_DESCRIPTION as string,",
						"          LOOKUP_DESCRIPTION as string,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          DATA_HASH as binary,",
						"          SOURCE_KEY as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> LookUpDetailsSink",
						"derivedColumn2 sink(validateSchema: false,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     store: 'cache',",
						"     format: 'inline',",
						"     output: false,",
						"     saveOrder: 1) ~> lookupTypeCache"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/fl_source_addDefaultColumnFlowlet')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage__emp_riskType_excel')]",
				"[concat(variables('factoryId'), '/datasets/StgRefLookUp')]",
				"[concat(variables('factoryId'), '/datasets/StgLookUpType')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_source_insuredAddressToLocation')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Source Stage Data Flows/txnDataFlow"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_insuredAddress",
								"type": "DatasetReference"
							},
							"name": "insuredAddressSource"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policy",
								"type": "DatasetReference"
							},
							"name": "policyStaging"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_genAddress",
								"type": "DatasetReference"
							},
							"name": "genAddressStaging"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_insured_location",
								"type": "DatasetReference"
							},
							"name": "insuredLocationStagingMaxId"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_insured_location",
								"type": "DatasetReference"
							},
							"name": "insuredLocationStaging"
						},
						{
							"name": "maxIdCache"
						}
					],
					"transformations": [
						{
							"name": "flowlet1",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "join1"
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "join2"
						},
						{
							"name": "derivedColumn2"
						},
						{
							"name": "select1"
						},
						{
							"name": "select2"
						},
						{
							"name": "select3"
						},
						{
							"name": "surrogateKey1"
						},
						{
							"name": "select4"
						}
					],
					"scriptLines": [
						"parameters{",
						"     policyPrefix as string,",
						"     policies as string[]",
						"}",
						"source(output(",
						"          Policy as string,",
						"          Policy_Sequence as string,",
						"          PolicyPrefix as string,",
						"          ProductCode as string,",
						"          EffectiveDate as timestamp,",
						"          ExpirationDate as timestamp,",
						"          InsuredName as string,",
						"          InsuredAddress1 as string,",
						"          InsuredAddress2 as string,",
						"          InsuredAddress3 as string,",
						"          InsuredCity as string,",
						"          InsuredState as string,",
						"          InsuredZipCode as string,",
						"          InsuredTelephone as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from [dbo].[Insured_Address] where PolicyPrefix = '{$policyPrefix}'\" +iif(size($policies) >0&& size($policies) ==1&&$policies[1] =='','','and policy in ('+dropLeft(toString(reduce($policies, \"'\", #acc + \",'\" + #item +\"'\", #result)), 2)+')')),",
						"     format: 'query') ~> insuredAddressSource",
						"source(output(",
						"          POLICY_ID as long,",
						"          POLICY_VID as long,",
						"          REINSURANCE_DAC as string,",
						"          PREVIOUS_INSURANCE_NO_REMARKS as string,",
						"          AGENCY_ID as long,",
						"          AGENCY_OVID as long,",
						"          PRODUCER_ID as long,",
						"          PRODUCER_OVID as long,",
						"          PRODUCER_CONTACT_ID as long,",
						"          PRODUCER_CONTACT_OVID as long,",
						"          POLICY_NUMBER as string,",
						"          ENTITY_TYPE as string,",
						"          ENTITY_STATUS as string,",
						"          IS_RENEWAL_YN as string,",
						"          REVISION_NUMBER as integer,",
						"          PRODUCT_ID as long,",
						"          PRODUCT_OVID as long,",
						"          POLICY_EFFECTIVE_DATE as timestamp,",
						"          POLICY_EXPIRATION_DATE as timestamp,",
						"          NON_RENEWAL_CODE as string,",
						"          POLICY_RENEWED_YN as string,",
						"          CANCELLATION_DATE as timestamp,",
						"          IS_RENEWABLE_YN as string,",
						"          PREVIOUS_INSURANCE_NO_REASON as string,",
						"          POLICY_STATUS as string,",
						"          CANCEL_REASON_CODE as string,",
						"          CANCEL_REASON_DESCRIPTION as string,",
						"          CANCEL_METHOD as string,",
						"          CANCEL_METHOD_DESC as string,",
						"          LOSE_REASON_CODE as string,",
						"          LOSE_REASON_DESC as string,",
						"          DECLINATION_REASON_CODE as string,",
						"          DECLINATION_REASON_DESC as string,",
						"          NOT_WRITTEN_REASON_CODE as string,",
						"          NOT_WRITTEN_REASON_DESC as string,",
						"          POLICY_STATE_CODE as string,",
						"          PROGRAM_ID as long,",
						"          PROGRAM_OVID as long,",
						"          BILLING_TYPE_CODE as string,",
						"          UNDERWRITING_COMPANY_ID as long,",
						"          UNDERWRITING_COMPANY_OVID as long,",
						"          SUBMISSION_ID as long,",
						"          PREVIOUS_INSURANCE_YN as string,",
						"          LEGACY_POLICY_NUMBER as string,",
						"          STATE as string,",
						"          POLICY_POLICY as integer,",
						"          PAYMENT_PLAN as string,",
						"          APPLICATION_RECEIVED_DATE as timestamp,",
						"          INCEPTION_DATE as timestamp,",
						"          BILL_TYPE as string,",
						"          FORMS_LANGUAGE as string,",
						"          BASE_CURRENCY as string,",
						"          INVOICE_CURRENCY as string,",
						"          PREVIOUS_POLICY_ID as long,",
						"          PREVIOUS_POLICY_OVID as long,",
						"          REVISED_FROM_POLICY_ID as long,",
						"          REVISED_FROM_POLICY_OVID as long,",
						"          OPERATING_COMPANY_ID as long,",
						"          OPERATING_COMPANY_OVID as long,",
						"          CONVERTED_FROM_ID as long,",
						"          CONVERTED_FROM_OVID as long,",
						"          INSTALLMENT_RENEWAL as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from [dbo].[POL_POLICY] where ENTITY_TYPE ='{$policyPrefix}'\" +iif(size($policies) >0&& size($policies) ==1&&$policies[1] =='','','and policy_number in ('+dropLeft(toString(reduce($policies, \"'\", #acc + \",'\" + #item +\"'\", #result)), 2)+')')),",
						"     format: 'query') ~> policyStaging",
						"source(output(",
						"          GEN_ADDRESS_UNIQ_ID as long,",
						"          ADDRESS_STREET1 as string,",
						"          ADDRESS_STREET2 as string,",
						"          COUNTY_CODE as string,",
						"          COUNTY as string,",
						"          ADDRESS_CITY as string,",
						"          ADD_DESCRIPTION as string,",
						"          STATE_PROVINCE_CODE as string,",
						"          POSTAL_CODE as string,",
						"          POSTAL_CODE_EXT as string,",
						"          COUNTRY_CODE as string,",
						"          SOURCE_INSERTED_ON as timestamp,",
						"          SOURCE_UPDATED_ON as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary,",
						"          TERRITORY as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> genAddressStaging",
						"source(output(",
						"          maxId as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT isnull(MAX(LOCATION_ID), 0) as maxId\\nFROM dbo.POL_INSURED_LOCATION',",
						"     format: 'query') ~> insuredLocationStagingMaxId",
						"derivedColumn2 compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet1@(output1)",
						"select1, select2 join(Policy == POLICY_NUMBER,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"join1 derive(source_key_exp = concatWS('', iif(isNull(ADDRESS_STREET1), '', replace(ADDRESS_STREET1, ' ', '')), iif(isNull(ADDRESS_STREET2), '', replace(ADDRESS_STREET2, ' ', '')), iif(isNull(ADDRESS_CITY), '', replace(ADDRESS_CITY, ' ', '')) , iif(isNull(POSTAL_CODE), '', replace(POSTAL_CODE, ' ', '')))) ~> derivedColumn1",
						"derivedColumn1, select3 join(source_key_exp == SOURCE_KEY,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join2",
						"surrogateKey1 derive(LOCATION_ID = skey + maxIdCache#outputs()[1].maxId,",
						"          LOCATION_VID = 1,",
						"          LOCATION_IS_ACTIVE_YN = \"Y\",",
						"          LOCATION_EFF_DATE = currentTimestamp(),",
						"          LOCATION_EXP_DATE = toTimestamp(\"9999-01-01 00:00:00\")) ~> derivedColumn2",
						"insuredAddressSource select(mapColumn(",
						"          Policy,",
						"          ADDRESS_STREET1 = InsuredAddress1,",
						"          ADDRESS_STREET2 = InsuredAddress2,",
						"          ADDRESS_CITY = InsuredCity,",
						"          POSTAL_CODE = InsuredZipCode",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"policyStaging select(mapColumn(",
						"          POLICY_ID,",
						"          POLICY_NUMBER",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select2",
						"genAddressStaging select(mapColumn(",
						"          GEN_ADDRESS_UNIQ_ID,",
						"          SOURCE_KEY",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select3",
						"select4 keyGenerate(output(skey as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> surrogateKey1",
						"join2 select(mapColumn(",
						"          POLICY_ID,",
						"          GEN_ADDRESS_UNIQ_ID",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select4",
						"flowlet1@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          LOCATION_ID as long,",
						"          LOCATION_VID as long,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          LOCATION_IS_ACTIVE_YN as string,",
						"          LOCATION_EFF_DATE as timestamp,",
						"          LOCATION_EXP_DATE as timestamp,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          IS_PRIMARY_LOCATION_YN as string,",
						"          IS_FALSE_ADDRESS as string,",
						"          PROTECTION_CLASS as string,",
						"          FIRE_DISTRICT_NAME as string,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          GEN_ADDRESS_UNIQ_ID as long,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> insuredLocationStaging",
						"insuredLocationStagingMaxId sink(validateSchema: false,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     store: 'cache',",
						"     format: 'inline',",
						"     output: false,",
						"     saveOrder: 1) ~> maxIdCache"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/fl_source_addDefaultColumnFlowlet')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_insuredAddress')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_policy')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_genAddress')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_insured_location')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_source_insuredgenaddress')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Source Stage Data Flows/referenceDataFlow"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_insuredAddress",
								"type": "DatasetReference"
							},
							"name": "insuredAddressSource"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_genAddress",
								"type": "DatasetReference"
							},
							"name": "genAddressStagingLookup"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_genAddress",
								"type": "DatasetReference"
							},
							"name": "genAddressStaging"
						}
					],
					"transformations": [
						{
							"name": "selectRequiredAddressColumns"
						},
						{
							"name": "addressSurrogateKey"
						},
						{
							"name": "deriveSourceKey"
						},
						{
							"name": "alreadyExistsCheck"
						},
						{
							"name": "groupBySourceKey"
						}
					],
					"scriptLines": [
						"parameters{",
						"     DF_max_id as integer (1),",
						"     policyPrefix as string ('')",
						"}",
						"source(output(",
						"          Policy as string,",
						"          Policy_Sequence as string,",
						"          PolicyPrefix as string,",
						"          ProductCode as string,",
						"          EffectiveDate as timestamp,",
						"          ExpirationDate as timestamp,",
						"          InsuredName as string,",
						"          InsuredAddress1 as string,",
						"          InsuredAddress2 as string,",
						"          InsuredAddress3 as string,",
						"          InsuredCity as string,",
						"          InsuredState as string,",
						"          InsuredZipCode as string,",
						"          InsuredTelephone as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from [dbo].[Insured_Address] where PolicyPrefix = '{$policyPrefix}'\" ),",
						"     format: 'query') ~> insuredAddressSource",
						"source(output(",
						"          GEN_ADDRESS_UNIQ_ID as long,",
						"          ADDRESS_STREET1 as string,",
						"          ADDRESS_STREET2 as string,",
						"          COUNTY_CODE as string,",
						"          COUNTY as string,",
						"          ADDRESS_CITY as string,",
						"          ADD_DESCRIPTION as string,",
						"          STATE_PROVINCE_CODE as string,",
						"          POSTAL_CODE as string,",
						"          POSTAL_CODE_EXT as string,",
						"          COUNTRY_CODE as string,",
						"          SOURCE_INSERTED_ON as timestamp,",
						"          SOURCE_UPDATED_ON as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> genAddressStagingLookup",
						"insuredAddressSource select(mapColumn(",
						"          ADDRESS_STREET1 = InsuredAddress1,",
						"          ADDRESS_STREET2 = InsuredAddress2,",
						"          ADDRESS_CITY = InsuredCity,",
						"          STATE_PROVINCE_CODE = InsuredState,",
						"          POSTAL_CODE = InsuredZipCode",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectRequiredAddressColumns",
						"selectRequiredAddressColumns keyGenerate(output(skey as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> addressSurrogateKey",
						"addressSurrogateKey derive(GEN_ADDRESS_UNIQ_ID = skey + $DF_max_id,",
						"          SOURCE_KEY = concatWS('', iif(isNull(ADDRESS_STREET1), '', replace(ADDRESS_STREET1, ' ', '')), iif(isNull(ADDRESS_STREET2), '', replace(ADDRESS_STREET2, ' ', '')), iif(isNull(ADDRESS_CITY), '', replace(ADDRESS_CITY, ' ', '')) , iif(isNull(POSTAL_CODE), '', replace(POSTAL_CODE, ' ', '')))) ~> deriveSourceKey",
						"groupBySourceKey, genAddressStagingLookup exists(groupBySourceKey@SOURCE_KEY == genAddressStagingLookup@SOURCE_KEY,",
						"     negate:true,",
						"     broadcast: 'auto')~> alreadyExistsCheck",
						"deriveSourceKey aggregate(groupBy(SOURCE_KEY),",
						"     each(match(name!='SOURCE_KEY'), $$ = first($$))) ~> groupBySourceKey",
						"alreadyExistsCheck sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          GEN_ADDRESS_UNIQ_ID as long,",
						"          ADDRESS_STREET1 as string,",
						"          ADDRESS_STREET2 as string,",
						"          COUNTY_CODE as string,",
						"          COUNTY as string,",
						"          ADDRESS_CITY as string,",
						"          ADD_DESCRIPTION as string,",
						"          STATE_PROVINCE_CODE as string,",
						"          POSTAL_CODE as string,",
						"          POSTAL_CODE_EXT as string,",
						"          COUNTRY_CODE as string,",
						"          SOURCE_INSERTED_ON as timestamp,",
						"          SOURCE_UPDATED_ON as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary,",
						"          TERRITORY as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> genAddressStaging"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ds_source_insuredAddress')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_genAddress')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_source_lobcompany')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Source Stage Data Flows/referenceDataFlow"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_company",
								"type": "DatasetReference"
							},
							"name": "companySource"
						},
						{
							"dataset": {
								"referenceName": "ds_source_lob",
								"type": "DatasetReference"
							},
							"name": "lobSource"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_company",
								"type": "DatasetReference"
							},
							"name": "compnayStatgingLookup"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_lob",
								"type": "DatasetReference"
							},
							"name": "lobStagingLookup"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_company",
								"type": "DatasetReference"
							},
							"name": "companyStaging"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_lob",
								"type": "DatasetReference"
							},
							"name": "lobStaging"
						}
					],
					"transformations": [
						{
							"name": "flowlet3",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet4",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "select3"
						},
						{
							"name": "surrogateKey1"
						},
						{
							"name": "derivedColumn2"
						},
						{
							"name": "select4"
						},
						{
							"name": "surrogateKey2"
						},
						{
							"name": "derivedColumn3"
						},
						{
							"name": "select5"
						},
						{
							"name": "exists1"
						},
						{
							"name": "select6"
						},
						{
							"name": "exists2"
						}
					],
					"scriptLines": [
						"parameters{",
						"     DF_batch as integer (1),",
						"     DF_lob_max_id as integer (1),",
						"     DF_company_max_id as integer (1)",
						"}",
						"source(output(",
						"          ID as integer,",
						"          WINSCompanyID as string,",
						"          Name as string,",
						"          NAICNumber as string,",
						"          NAICGroupCode as string,",
						"          NCCICode as string,",
						"          ISOCode as string,",
						"          FEIN as string,",
						"          AddressLine1 as string,",
						"          AddressLine2 as string,",
						"          City as string,",
						"          AlphaStateCode as string,",
						"          ZipCode as string,",
						"          CreateTime as timestamp,",
						"          CreatedBy as string,",
						"          UpdateTime as timestamp,",
						"          UpdatedBy as string,",
						"          AgentUploadFlag as string,",
						"          ARICGroupCode as string,",
						"          CompanyGroup as string,",
						"          ARICDirectAssumed as string,",
						"          CompanyAbbreviation as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> companySource",
						"source(output(",
						"          ARICGroupCode as string,",
						"          ARICLineOfBusinessID as string,",
						"          ARICGroupLineDescription as string,",
						"          ARICMajorProductCode as string,",
						"          ProductCode as string,",
						"          INFCATPProduct as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> lobSource",
						"source(output(",
						"          COMPANY_ID as long,",
						"          COMPANY_VID as long,",
						"          COMPANY_CODE as string,",
						"          COMPANY_NAME as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          CORPORATE_NAME as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> compnayStatgingLookup",
						"source(output(",
						"          LOB_ID as long,",
						"          LOB_CODE as string,",
						"          LOB_NAME as string,",
						"          LOB_DESCRIPTION as string,",
						"          LOB_IS_VALID_YN as string,",
						"          LOB_VALID_START_DATE as timestamp,",
						"          LOB_VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> lobStagingLookup",
						"derivedColumn2 compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet3@(output1)",
						"derivedColumn3 compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet4@(output1)",
						"companySource select(mapColumn(",
						"          COMPANY_CODE = WINSCompanyID,",
						"          COMPANY_NAME = Name",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select3",
						"exists1 keyGenerate(output(skey as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> surrogateKey1",
						"surrogateKey1 derive(COMPANY_ID = skey + $DF_company_max_id,",
						"          COMPANY_VID = 1) ~> derivedColumn2",
						"lobSource select(mapColumn(",
						"          LOB_CODE = ARICLineOfBusinessID,",
						"          LOB_DESCRIPTION = ARICGroupLineDescription",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select4",
						"exists2 keyGenerate(output(skey as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> surrogateKey2",
						"surrogateKey2 derive(LOB_ID = skey + $DF_lob_max_id) ~> derivedColumn3",
						"compnayStatgingLookup select(mapColumn(",
						"          COMPANY_CODE",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select5",
						"select3, select5 exists(select3@COMPANY_CODE == select5@COMPANY_CODE,",
						"     negate:true,",
						"     broadcast: 'auto')~> exists1",
						"lobStagingLookup select(mapColumn(",
						"          LOB_CODE",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select6",
						"select4, select6 exists(select4@LOB_CODE == select6@LOB_CODE,",
						"     negate:true,",
						"     broadcast: 'auto')~> exists2",
						"flowlet3@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          COMPANY_ID as long,",
						"          COMPANY_VID as long,",
						"          COMPANY_CODE as string,",
						"          COMPANY_NAME as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          CORPORATE_NAME as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     saveOrder: 1) ~> companyStaging",
						"flowlet4@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          LOB_ID as long,",
						"          LOB_CODE as string,",
						"          LOB_NAME as string,",
						"          LOB_DESCRIPTION as string,",
						"          LOB_IS_VALID_YN as string,",
						"          LOB_VALID_START_DATE as timestamp,",
						"          LOB_VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     saveOrder: 2) ~> lobStaging"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/fl_source_addDefaultColumnFlowlet')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_company')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_lob')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_company')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_lob')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_source_locationAddressToLocation')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Source Stage Data Flows/txnDataFlow"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_locationAddress",
								"type": "DatasetReference"
							},
							"name": "locationAddressSource"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policy",
								"type": "DatasetReference"
							},
							"name": "policyStaging"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_genAddress",
								"type": "DatasetReference"
							},
							"name": "genAddressStaging"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_location",
								"type": "DatasetReference"
							},
							"name": "locationStagingMaxId"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_location",
								"type": "DatasetReference"
							},
							"name": "locationStaging"
						},
						{
							"name": "maxIdCache"
						}
					],
					"transformations": [
						{
							"name": "flowlet1",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "join1"
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "join2"
						},
						{
							"name": "derivedColumn2"
						},
						{
							"name": "select1"
						},
						{
							"name": "select2"
						},
						{
							"name": "select3"
						},
						{
							"name": "surrogateKey1"
						},
						{
							"name": "select4"
						}
					],
					"scriptLines": [
						"parameters{",
						"     policyPrefix as string,",
						"     policies as string[]",
						"}",
						"source(output(",
						"          Policy as string,",
						"          Policy_Sequence as string,",
						"          PolicyPrefix as string,",
						"          ProductCode as string,",
						"          LocationNumber as string,",
						"          BuildingNumber as string,",
						"          LocationName as string,",
						"          LocationAddress1 as string,",
						"          LocationAddress2 as string,",
						"          LocationAddress3 as string,",
						"          LocationCity as string,",
						"          LocationZipCode as string,",
						"          LocationCounty as string,",
						"          Territory as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from [dbo].[Location_Address] where  PolicyPrefix = '{$policyPrefix}' and LocationNumber != '000'\"+iif(size($policies) >0&& size($policies) ==1&&$policies[1] =='','','and policy in ('+dropLeft(toString(reduce($policies, \"'\", #acc + \",'\" + #item +\"'\", #result)), 2)+')')),",
						"     format: 'query') ~> locationAddressSource",
						"source(output(",
						"          POLICY_ID as long,",
						"          POLICY_VID as long,",
						"          REINSURANCE_DAC as string,",
						"          PREVIOUS_INSURANCE_NO_REMARKS as string,",
						"          AGENCY_ID as long,",
						"          AGENCY_OVID as long,",
						"          PRODUCER_ID as long,",
						"          PRODUCER_OVID as long,",
						"          PRODUCER_CONTACT_ID as long,",
						"          PRODUCER_CONTACT_OVID as long,",
						"          POLICY_NUMBER as string,",
						"          ENTITY_TYPE as string,",
						"          ENTITY_STATUS as string,",
						"          IS_RENEWAL_YN as string,",
						"          REVISION_NUMBER as integer,",
						"          PRODUCT_ID as long,",
						"          PRODUCT_OVID as long,",
						"          POLICY_EFFECTIVE_DATE as timestamp,",
						"          POLICY_EXPIRATION_DATE as timestamp,",
						"          NON_RENEWAL_CODE as string,",
						"          POLICY_RENEWED_YN as string,",
						"          CANCELLATION_DATE as timestamp,",
						"          IS_RENEWABLE_YN as string,",
						"          PREVIOUS_INSURANCE_NO_REASON as string,",
						"          POLICY_STATUS as string,",
						"          CANCEL_REASON_CODE as string,",
						"          CANCEL_REASON_DESCRIPTION as string,",
						"          CANCEL_METHOD as string,",
						"          CANCEL_METHOD_DESC as string,",
						"          LOSE_REASON_CODE as string,",
						"          LOSE_REASON_DESC as string,",
						"          DECLINATION_REASON_CODE as string,",
						"          DECLINATION_REASON_DESC as string,",
						"          NOT_WRITTEN_REASON_CODE as string,",
						"          NOT_WRITTEN_REASON_DESC as string,",
						"          POLICY_STATE_CODE as string,",
						"          PROGRAM_ID as long,",
						"          PROGRAM_OVID as long,",
						"          BILLING_TYPE_CODE as string,",
						"          UNDERWRITING_COMPANY_ID as long,",
						"          UNDERWRITING_COMPANY_OVID as long,",
						"          SUBMISSION_ID as long,",
						"          PREVIOUS_INSURANCE_YN as string,",
						"          LEGACY_POLICY_NUMBER as string,",
						"          STATE as string,",
						"          POLICY_POLICY as integer,",
						"          PAYMENT_PLAN as string,",
						"          APPLICATION_RECEIVED_DATE as timestamp,",
						"          INCEPTION_DATE as timestamp,",
						"          BILL_TYPE as string,",
						"          FORMS_LANGUAGE as string,",
						"          BASE_CURRENCY as string,",
						"          INVOICE_CURRENCY as string,",
						"          PREVIOUS_POLICY_ID as long,",
						"          PREVIOUS_POLICY_OVID as long,",
						"          REVISED_FROM_POLICY_ID as long,",
						"          REVISED_FROM_POLICY_OVID as long,",
						"          OPERATING_COMPANY_ID as long,",
						"          OPERATING_COMPANY_OVID as long,",
						"          CONVERTED_FROM_ID as long,",
						"          CONVERTED_FROM_OVID as long,",
						"          INSTALLMENT_RENEWAL as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from [dbo].[POL_POLICY] where ENTITY_TYPE ='{$policyPrefix}' \"+iif(size($policies) >0&& size($policies) ==1&&$policies[1] =='','','and policy_number in ('+dropLeft(toString(reduce($policies, \"'\", #acc + \",'\" + #item +\"'\", #result)), 2)+')')),",
						"     format: 'query') ~> policyStaging",
						"source(output(",
						"          GEN_ADDRESS_UNIQ_ID as long,",
						"          ADDRESS_STREET1 as string,",
						"          ADDRESS_STREET2 as string,",
						"          COUNTY_CODE as string,",
						"          COUNTY as string,",
						"          ADDRESS_CITY as string,",
						"          ADD_DESCRIPTION as string,",
						"          STATE_PROVINCE_CODE as string,",
						"          POSTAL_CODE as string,",
						"          POSTAL_CODE_EXT as string,",
						"          COUNTRY_CODE as string,",
						"          SOURCE_INSERTED_ON as timestamp,",
						"          SOURCE_UPDATED_ON as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary,",
						"          TERRITORY as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> genAddressStaging",
						"source(output(",
						"          maxId as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT isnull(MAX(LOCATION_ID), 0) as maxId\\nFROM dbo.POL_LOCATION',",
						"     format: 'query') ~> locationStagingMaxId",
						"derivedColumn2 compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet1@(output1)",
						"select1, select2 join(Policy == POLICY_NUMBER,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"join1 derive(source_key_exp = concatWS('', iif(isNull(ADDRESS_STREET1), '', replace(ADDRESS_STREET1, ' ', '')), iif(isNull(ADDRESS_STREET2), '', replace(ADDRESS_STREET2, ' ', '')), iif(isNull(ADDRESS_CITY), '', replace(ADDRESS_CITY, ' ', '')) , iif(isNull(POSTAL_CODE), '', replace(POSTAL_CODE, ' ', '')), iif(isNull(TERRITORY), '', replace(TERRITORY, ' ', '')))) ~> derivedColumn1",
						"derivedColumn1, select3 join(source_key_exp == SOURCE_KEY,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join2",
						"surrogateKey1 derive(LOCATION_ID = skey + maxIdCache#outputs()[1].maxId,",
						"          LOCATION_VID = 1,",
						"          LOCATION_IS_ACTIVE_YN = \"Y\",",
						"          LOCATION_EFF_DATE = currentTimestamp(),",
						"          LOCATION_EXP_DATE = toTimestamp(\"9999-01-01 00:00:00\")) ~> derivedColumn2",
						"locationAddressSource select(mapColumn(",
						"          Policy,",
						"          LOCATION_NO = LocationNumber,",
						"          LOCATION_NAME = LocationName,",
						"          ADDRESS_STREET1 = LocationAddress1,",
						"          ADDRESS_STREET2 = LocationAddress2,",
						"          ADDRESS_CITY = LocationCity,",
						"          POSTAL_CODE = LocationZipCode,",
						"          TERRITORY = Territory",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"policyStaging select(mapColumn(",
						"          POLICY_ID,",
						"          POLICY_NUMBER",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select2",
						"genAddressStaging select(mapColumn(",
						"          GEN_ADDRESS_UNIQ_ID,",
						"          SOURCE_KEY",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select3",
						"select4 keyGenerate(output(skey as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> surrogateKey1",
						"join2 select(mapColumn(",
						"          LOCATION_NO,",
						"          LOCATION_NAME,",
						"          POLICY_ID,",
						"          GEN_ADDRESS_UNIQ_ID",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select4",
						"flowlet1@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          LOCATION_ID as long,",
						"          LOCATION_VID as long,",
						"          LOCATION_NAME as string,",
						"          LOCATION_NO as long,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          LOCATION_IS_ACTIVE_YN as string,",
						"          LOCATION_EFF_DATE as timestamp,",
						"          LOCATION_EXP_DATE as timestamp,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          IS_PRIMARY_LOCATION_YN as string,",
						"          IS_FALSE_ADDRESS as string,",
						"          PROTECTION_CLASS as string,",
						"          FIRE_DISTRICT_NAME as string,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          GEN_ADDRESS_UNIQ_ID as long,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> locationStaging",
						"locationStagingMaxId sink(validateSchema: false,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     store: 'cache',",
						"     format: 'inline',",
						"     output: false,",
						"     saveOrder: 1) ~> maxIdCache"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/fl_source_addDefaultColumnFlowlet')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_locationAddress')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_policy')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_genAddress')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_location')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_source_location_risk_bridege')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Source Stage Data Flows/txnDataFlow/bridge"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_location",
								"type": "DatasetReference"
							},
							"name": "location"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policy",
								"type": "DatasetReference"
							},
							"name": "policy"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRisk",
								"type": "DatasetReference"
							},
							"name": "risk"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_locationRiskBridge",
								"type": "DatasetReference"
							},
							"name": "sink1",
							"rejectedDataLinkedService": {
								"referenceName": "AzureBlobStorage1",
								"type": "LinkedServiceReference"
							}
						},
						{
							"dataset": {
								"referenceName": "ds_error_location_risk_bridge",
								"type": "DatasetReference"
							},
							"name": "sink2"
						}
					],
					"transformations": [
						{
							"name": "flowlet1",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "polSelect"
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "locationlookup"
						},
						{
							"name": "locationSelect"
						},
						{
							"name": "derivedColumn2"
						},
						{
							"name": "select1"
						},
						{
							"name": "split1"
						},
						{
							"name": "join1"
						}
					],
					"scriptLines": [
						"parameters{",
						"     policies as string[],",
						"     policyPrefix as string",
						"}",
						"source(output(",
						"          LOCATION_ID as long,",
						"          LOCATION_VID as long,",
						"          LOCATION_NAME as string,",
						"          LOCATION_NO as long,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          LOCATION_IS_ACTIVE_YN as string,",
						"          LOCATION_EFF_DATE as timestamp,",
						"          LOCATION_EXP_DATE as timestamp,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          IS_PRIMARY_LOCATION_YN as string,",
						"          IS_FALSE_ADDRESS as string,",
						"          PROTECTION_CLASS as string,",
						"          FIRE_DISTRICT_NAME as string,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          GEN_ADDRESS_UNIQ_ID as long,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select * from [dbo].[POL_LOCATION] where LOCATION_NO is not null\\n',",
						"     format: 'query') ~> location",
						"source(output(",
						"          POLICY_ID as long,",
						"          POLICY_VID as long,",
						"          REINSURANCE_DAC as string,",
						"          PREVIOUS_INSURANCE_NO_REMARKS as string,",
						"          AGENCY_ID as long,",
						"          AGENCY_OVID as long,",
						"          PRODUCER_ID as long,",
						"          PRODUCER_OVID as long,",
						"          PRODUCER_CONTACT_ID as long,",
						"          PRODUCER_CONTACT_OVID as long,",
						"          POLICY_NUMBER as string,",
						"          ENTITY_TYPE as string,",
						"          ENTITY_STATUS as string,",
						"          IS_RENEWAL_YN as string,",
						"          REVISION_NUMBER as integer,",
						"          PRODUCT_ID as long,",
						"          PRODUCT_OVID as long,",
						"          POLICY_EFFECTIVE_DATE as timestamp,",
						"          POLICY_EXPIRATION_DATE as timestamp,",
						"          NON_RENEWAL_CODE as string,",
						"          POLICY_RENEWED_YN as string,",
						"          CANCELLATION_DATE as timestamp,",
						"          IS_RENEWABLE_YN as string,",
						"          PREVIOUS_INSURANCE_NO_REASON as string,",
						"          POLICY_STATUS as string,",
						"          CANCEL_REASON_CODE as string,",
						"          CANCEL_REASON_DESCRIPTION as string,",
						"          CANCEL_METHOD as string,",
						"          CANCEL_METHOD_DESC as string,",
						"          LOSE_REASON_CODE as string,",
						"          LOSE_REASON_DESC as string,",
						"          DECLINATION_REASON_CODE as string,",
						"          DECLINATION_REASON_DESC as string,",
						"          NOT_WRITTEN_REASON_CODE as string,",
						"          NOT_WRITTEN_REASON_DESC as string,",
						"          POLICY_STATE_CODE as string,",
						"          PROGRAM_ID as long,",
						"          PROGRAM_OVID as long,",
						"          BILLING_TYPE_CODE as string,",
						"          UNDERWRITING_COMPANY_ID as long,",
						"          UNDERWRITING_COMPANY_OVID as long,",
						"          SUBMISSION_ID as long,",
						"          PREVIOUS_INSURANCE_YN as string,",
						"          LEGACY_POLICY_NUMBER as string,",
						"          STATE as string,",
						"          POLICY_POLICY as integer,",
						"          PAYMENT_PLAN as string,",
						"          APPLICATION_RECEIVED_DATE as timestamp,",
						"          INCEPTION_DATE as timestamp,",
						"          BILL_TYPE as string,",
						"          FORMS_LANGUAGE as string,",
						"          BASE_CURRENCY as string,",
						"          INVOICE_CURRENCY as string,",
						"          PREVIOUS_POLICY_ID as long,",
						"          PREVIOUS_POLICY_OVID as long,",
						"          REVISED_FROM_POLICY_ID as long,",
						"          REVISED_FROM_POLICY_OVID as long,",
						"          OPERATING_COMPANY_ID as long,",
						"          OPERATING_COMPANY_OVID as long,",
						"          CONVERTED_FROM_ID as long,",
						"          CONVERTED_FROM_OVID as long,",
						"          INSTALLMENT_RENEWAL as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from [dbo].[POL_POLICY] where ENTITY_TYPE ='{$policyPrefix}' \"+iif(size($policies) >0&& size($policies) ==1&&$policies[1] =='','','and policy_number in ('+dropLeft(toString(reduce($policies, \"'\", #acc + \",'\" + #item +\"'\", #result)), 2)+')')),",
						"     format: 'query') ~> policy",
						"source(output(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_NUMBER as string,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          RISK_IS_ACTIVE_YN as string,",
						"          RISK_EFF_DATE as timestamp,",
						"          RISK_EXP_DATE as timestamp,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select * from POL_RISK ',",
						"     format: 'query') ~> risk",
						"split1@goodRows compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet1@(output1)",
						"policy select(mapColumn(",
						"          POLICY_ID,",
						"          POLICY_VID,",
						"          POLICY_NUMBER,",
						"          ENTITY_TYPE",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> polSelect",
						"join1 derive(POLICY_ID = polSelect@POLICY_ID,",
						"          POLICY_NUMBER = POLICY_NUMBER,",
						"          RISK_ID = RISK_ID,",
						"          LOCATIONNUMBER = split(RISK_NUMBER, '-')[1],",
						"          LOCATIONUNITNUMBER = split(RISK_NUMBER, '-')[2]) ~> derivedColumn1",
						"derivedColumn1, locationSelect lookup(derivedColumn1@POLICY_ID == locationSelect@POLICY_ID",
						"     && LOCATIONNUMBER == concat('00',toString(LOCATION_NO)),",
						"     multiple: false,",
						"     pickup: 'first',",
						"     asc(LOCATION_ID, true),",
						"     broadcast: 'auto')~> locationlookup",
						"location select(mapColumn(",
						"          LOCATION_ID,",
						"          LOCATION_VID,",
						"          LOCATION_NO,",
						"          POLICY_ID",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> locationSelect",
						"locationlookup derive(LOCATION_ID = LOCATION_ID,",
						"          RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          LOCATION_OVID = LOCATION_VID) ~> derivedColumn2",
						"derivedColumn2 select(mapColumn(",
						"          RISK_ID,",
						"          RISK_VID,",
						"          LOCATION_ID,",
						"          LOCATION_OVID",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"select1 split(!isNull(RISK_ID)&&!isNull(RISK_VID)&&!isNull(LOCATION_ID)&&!isNull(LOCATION_OVID),",
						"     disjoint: false) ~> split1@(goodRows, badRows)",
						"risk, polSelect join(risk@POLICY_ID == polSelect@POLICY_ID,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"flowlet1@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          LOCATION_ID as long,",
						"          LOCATION_OVID as long,",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          DATA_HASH as binary,",
						"          SOURCE_KEY as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     outputAssertFailedRows: true,",
						"     assertFailure_container: 'bpadocuments') ~> sink1",
						"split1@badRows sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink2"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/fl_source_addDefaultColumnFlowlet')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_location')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_policy')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_policyRisk')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_locationRiskBridge')]",
				"[concat(variables('factoryId'), '/linkedServices/AzureBlobStorage1')]",
				"[concat(variables('factoryId'), '/datasets/ds_error_location_risk_bridge')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_source_locationgenaddress')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Source Stage Data Flows/referenceDataFlow"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_locationAddress",
								"type": "DatasetReference"
							},
							"name": "locationAddressSource"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_genAddress",
								"type": "DatasetReference"
							},
							"name": "genAddressStagingLookup"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_genAddress",
								"type": "DatasetReference"
							},
							"name": "genAddressStaging"
						}
					],
					"transformations": [
						{
							"name": "selectRequiredAddressColumns"
						},
						{
							"name": "addressSurrogateKey"
						},
						{
							"name": "deriveSourceKey"
						},
						{
							"name": "alreadyExistsCheck"
						},
						{
							"name": "groupBySourceKey"
						}
					],
					"scriptLines": [
						"parameters{",
						"     DF_max_id as integer (1),",
						"     policyPrefix as string ('CFA')",
						"}",
						"source(output(",
						"          Policy as string,",
						"          Policy_Sequence as string,",
						"          PolicyPrefix as string,",
						"          ProductCode as string,",
						"          LocationNumber as string,",
						"          BuildingNumber as string,",
						"          LocationName as string,",
						"          LocationAddress1 as string,",
						"          LocationAddress2 as string,",
						"          LocationAddress3 as string,",
						"          LocationCity as string,",
						"          LocationZipCode as string,",
						"          LocationCounty as string,",
						"          Territory as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from [dbo].[Location_Address] where  PolicyPrefix = '{$policyPrefix}' and LocationNumber != '000'\"),",
						"     format: 'query') ~> locationAddressSource",
						"source(output(",
						"          GEN_ADDRESS_UNIQ_ID as long,",
						"          ADDRESS_STREET1 as string,",
						"          ADDRESS_STREET2 as string,",
						"          COUNTY_CODE as string,",
						"          COUNTY as string,",
						"          ADDRESS_CITY as string,",
						"          ADD_DESCRIPTION as string,",
						"          STATE_PROVINCE_CODE as string,",
						"          POSTAL_CODE as string,",
						"          POSTAL_CODE_EXT as string,",
						"          COUNTRY_CODE as string,",
						"          SOURCE_INSERTED_ON as timestamp,",
						"          SOURCE_UPDATED_ON as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary,",
						"          TERRITORY as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> genAddressStagingLookup",
						"locationAddressSource select(mapColumn(",
						"          ADDRESS_STREET1 = LocationAddress1,",
						"          ADDRESS_STREET2 = LocationAddress2,",
						"          ADDRESS_CITY = LocationCity,",
						"          POSTAL_CODE = LocationZipCode,",
						"          COUNTY = LocationCounty,",
						"          TERRITORY = Territory",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectRequiredAddressColumns",
						"selectRequiredAddressColumns keyGenerate(output(skey as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> addressSurrogateKey",
						"addressSurrogateKey derive(GEN_ADDRESS_UNIQ_ID = skey + $DF_max_id,",
						"          SOURCE_INSERTED_ON = currentTimestamp(),",
						"          SOURCE_UPDATED_ON = currentTimestamp(),",
						"          SOURCE_KEY = concatWS('', iif(isNull(ADDRESS_STREET1), '', replace(ADDRESS_STREET1, ' ', '')), iif(isNull(ADDRESS_STREET2), '', replace(ADDRESS_STREET2, ' ', '')), iif(isNull(ADDRESS_CITY), '', replace(ADDRESS_CITY, ' ', '')) , iif(isNull(POSTAL_CODE), '', replace(POSTAL_CODE, ' ', '')), iif(isNull(TERRITORY), '', replace(TERRITORY, ' ', '')))) ~> deriveSourceKey",
						"groupBySourceKey, genAddressStagingLookup exists(groupBySourceKey@SOURCE_KEY == genAddressStagingLookup@SOURCE_KEY,",
						"     negate:true,",
						"     broadcast: 'auto')~> alreadyExistsCheck",
						"deriveSourceKey aggregate(groupBy(SOURCE_KEY),",
						"     each(match(name!='SOURCE_KEY'), $$ = first($$))) ~> groupBySourceKey",
						"alreadyExistsCheck sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          GEN_ADDRESS_UNIQ_ID as long,",
						"          ADDRESS_STREET1 as string,",
						"          ADDRESS_STREET2 as string,",
						"          COUNTY_CODE as string,",
						"          COUNTY as string,",
						"          ADDRESS_CITY as string,",
						"          ADD_DESCRIPTION as string,",
						"          STATE_PROVINCE_CODE as string,",
						"          POSTAL_CODE as string,",
						"          POSTAL_CODE_EXT as string,",
						"          COUNTRY_CODE as string,",
						"          SOURCE_INSERTED_ON as timestamp,",
						"          SOURCE_UPDATED_ON as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary,",
						"          TERRITORY as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> genAddressStaging"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ds_source_locationAddress')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_genAddress')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_source_party')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Source Stage Data Flows/referenceDataFlow"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_party",
								"type": "DatasetReference"
							},
							"name": "partySource"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_party",
								"type": "DatasetReference"
							},
							"name": "partyStagingLookup"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_party",
								"type": "DatasetReference"
							},
							"name": "partyStaging"
						}
					],
					"transformations": [
						{
							"name": "metadataflowlet",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "$DF_batch"
								}
							}
						},
						{
							"name": "selectRequiredPartyColumns"
						},
						{
							"name": "partySurrogateKey"
						},
						{
							"name": "deriveOtherRequiredColumns"
						},
						{
							"name": "selectRequiredStagingPartyColumns"
						},
						{
							"name": "derivedFullName"
						},
						{
							"name": "groupByFullName"
						}
					],
					"scriptLines": [
						"parameters{",
						"     DF_batch as integer (1),",
						"     DF_max_id as integer (1)",
						"}",
						"source(output(",
						"          Policy as string,",
						"          Policy_Sequence as string,",
						"          EffectiveDate as timestamp,",
						"          ExpirationDate as timestamp,",
						"          LocationNumber as string,",
						"          LocationUnitNumber as string,",
						"          InsuredNumber as integer,",
						"          InsuredType as string,",
						"          InsuredSubType as string,",
						"          FirstName as string,",
						"          MiddleName as string,",
						"          LastName as string,",
						"          NameSuffix as string,",
						"          CorporateName as string,",
						"          AlternateName as string,",
						"          MailingAddress1 as string,",
						"          MailingAddress2 as string,",
						"          MailingCity as string,",
						"          MailingZipCode as string,",
						"          DOB as date,",
						"          Relationship as string,",
						"          ExcludedDate as date,",
						"          DW_InsertDate as date",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> partySource",
						"source(output(",
						"          PARTY_ID as long,",
						"          PARTY_VID as long,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          NAME_PREFIX as string,",
						"          FIRST_NAME as string,",
						"          MIDDLE_NAME as string,",
						"          LAST_NAME as string,",
						"          FULL_NAME as string,",
						"          DATE_OF_BIRTH as timestamp,",
						"          GENDER as string,",
						"          SSN as string,",
						"          HIRE_DATE as timestamp,",
						"          POLICYINATION_DATE as timestamp,",
						"          EMAIL as string,",
						"          PARTY_IS_ACTIVE_YN as string,",
						"          PARTY_EFF_DATE as timestamp,",
						"          PARTY_EXP_DATE as timestamp,",
						"          PARTY_TYPE as string,",
						"          PHYSICAL_GEN_ADDRESS_ID as long,",
						"          HOME_PHONE_NUMBER as string,",
						"          FAX_NUMBER as string,",
						"          YEARS_WITH_EMPLOYER as integer,",
						"          NAME_SUFFIX as string,",
						"          MARITAL_STATUS as string,",
						"          OCCUPATION as string,",
						"          DOING_BUSINESS_AS as string,",
						"          DECEASED_DATE as timestamp,",
						"          IS_DECEASED_YN as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> partyStagingLookup",
						"deriveOtherRequiredColumns compose(mapParameter(",
						"          FL_batch = $DF_batch",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> metadataflowlet@(output1)",
						"partySource select(mapColumn(",
						"          FIRST_NAME = FirstName,",
						"          MIDDLE_NAME = MiddleName,",
						"          LAST_NAME = LastName,",
						"          GIVEN_FULL_NAME = CorporateName,",
						"          DATE_OF_BIRTH = DOB",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectRequiredPartyColumns",
						"groupByFullName keyGenerate(output(skey as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> partySurrogateKey",
						"partySurrogateKey derive(PARTY_ID = skey + $DF_max_id,",
						"          PARTY_VID = 1,",
						"          PARTY_TYPE = \"INSURED\") ~> deriveOtherRequiredColumns",
						"partyStagingLookup select(mapColumn(",
						"          FIRST_NAME,",
						"          LAST_NAME,",
						"          MIDDLE_NAME,",
						"          FULL_NAME",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectRequiredStagingPartyColumns",
						"selectRequiredPartyColumns derive(FULL_NAME = iif(isNull(GIVEN_FULL_NAME)|| trim(GIVEN_FULL_NAME)=='', concatWS(\" \", trim(FIRST_NAME), trim(MIDDLE_NAME), trim(LAST_NAME)), trim(GIVEN_FULL_NAME))) ~> derivedFullName",
						"derivedFullName aggregate(groupBy(FULL_NAME),",
						"     each(match(name!='FULL_NAME'), $$ = first($$))) ~> groupByFullName",
						"metadataflowlet@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          PARTY_ID as long,",
						"          PARTY_VID as long,",
						"          NAME_PREFIX as string,",
						"          FIRST_NAME as string,",
						"          MIDDLE_NAME as string,",
						"          LAST_NAME as string,",
						"          FULL_NAME as string,",
						"          DATE_OF_BIRTH as timestamp,",
						"          GENDER as string,",
						"          SSN as string,",
						"          HIRE_DATE as timestamp,",
						"          POLICYINATION_DATE as timestamp,",
						"          EMAIL as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          PARTY_TYPE as string,",
						"          PHYSICAL_GEN_ADDRESS_ID as long,",
						"          HOME_PHONE_NUMBER as string,",
						"          FAX_NUMBER as string,",
						"          YEARS_WITH_EMPLOYER as integer,",
						"          NAME_SUFFIX as string,",
						"          MARITAL_STATUS as string,",
						"          OCCUPATION as string,",
						"          DOING_BUSINESS_AS as string,",
						"          DECEASED_DATE as timestamp,",
						"          IS_DECEASED_YN as string,",
						"          GEN_ADDRESS_UNIQ_ID as long,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> partyStaging"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/fl_source_addDefaultColumnFlowlet')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_party')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_party')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_source_policy')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Source Stage Data Flows/txnDataFlow"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_policyCoverage",
								"type": "DatasetReference"
							},
							"name": "ecmPolicyCoverage"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_agency",
								"type": "DatasetReference"
							},
							"name": "polAgencyStg"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_agency",
								"type": "DatasetReference"
							},
							"name": "producerStg"
						},
						{
							"dataset": {
								"referenceName": "ds_ecm_state_code",
								"type": "DatasetReference"
							},
							"name": "stateCode"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policy",
								"type": "DatasetReference"
							},
							"name": "stgPolicyNextPkey"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_policy",
								"type": "DatasetReference"
							},
							"name": "stgPolicy"
						},
						{
							"name": "stateCodeSink"
						},
						{
							"name": "policyPkeyCache"
						}
					],
					"transformations": [
						{
							"name": "flowlet1",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "surrogateKey1"
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "select1"
						},
						{
							"name": "polAgencySrc"
						},
						{
							"name": "producerLookup"
						},
						{
							"name": "insuredLookUp"
						},
						{
							"name": "producerSelect"
						},
						{
							"name": "producerDerviedCol"
						},
						{
							"name": "derivedColumn2"
						}
					],
					"scriptLines": [
						"parameters{",
						"     policyPrefix as string (\"\"),",
						"     policies as string[] ([\"\"])",
						"}",
						"source(output(",
						"          Policy as string,",
						"          ARICLOB as string,",
						"          ARICGroupCode as string,",
						"          Description as string,",
						"          Product as string,",
						"          Occupancy as string,",
						"          ConstructionCode as string,",
						"          ConstructionYear as integer,",
						"          NumberOfFloors as integer,",
						"          ProtectionClass as string,",
						"          GEOLatitude as decimal(11,8),",
						"          GEOLongitude as decimal(11,8),",
						"          CauseOfLoss as string,",
						"          BCEGClassCode as string,",
						"          CoverageForm as string,",
						"          DesignatedPremisis as string,",
						"          WindIndicatorFlag as string,",
						"          PurchaseCost as decimal(8,2),",
						"          CoInsuranceBuilding as integer,",
						"          CoInsurancePersonalProperty as integer,",
						"          CoInsuranceBodilyInjury as integer,",
						"          ISOClassCode as string,",
						"          PolicyPrefix as string,",
						"          CancelDate as timestamp,",
						"          CancelReason as string,",
						"          CancelReasonDescription as string,",
						"          PolicyTermMonths as integer,",
						"          InsuredName as string,",
						"          InsuredAddress1 as string,",
						"          InsuredAddress2 as string,",
						"          InsuredCity as string,",
						"          InsuredState as string,",
						"          InsuredZipCode as string,",
						"          CompanyCode as string,",
						"          CompanyName as string,",
						"          GroupName as string,",
						"          GBLICompanyCode as string,",
						"          AgentCode as string,",
						"          AgentName as string,",
						"          AgentOffice as string,",
						"          GroupCode as string,",
						"          AgentCity as string,",
						"          EMail as string,",
						"          AgentPhone as string,",
						"          AgentCounty as string,",
						"          AgentZipCode as string,",
						"          AgentAddress1 as string,",
						"          AgentAddress2 as string,",
						"          AgentState as string,",
						"          SubProducerNumber as string,",
						"          SubProducerCode as string,",
						"          SubProducerName as string,",
						"          SubproducerState as string,",
						"          SubProducerType as string,",
						"          ProductCode as string,",
						"          ProductCodeDescription as string,",
						"          PreviousPolicy as string,",
						"          OriginalPolicyYear as integer,",
						"          NonRenewalReason as string,",
						"          NonRenewalNoticeDate as timestamp,",
						"          DatabaseCode as string,",
						"          MasterPolicy as string,",
						"          BillingType as string,",
						"          RowStatus as string,",
						"          OriginalInceptionDate as timestamp,",
						"          MultiplePolicyFlag as string,",
						"          ARICBusinessUnit as string,",
						"          HonorCurrentRateFlag as string,",
						"          FarmType as string,",
						"          PrimaryPremiumStateCode as string,",
						"          StateName as string,",
						"          BillingSystem as string,",
						"          ExperienceModFactor as decimal(7,4),",
						"          Exposure as decimal(8,0),",
						"          TaxFeeSurchargeFlag as string,",
						"          Rate as decimal(12,6)",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"SELECT distinct [Policy]  ,[ARICLOB] ,[ARICGroupCode] ,[Description] ,[Product] ,[Occupancy] ,[ConstructionCode] ,[ConstructionYear] ,[NumberOfFloors] ,[ProtectionClass] ,[GEOLatitude] ,[GEOLongitude] ,[CauseOfLoss] ,[BCEGClassCode] ,[CoverageForm] ,[DesignatedPremisis] ,[WindIndicatorFlag] ,[PurchaseCost] ,[CoInsuranceBuilding] ,[CoInsurancePersonalProperty] ,[CoInsuranceBodilyInjury], [ISOClassCode] ,[PolicyPrefix]  ,[CancelDate] ,[CancelReason] ,[CancelReasonDescription] ,[PolicyTermMonths] ,[InsuredName] ,[InsuredAddress1] ,[InsuredAddress2] ,[InsuredCity] ,[InsuredState] ,[InsuredZipCode] ,[CompanyCode] ,[CompanyName] ,[GroupName] ,[GBLICompanyCode] ,[AgentCode] ,[AgentName] ,[AgentOffice] ,[GroupCode] ,[AgentCity] ,[EMail] ,[AgentPhone] ,[AgentCounty] ,[AgentZipCode] ,[AgentAddress1] ,[AgentAddress2] ,[AgentState] ,[SubProducerNumber] ,[SubProducerCode] ,[SubProducerName] ,[SubproducerState] ,[SubProducerType] ,[ProductCode] ,[ProductCodeDescription] ,[PreviousPolicy] ,[OriginalPolicyYear] ,[NonRenewalReason] ,[NonRenewalNoticeDate] ,[DatabaseCode],[MasterPolicy] ,[BillingType] ,[RowStatus] ,[OriginalInceptionDate] ,[MultiplePolicyFlag] ,[ARICBusinessUnit] ,[HonorCurrentRateFlag] ,[FarmType] ,[PrimaryPremiumStateCode] ,[StateName] ,[BillingSystem] ,[ExperienceModFactor] ,[Exposure] ,[TaxFeeSurchargeFlag] , [Rate] FROM [DataStoreARICECM].[dbo].[Policy_Coverage]  where PolicyPrefix='{$policyPrefix}'\"+iif(size($policies) >0&& size($policies) ==1&&$policies[1] =='','','and policy in ('+dropLeft(toString(reduce($policies, \"'\", #acc + \",'\" + #item +\"'\", #result)), 2)+')')),",
						"     format: 'query') ~> ecmPolicyCoverage",
						"source(output(",
						"          AGENCY_ID as long,",
						"          AGENCY_VID as long,",
						"          AGENCY_GEN_ADDRESS_ID as long,",
						"          AGENCY_CODE as string,",
						"          AGENCY_NAME as string,",
						"          AGENCY_STATUS as string,",
						"          AGENCY_CATEGORY as string,",
						"          DIRECT_BILL_FLAG_YN as string,",
						"          TELEPHONE as string,",
						"          FAX as string,",
						"          EMAIL_ID as string,",
						"          WEBSITE as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          ENTITY_TYPE as string,",
						"          ENTITY_PARENT_ID as long,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select * from [dbo].[POL_AGENCY] where  ENTITY_TYPE=\\'AGENCY\\'',",
						"     format: 'query') ~> polAgencyStg",
						"source(output(",
						"          AGENCY_ID as long,",
						"          AGENCY_VID as long,",
						"          AGENCY_GEN_ADDRESS_ID as long,",
						"          AGENCY_CODE as string,",
						"          AGENCY_NAME as string,",
						"          AGENCY_STATUS as string,",
						"          AGENCY_CATEGORY as string,",
						"          DIRECT_BILL_FLAG_YN as string,",
						"          TELEPHONE as string,",
						"          FAX as string,",
						"          EMAIL_ID as string,",
						"          WEBSITE as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          ENTITY_TYPE as string,",
						"          ENTITY_PARENT_ID as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select * from [dbo].[POL_AGENCY]  pa where pa.ENTITY_TYPE=\\'PRODUCER\\'',",
						"     format: 'query') ~> producerStg",
						"source(output(",
						"          StateCode as string,",
						"          StateAbbreviation as string,",
						"          StateName as string,",
						"          WCTypeOfLossGroupCode as string,",
						"          QuickRaterStateID as integer,",
						"          AutoDoNotRenewDays as integer,",
						"          AutoConditionalRenewalNoticeDays as integer,",
						"          AutoUMLimitFlag as string,",
						"          AutoStateBand as string,",
						"          AutoRegionID as integer,",
						"          StateTypeCode as string,",
						"          FIPSStateCode as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> stateCode",
						"source(output(",
						"          POLICY_ID as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select MAX(POLICY_ID) as POLICY_ID from POL_POLICY',",
						"     format: 'query') ~> stgPolicyNextPkey",
						"derivedColumn1 compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet1@(output1)",
						"ecmPolicyCoverage keyGenerate(output(pid as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> surrogateKey1",
						"insuredLookUp derive(POLICY_ID = policyPkeyCache#outputs()[1].POLICY_ID + pid,",
						"          POLICY_VID = 1,",
						"          POLICY_NUMBER = Policy,",
						"          ENTITY_TYPE = PolicyPrefix,",
						"          PAYMENT_PLAN = toString(PolicyTermMonths),",
						"          AGENCY_ID = agencyPKey,",
						"          AGENCY_VID = agencyPvKey,",
						"          PRODUCER_ID = producerDerviedCol@AGENCY_ID,",
						"          PRODUCER_VID = producerDerviedCol@AGENCY_VID,",
						"          LEGACY_POLICY_NUMBER = PreviousPolicy,",
						"          INCEPTION_DATE = OriginalInceptionDate,",
						"          POLICY_STATE_CODE = stateCodeSink#lookup(PrimaryPremiumStateCode).StateAbbreviation) ~> derivedColumn1",
						"polAgencyStg select(mapColumn(",
						"          AGENCY_ID,",
						"          AGENCY_VID,",
						"          AGENCY_CODE,",
						"          AGENCY_NAME,",
						"          ENTITY_TYPE",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"select1 derive(agencyPKey = AGENCY_ID,",
						"          agencyPvKey = AGENCY_VID,",
						"          AGENCY_CODE = AGENCY_CODE) ~> polAgencySrc",
						"surrogateKey1, polAgencySrc lookup(AgentCode == AGENCY_CODE,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> producerLookup",
						"producerLookup, producerDerviedCol lookup(SubProducerCode == producerDerviedCol@AGENCY_CODE,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> insuredLookUp",
						"producerStg select(mapColumn(",
						"          AGENCY_ID,",
						"          AGENCY_VID,",
						"          AGENCY_CODE,",
						"          AGENCY_NAME",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> producerSelect",
						"producerSelect derive(AGENCY_ID = AGENCY_ID,",
						"          AGENCY_VID = AGENCY_VID,",
						"          AGENCY_CODE = AGENCY_CODE) ~> producerDerviedCol",
						"stgPolicyNextPkey derive(POLICY_ID = iifNull(POLICY_ID, 0, POLICY_ID)) ~> derivedColumn2",
						"flowlet1@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          POLICY_ID as long,",
						"          POLICY_VID as long,",
						"          REINSURANCE_DAC as string,",
						"          PREVIOUS_INSURANCE_NO_REMARKS as string,",
						"          AGENCY_ID as long,",
						"          AGENCY_OVID as long,",
						"          PRODUCER_ID as long,",
						"          PRODUCER_OVID as long,",
						"          PRODUCER_CONTACT_ID as long,",
						"          PRODUCER_CONTACT_OVID as long,",
						"          POLICY_NUMBER as string,",
						"          ENTITY_TYPE as string,",
						"          ENTITY_STATUS as string,",
						"          IS_RENEWAL_YN as string,",
						"          REVISION_NUMBER as integer,",
						"          PRODUCT_ID as long,",
						"          PRODUCT_OVID as long,",
						"          POLICY_EFFECTIVE_DATE as timestamp,",
						"          POLICY_EXPIRATION_DATE as timestamp,",
						"          NON_RENEWAL_CODE as string,",
						"          POLICY_RENEWED_YN as string,",
						"          CANCELLATION_DATE as timestamp,",
						"          IS_RENEWABLE_YN as string,",
						"          PREVIOUS_INSURANCE_NO_REASON as string,",
						"          POLICY_STATUS as string,",
						"          CANCEL_REASON_CODE as string,",
						"          CANCEL_REASON_DESCRIPTION as string,",
						"          CANCEL_METHOD as string,",
						"          CANCEL_METHOD_DESC as string,",
						"          LOSE_REASON_CODE as string,",
						"          LOSE_REASON_DESC as string,",
						"          DECLINATION_REASON_CODE as string,",
						"          DECLINATION_REASON_DESC as string,",
						"          NOT_WRITTEN_REASON_CODE as string,",
						"          NOT_WRITTEN_REASON_DESC as string,",
						"          POLICY_STATE_CODE as string,",
						"          PROGRAM_ID as long,",
						"          PROGRAM_OVID as long,",
						"          BILLING_TYPE_CODE as string,",
						"          UNDERWRITING_COMPANY_ID as long,",
						"          UNDERWRITING_COMPANY_OVID as long,",
						"          SUBMISSION_ID as long,",
						"          PREVIOUS_INSURANCE_YN as string,",
						"          LEGACY_POLICY_NUMBER as string,",
						"          STATE as string,",
						"          POLICY_POLICY as integer,",
						"          PAYMENT_PLAN as string,",
						"          APPLICATION_RECEIVED_DATE as timestamp,",
						"          INCEPTION_DATE as timestamp,",
						"          BILL_TYPE as string,",
						"          FORMS_LANGUAGE as string,",
						"          BASE_CURRENCY as string,",
						"          INVOICE_CURRENCY as string,",
						"          PREVIOUS_POLICY_ID as long,",
						"          PREVIOUS_POLICY_OVID as long,",
						"          REVISED_FROM_POLICY_ID as long,",
						"          REVISED_FROM_POLICY_OVID as long,",
						"          OPERATING_COMPANY_ID as long,",
						"          OPERATING_COMPANY_OVID as long,",
						"          CONVERTED_FROM_ID as long,",
						"          CONVERTED_FROM_OVID as long,",
						"          INSTALLMENT_RENEWAL as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> stgPolicy",
						"stateCode sink(validateSchema: false,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     keys:['StateCode'],",
						"     store: 'cache',",
						"     format: 'inline',",
						"     output: false,",
						"     saveOrder: 1) ~> stateCodeSink",
						"derivedColumn2 sink(validateSchema: false,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     store: 'cache',",
						"     format: 'inline',",
						"     output: false,",
						"     saveOrder: 1) ~> policyPkeyCache"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/fl_source_addDefaultColumnFlowlet')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_policyCoverage')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_agency')]",
				"[concat(variables('factoryId'), '/datasets/ds_ecm_state_code')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_policy')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_source_policy_partyrole_bridge')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Source Stage Data Flows/txnDataFlow/bridge"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_party",
								"type": "DatasetReference"
							},
							"name": "EcmParty"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_party",
								"type": "DatasetReference"
							},
							"name": "StagingParty"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policy",
								"type": "DatasetReference"
							},
							"name": "StagingPolicy"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_partyrole",
								"type": "DatasetReference"
							},
							"name": "StagingPartyRole"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policy_partyrole_bridge",
								"type": "DatasetReference"
							},
							"name": "bridgeMaxId"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_policy_partyrole_bridge",
								"type": "DatasetReference"
							},
							"name": "StagingPolicyPartyRoleBridge"
						},
						{
							"name": "maxIdCache"
						}
					],
					"transformations": [
						{
							"name": "flowlet1",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "select1"
						},
						{
							"name": "select2"
						},
						{
							"name": "select3"
						},
						{
							"name": "join1"
						},
						{
							"name": "derivedColumn2"
						},
						{
							"name": "flatten1"
						},
						{
							"name": "derivedColumn4"
						},
						{
							"name": "derivedColumn5"
						},
						{
							"name": "select4"
						},
						{
							"name": "join2"
						},
						{
							"name": "sourceStagePartyLookup"
						},
						{
							"name": "surrogateKey2"
						},
						{
							"name": "derivedColumn6"
						},
						{
							"name": "filter1"
						},
						{
							"name": "filter2"
						},
						{
							"name": "filter3"
						},
						{
							"name": "lookup1"
						},
						{
							"name": "select5"
						}
					],
					"scriptLines": [
						"parameters{",
						"     policies as string[] (['']),",
						"     policyPrefix as string ('')",
						"}",
						"source(output(",
						"          Policy as string,",
						"          Policy_Sequence as string,",
						"          EffectiveDate as timestamp,",
						"          ExpirationDate as timestamp,",
						"          LocationNumber as string,",
						"          LocationUnitNumber as string,",
						"          InsuredNumber as short,",
						"          InsuredType as string,",
						"          InsuredSubType as string,",
						"          FirstName as string,",
						"          MiddleName as string,",
						"          LastName as string,",
						"          NameSuffix as string,",
						"          CorporateName as string,",
						"          AlternateName as string,",
						"          MailingAddress1 as string,",
						"          MailingAddress2 as string,",
						"          MailingCity as string,",
						"          MailingZipCode as string,",
						"          DOB as date,",
						"          Relationship as string,",
						"          ExcludedDate as date,",
						"          DW_InsertDate as date",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from Additional_Insured \"+iif(size($policies) >0&& size($policies) ==1&&$policies[1] =='','','where policy in ('+dropLeft(toString(reduce($policies, \"'\", #acc + \",'\" + #item +\"'\", #result)), 2)+')')),",
						"     format: 'query') ~> EcmParty",
						"source(output(",
						"          PARTY_ID as long,",
						"          PARTY_VID as long,",
						"          NAME_PREFIX as string,",
						"          FIRST_NAME as string,",
						"          MIDDLE_NAME as string,",
						"          LAST_NAME as string,",
						"          FULL_NAME as string,",
						"          DATE_OF_BIRTH as timestamp,",
						"          GENDER as string,",
						"          SSN as string,",
						"          HIRE_DATE as timestamp,",
						"          POLICYINATION_DATE as timestamp,",
						"          EMAIL as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          PARTY_TYPE as string,",
						"          PHYSICAL_GEN_ADDRESS_ID as long,",
						"          HOME_PHONE_NUMBER as string,",
						"          FAX_NUMBER as string,",
						"          YEARS_WITH_EMPLOYER as integer,",
						"          NAME_SUFFIX as string,",
						"          MARITAL_STATUS as string,",
						"          OCCUPATION as string,",
						"          DOING_BUSINESS_AS as string,",
						"          DECEASED_DATE as timestamp,",
						"          IS_DECEASED_YN as string,",
						"          GEN_ADDRESS_UNIQ_ID as long,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select * from POL_PARTY',",
						"     format: 'query') ~> StagingParty",
						"source(output(",
						"          POLICY_ID as long,",
						"          POLICY_VID as long,",
						"          REINSURANCE_DAC as string,",
						"          PREVIOUS_INSURANCE_NO_REMARKS as string,",
						"          AGENCY_ID as long,",
						"          AGENCY_OVID as long,",
						"          PRODUCER_ID as long,",
						"          PRODUCER_OVID as long,",
						"          PRODUCER_CONTACT_ID as long,",
						"          PRODUCER_CONTACT_OVID as long,",
						"          POLICY_NUMBER as string,",
						"          ENTITY_TYPE as string,",
						"          ENTITY_STATUS as string,",
						"          IS_RENEWAL_YN as string,",
						"          REVISION_NUMBER as integer,",
						"          PRODUCT_ID as long,",
						"          PRODUCT_OVID as long,",
						"          POLICY_EFFECTIVE_DATE as timestamp,",
						"          POLICY_EXPIRATION_DATE as timestamp,",
						"          NON_RENEWAL_CODE as string,",
						"          POLICY_RENEWED_YN as string,",
						"          CANCELLATION_DATE as timestamp,",
						"          IS_RENEWABLE_YN as string,",
						"          PREVIOUS_INSURANCE_NO_REASON as string,",
						"          POLICY_STATUS as string,",
						"          CANCEL_REASON_CODE as string,",
						"          CANCEL_REASON_DESCRIPTION as string,",
						"          CANCEL_METHOD as string,",
						"          CANCEL_METHOD_DESC as string,",
						"          LOSE_REASON_CODE as string,",
						"          LOSE_REASON_DESC as string,",
						"          DECLINATION_REASON_CODE as string,",
						"          DECLINATION_REASON_DESC as string,",
						"          NOT_WRITTEN_REASON_CODE as string,",
						"          NOT_WRITTEN_REASON_DESC as string,",
						"          POLICY_STATE_CODE as string,",
						"          PROGRAM_ID as long,",
						"          PROGRAM_OVID as long,",
						"          BILLING_TYPE_CODE as string,",
						"          UNDERWRITING_COMPANY_ID as long,",
						"          UNDERWRITING_COMPANY_OVID as long,",
						"          SUBMISSION_ID as long,",
						"          PREVIOUS_INSURANCE_YN as string,",
						"          LEGACY_POLICY_NUMBER as string,",
						"          POLICY_POLICY as short,",
						"          PAYMENT_PLAN as string,",
						"          APPLICATION_RECEIVED_DATE as timestamp,",
						"          INCEPTION_DATE as timestamp,",
						"          BILL_TYPE as string,",
						"          FORMS_LANGUAGE as string,",
						"          BASE_CURRENCY as string,",
						"          INVOICE_CURRENCY as string,",
						"          PREVIOUS_POLICY_ID as long,",
						"          PREVIOUS_POLICY_OVID as long,",
						"          REVISED_FROM_POLICY_ID as long,",
						"          REVISED_FROM_POLICY_OVID as long,",
						"          OPERATING_COMPANY_ID as long,",
						"          OPERATING_COMPANY_OVID as long,",
						"          CONVERTED_FROM_ID as long,",
						"          CONVERTED_FROM_OVID as long,",
						"          INSTALLMENT_RENEWAL as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from POL_POLICY where policy_number like '{$policyPrefix}%'\"+iif(size($policies) >0&& size($policies) ==1&&$policies[1] =='','','and policy_number in ('+dropLeft(toString(reduce($policies, \"'\", #acc + \",'\" + #item +\"'\", #result)), 2)+')')),",
						"     format: 'query') ~> StagingPolicy",
						"source(output(",
						"          ROLE_ID as long,",
						"          ROLE_VID as long,",
						"          ROLE_CODE as string,",
						"          ROLE_DESCRIPTION as string,",
						"          IS_PRIMARY_INSURED_YN as string,",
						"          IS_DRIVER_YN as string,",
						"          IS_CUSTOMER_YN as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> StagingPartyRole",
						"source(output(",
						"          maxId as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT isnull(MAX(POLICY_PARTY_ROLE_BRIDGE_ID), 0) as maxId\\nFROM dbo.POL_POLICY_PARTY_ROLE_BRIDGE',",
						"     format: 'query') ~> bridgeMaxId",
						"derivedColumn6 compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet1@(output1)",
						"EcmParty derive(full_name = iif(isNull(CorporateName)|| trim(CorporateName)=='', concatWS(\" \", trim(FirstName), trim(MiddleName), trim(LastName)), trim(CorporateName))) ~> derivedColumn1",
						"StagingParty select(mapColumn(",
						"          PARTY_ID,",
						"          PARTY_OVID = PARTY_VID,",
						"          FULL_NAME",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"derivedColumn1 select(mapColumn(",
						"          full_name,",
						"          policy = Policy",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select2",
						"StagingPolicy select(mapColumn(",
						"          POLICY_ID,",
						"          POLICY_OVID = POLICY_VID,",
						"          AGENCY_ID,",
						"          AGENCY_OVID,",
						"          PRODUCER_ID,",
						"          PRODUCER_OVID,",
						"          POLICY_NUMBER",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select3",
						"select3, sourceStagePartyLookup join(POLICY_NUMBER == policy,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"filter3 derive(party_id_array = [PARTY_ID,AGENCY_ID,PRODUCER_ID],",
						"          party_ovid_array = [iif(isNull(PARTY_OVID), toLong(1), PARTY_OVID),iif(isNull(AGENCY_OVID), toLong(1), AGENCY_OVID),iif(isNull(PRODUCER_OVID), toLong(1), PRODUCER_OVID)],",
						"          role_array = ['INSURED', 'AGENCY', 'PRODUCER']) ~> derivedColumn2",
						"derivedColumn4 foldDown(unroll(final_array),",
						"     mapColumn(",
						"          POLICY_ID,",
						"          POLICY_OVID,",
						"          final_array",
						"     ),",
						"     skipDuplicateMapInputs: false,",
						"     skipDuplicateMapOutputs: false) ~> flatten1",
						"derivedColumn2 derive(final_array = mapIndex(party_id_array, toString(#item)+'_'+toString(party_ovid_array[#index])+'_'+role_array[#index])) ~> derivedColumn4",
						"flatten1 derive(PARTY_ID = toLong(split(toString(final_array), \"_\")[1]),",
						"          PARTY_OVID = toLong(split(toString(final_array), \"_\")[2]),",
						"          ROLE = split(toString(final_array), \"_\")[3],",
						"          SOURCE_SYSTEM = 'ECM') ~> derivedColumn5",
						"StagingPartyRole select(mapColumn(",
						"          ROLE_ID,",
						"          ROLE_OVID = ROLE_VID,",
						"          ROLE_CODE",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select4",
						"derivedColumn5, select4 join(ROLE == ROLE_CODE,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join2",
						"select2, select1 join(select2@full_name == select1@FULL_NAME,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> sourceStagePartyLookup",
						"filter1 keyGenerate(output(skey as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> surrogateKey2",
						"surrogateKey2 derive(POLICY_PARTY_ROLE_BRIDGE_ID = skey+maxIdCache#outputs()[1].maxId) ~> derivedColumn6",
						"select5 filter(!isNull(POLICY_ID) && !isNull(ROLE_ID) && !isNull(PARTY_ID) && !isNull(POLICY_OVID) && !isNull(ROLE_OVID) && !isNull(PARTY_OVID)) ~> filter1",
						"sourceStagePartyLookup filter(startsWith(policy, 'EMP')) ~> filter2",
						"join1 filter(!isNull(PARTY_ID)) ~> filter3",
						"join2, select1 lookup(derivedColumn5@PARTY_ID == select1@PARTY_ID,",
						"     multiple: false,",
						"     pickup: 'first',",
						"     asc(select1@PARTY_ID, true),",
						"     broadcast: 'auto')~> lookup1",
						"lookup1 select(mapColumn(",
						"          POLICY_ID,",
						"          POLICY_OVID,",
						"          final_array,",
						"          ROLE,",
						"          SOURCE_SYSTEM,",
						"          ROLE_ID,",
						"          ROLE_OVID,",
						"          ROLE_CODE,",
						"          PARTY_ID = select1@PARTY_ID,",
						"          PARTY_OVID = select1@PARTY_OVID,",
						"          FULL_NAME",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select5",
						"flowlet1@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          POLICY_PARTY_ROLE_BRIDGE_ID as long,",
						"          ROLE_ID as long,",
						"          ROLE_OVID as long,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          PARTY_ID as long,",
						"          PARTY_OVID as long,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          SOURCE_SYSTEM as string,",
						"          SOURCE_KEY as string,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DATA_HASH as binary,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> StagingPolicyPartyRoleBridge",
						"bridgeMaxId sink(validateSchema: false,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     store: 'cache',",
						"     format: 'inline',",
						"     output: false,",
						"     saveOrder: 1) ~> maxIdCache"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/fl_source_addDefaultColumnFlowlet')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_party')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_party')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_policy')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_partyrole')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_policy_partyrole_bridge')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_source_policy_premium')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Source Stage Data Flows/txnDataFlow"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_txnBridge",
								"type": "DatasetReference"
							},
							"name": "StagingPolTxn"
						},
						{
							"dataset": {
								"referenceName": "ds_source_Fact_Coverage_Premium",
								"type": "DatasetReference"
							},
							"name": "FactCoveragePremium"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policy",
								"type": "DatasetReference"
							},
							"name": "StagingPolicy"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_polTxn",
								"type": "DatasetReference"
							},
							"name": "source1"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_polTxnPremium",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "flowlet1",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "select1"
						},
						{
							"name": "lookup2"
						},
						{
							"name": "select2"
						},
						{
							"name": "lookup3"
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "join1"
						}
					],
					"scriptLines": [
						"parameters{",
						"     policyPrefix as string,",
						"     policies as string[]",
						"}",
						"source(output(",
						"          TX_BRIDGE_ID as long,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          TX_ID as long,",
						"          SECTION_ID as long,",
						"          SECTION_VID as long,",
						"          RISK_ID as long,",
						"          RISK_OVID as long,",
						"          CLASSIFICATION_ID as long,",
						"          CLASSIFICATION_OVID as long,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          DATA_HASH as binary,",
						"          SOURCE_KEY as string,",
						"          COVERAGE_ID as long,",
						"          COVERAGE_VID as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> StagingPolTxn",
						"source(output(",
						"          Policy as string,",
						"          Policy_Sequence as string,",
						"          PolicyPrefix as string,",
						"          ARICLOB as string,",
						"          ARICGroupCode as string,",
						"          Description as string,",
						"          Product as string,",
						"          ARICCoverageCode as string,",
						"          ARICCoverageDescription as string,",
						"          PrimaryPremiumStateCode as string,",
						"          LocationNumber as string,",
						"          LocationUnitNumber as string,",
						"          ARICCoverageSequence as integer,",
						"          CoveragePart as string,",
						"          CoverageAddDate as timestamp,",
						"          CoverageDescription as string,",
						"          Limit1 as decimal(38,0),",
						"          Limit2 as decimal(38,0),",
						"          PremiumAmount as decimal(38,2)",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from Fact_Coverage_Premium where PolicyPrefix='{$policyPrefix}'\"+iif(size($policies) >0&& size($policies) ==1&&$policies[1] =='','','and policy in ('+dropLeft(toString(reduce($policies, \"'\", #acc + \",'\" + #item +\"'\", #result)), 2)+')')),",
						"     format: 'query') ~> FactCoveragePremium",
						"source(output(",
						"          POLICY_ID as long,",
						"          POLICY_VID as long,",
						"          REINSURANCE_DAC as string,",
						"          PREVIOUS_INSURANCE_NO_REMARKS as string,",
						"          AGENCY_ID as long,",
						"          AGENCY_OVID as long,",
						"          PRODUCER_ID as long,",
						"          PRODUCER_OVID as long,",
						"          PRODUCER_CONTACT_ID as long,",
						"          PRODUCER_CONTACT_OVID as long,",
						"          POLICY_NUMBER as string,",
						"          ENTITY_TYPE as string,",
						"          ENTITY_STATUS as string,",
						"          IS_RENEWAL_YN as string,",
						"          REVISION_NUMBER as integer,",
						"          PRODUCT_ID as long,",
						"          PRODUCT_OVID as long,",
						"          POLICY_EFFECTIVE_DATE as timestamp,",
						"          POLICY_EXPIRATION_DATE as timestamp,",
						"          NON_RENEWAL_CODE as string,",
						"          POLICY_RENEWED_YN as string,",
						"          CANCELLATION_DATE as timestamp,",
						"          IS_RENEWABLE_YN as string,",
						"          PREVIOUS_INSURANCE_NO_REASON as string,",
						"          POLICY_STATUS as string,",
						"          CANCEL_REASON_CODE as string,",
						"          CANCEL_REASON_DESCRIPTION as string,",
						"          CANCEL_METHOD as string,",
						"          CANCEL_METHOD_DESC as string,",
						"          LOSE_REASON_CODE as string,",
						"          LOSE_REASON_DESC as string,",
						"          DECLINATION_REASON_CODE as string,",
						"          DECLINATION_REASON_DESC as string,",
						"          NOT_WRITTEN_REASON_CODE as string,",
						"          NOT_WRITTEN_REASON_DESC as string,",
						"          POLICY_STATE_CODE as string,",
						"          PROGRAM_ID as long,",
						"          PROGRAM_OVID as long,",
						"          BILLING_TYPE_CODE as string,",
						"          UNDERWRITING_COMPANY_ID as long,",
						"          UNDERWRITING_COMPANY_OVID as long,",
						"          SUBMISSION_ID as long,",
						"          PREVIOUS_INSURANCE_YN as string,",
						"          LEGACY_POLICY_NUMBER as string,",
						"          STATE as string,",
						"          POLICY_POLICY as integer,",
						"          PAYMENT_PLAN as string,",
						"          APPLICATION_RECEIVED_DATE as timestamp,",
						"          INCEPTION_DATE as timestamp,",
						"          BILL_TYPE as string,",
						"          FORMS_LANGUAGE as string,",
						"          BASE_CURRENCY as string,",
						"          INVOICE_CURRENCY as string,",
						"          PREVIOUS_POLICY_ID as long,",
						"          PREVIOUS_POLICY_OVID as long,",
						"          REVISED_FROM_POLICY_ID as long,",
						"          REVISED_FROM_POLICY_OVID as long,",
						"          OPERATING_COMPANY_ID as long,",
						"          OPERATING_COMPANY_OVID as long,",
						"          CONVERTED_FROM_ID as long,",
						"          CONVERTED_FROM_OVID as long,",
						"          INSTALLMENT_RENEWAL as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from [dbo].[POL_POLICY] where ENTITY_TYPE ='{$policyPrefix}' \"+iif(size($policies) >0&& size($policies) ==1&&$policies[1] =='','','and policy_number in ('+dropLeft(toString(reduce($policies, \"'\", #acc + \",'\" + #item +\"'\", #result)), 2)+')')),",
						"     format: 'query') ~> StagingPolicy",
						"source(output(",
						"          TX_ID as long,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          TX_CODE as string,",
						"          SUB_ACTIVITY as string,",
						"          ENDORSEMENT_SEQ_NO as integer,",
						"          IS_SYSTEM_GENERATED_YN as string,",
						"          ENDORSEMENT_CHANGES as string,",
						"          TRANSACTION_EFFECTIVE_DATE as timestamp,",
						"          TRANSACTION_EXPIRY_DATE as timestamp,",
						"          TRANSACTION_BOOK_FLAG_DATE as timestamp,",
						"          PARENT_TRANSACTION_ID as integer,",
						"          TRANSACTION_TYPE_CODE as string,",
						"          TYPE_OF_CHANGE as string,",
						"          TRANSACTION_CREATED_DATE as timestamp,",
						"          TRANSACTION_MODIFIED_DATE as timestamp,",
						"          TRANSACTION_DISPLAY_NAME as string,",
						"          TRANSACTION_PERIOD_PRORATION as decimal(19,9),",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          DATA_HASH as binary,",
						"          SOURCE_KEY as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> source1",
						"derivedColumn1 compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet1@(output1)",
						"StagingPolicy select(mapColumn(",
						"          POLICY_ID,",
						"          POLICY_VID,",
						"          POLICY_NUMBER",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"lookup3, FactCoveragePremium lookup(POLICY_NUMBER == Policy",
						"     && TX_CODE == concat(Policy_Sequence,'-',LocationNumber,'-',LocationUnitNumber,'-',ARICGroupCode,'-',PrimaryPremiumStateCode,'-', ARICLOB,'-',ARICCoverageCode,'-',toString(ARICCoverageSequence)),",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lookup2",
						"source1 select(mapColumn(",
						"          TX_ID,",
						"          TX_CODE",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select2",
						"join1, select2 lookup(StagingPolTxn@TX_ID == select2@TX_ID,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lookup3",
						"lookup2 derive(TX_ID = StagingPolTxn@TX_ID,",
						"          TX_BRIDGE_ID = TX_BRIDGE_ID,",
						"          POLICY_ID = StagingPolTxn@POLICY_ID,",
						"          POLICY_OVID = POLICY_OVID,",
						"          FULL_POLICY_AMOUNT = PremiumAmount) ~> derivedColumn1",
						"StagingPolTxn, select1 join(StagingPolTxn@POLICY_ID == select1@POLICY_ID,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"flowlet1@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          AGENCY_ID as long,",
						"          AGENCY_VID as long,",
						"          AGENCY_GEN_ADDRESS_ID as long,",
						"          AGENCY_CODE as string,",
						"          AGENCY_NAME as string,",
						"          AGENCY_STATUS as string,",
						"          AGENCY_CATEGORY as string,",
						"          DIRECT_BILL_FLAG_YN as string,",
						"          TELEPHONE as string,",
						"          FAX as string,",
						"          EMAIL_ID as string,",
						"          WEBSITE as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          ENTITY_TYPE as string,",
						"          ENTITY_PARENT_ID as long",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink1"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/fl_source_addDefaultColumnFlowlet')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_txnBridge')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_Fact_Coverage_Premium')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_policy')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_polTxn')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_polTxnPremium')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_source_policy_risk_cfa')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Source Stage Data Flows/txnDataFlow"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_PolicyAutoUnit",
								"type": "DatasetReference"
							},
							"name": "autoUnitSource"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policy",
								"type": "DatasetReference"
							},
							"name": "stgPolicy"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRisk",
								"type": "DatasetReference"
							},
							"name": "riskStaging"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRisk",
								"type": "DatasetReference"
							},
							"name": "PolRisk"
						},
						{
							"name": "maxId"
						}
					],
					"transformations": [
						{
							"name": "flowlet1",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "derivedColumn6"
						},
						{
							"name": "surrogateKey1"
						},
						{
							"name": "join1"
						}
					],
					"scriptLines": [
						"parameters{",
						"     policyPrefix as string,",
						"     policies as string[]",
						"}",
						"source(output(",
						"          PolicyPrefix as string,",
						"          Policy as string,",
						"          Policy_Sequence as string,",
						"          RowStatus as string,",
						"          EffectiveDate as timestamp,",
						"          ExpirationDate as timestamp,",
						"          LocationNumber as string,",
						"          LocationUnitNumber as string,",
						"          {UnitType/ModificationType} as string,",
						"          YearBuild as short,",
						"          UnitValue as decimal(13,0),",
						"          RiskUseCode as string,",
						"          Make as string,",
						"          Model as string,",
						"          UnitWidth as short,",
						"          ISOClassCode as string,",
						"          RiskType as string,",
						"          UnitLength as short,",
						"          PurchaseDate as timestamp,",
						"          AppraisalYear as short,",
						"          UnitDescription as string,",
						"          AnimalUseCode as string,",
						"          LeaseFlag as string,",
						"          AppraisalFlag as string,",
						"          RegistrationState as string,",
						"          VehicleID as string,",
						"          EngineDisplacement as short,",
						"          FuelTypeCode as string,",
						"          Layup as string,",
						"          ID as integer,",
						"          DataSource as string,",
						"          DW_InsertDate as date",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from [dbo].[PolicyAutoUnit_P]  where PolicyPrefix='{$policyPrefix}'\"+iif(size($policies) >0&& size($policies) ==1&&$policies[1] =='','','and policy in ('+dropLeft(toString(reduce($policies, \"'\", #acc + \",'\" + #item +\"'\", #result)), 2)+')')),",
						"     format: 'query') ~> autoUnitSource",
						"source(output(",
						"          POLICY_ID as long,",
						"          POLICY_VID as long,",
						"          REINSURANCE_DAC as string,",
						"          PREVIOUS_INSURANCE_NO_REMARKS as string,",
						"          AGENCY_ID as long,",
						"          AGENCY_OVID as long,",
						"          PRODUCER_ID as long,",
						"          PRODUCER_OVID as long,",
						"          PRODUCER_CONTACT_ID as long,",
						"          PRODUCER_CONTACT_OVID as long,",
						"          POLICY_NUMBER as string,",
						"          ENTITY_TYPE as string,",
						"          ENTITY_STATUS as string,",
						"          IS_RENEWAL_YN as string,",
						"          REVISION_NUMBER as integer,",
						"          PRODUCT_ID as long,",
						"          PRODUCT_OVID as long,",
						"          POLICY_EFFECTIVE_DATE as timestamp,",
						"          POLICY_EXPIRATION_DATE as timestamp,",
						"          NON_RENEWAL_CODE as string,",
						"          POLICY_RENEWED_YN as string,",
						"          CANCELLATION_DATE as timestamp,",
						"          IS_RENEWABLE_YN as string,",
						"          PREVIOUS_INSURANCE_NO_REASON as string,",
						"          POLICY_STATUS as string,",
						"          CANCEL_REASON_CODE as string,",
						"          CANCEL_REASON_DESCRIPTION as string,",
						"          CANCEL_METHOD as string,",
						"          CANCEL_METHOD_DESC as string,",
						"          LOSE_REASON_CODE as string,",
						"          LOSE_REASON_DESC as string,",
						"          DECLINATION_REASON_CODE as string,",
						"          DECLINATION_REASON_DESC as string,",
						"          NOT_WRITTEN_REASON_CODE as string,",
						"          NOT_WRITTEN_REASON_DESC as string,",
						"          POLICY_STATE_CODE as string,",
						"          PROGRAM_ID as long,",
						"          PROGRAM_OVID as long,",
						"          BILLING_TYPE_CODE as string,",
						"          UNDERWRITING_COMPANY_ID as long,",
						"          UNDERWRITING_COMPANY_OVID as long,",
						"          SUBMISSION_ID as long,",
						"          PREVIOUS_INSURANCE_YN as string,",
						"          LEGACY_POLICY_NUMBER as string,",
						"          STATE as string,",
						"          POLICY_POLICY as integer,",
						"          PAYMENT_PLAN as string,",
						"          APPLICATION_RECEIVED_DATE as timestamp,",
						"          INCEPTION_DATE as timestamp,",
						"          BILL_TYPE as string,",
						"          FORMS_LANGUAGE as string,",
						"          BASE_CURRENCY as string,",
						"          INVOICE_CURRENCY as string,",
						"          PREVIOUS_POLICY_ID as long,",
						"          PREVIOUS_POLICY_OVID as long,",
						"          REVISED_FROM_POLICY_ID as long,",
						"          REVISED_FROM_POLICY_OVID as long,",
						"          OPERATING_COMPANY_ID as long,",
						"          OPERATING_COMPANY_OVID as long,",
						"          CONVERTED_FROM_ID as long,",
						"          CONVERTED_FROM_OVID as long,",
						"          INSTALLMENT_RENEWAL as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from POL_POLICY where policy_number like '{$policyPrefix}%'\"+iif(size($policies) >0&& size($policies) ==1&&$policies[1] =='','','and policy_number in ('+dropLeft(toString(reduce($policies, \"'\", #acc + \",'\" + #item +\"'\", #result)), 2)+')')),",
						"     format: 'query') ~> stgPolicy",
						"source(output(",
						"          riskid as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select isNull(MAX(RISK_ID),0) as riskid from POL_RISK',",
						"     format: 'query') ~> riskStaging",
						"derivedColumn6 compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet1@(output1)",
						"surrogateKey1 derive(RISK_ID = skey + maxId#outputs()[1].riskid,",
						"          RISK_VID = 1,",
						"          POLICY_ID = POLICY_ID,",
						"          RISK_IS_ACTIVE_YN = \"Y\",",
						"          RISK_EFF_DATE = EffectiveDate,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_EXP_DATE = ExpirationDate,",
						"          POLICY_OVID = POLICY_VID,",
						"          RISK_CODE = {UnitType/ModificationType},",
						"          RISK_NUMBER = concat(LocationNumber,'-',LocationUnitNumber)) ~> derivedColumn6",
						"join1 keyGenerate(output(skey as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> surrogateKey1",
						"autoUnitSource, stgPolicy join(Policy == POLICY_NUMBER,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"flowlet1@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_NUMBER as string,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          RISK_IS_ACTIVE_YN as string,",
						"          RISK_EFF_DATE as timestamp,",
						"          RISK_EXP_DATE as timestamp,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> PolRisk",
						"riskStaging sink(validateSchema: false,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     store: 'cache',",
						"     format: 'inline',",
						"     output: false,",
						"     saveOrder: 1) ~> maxId"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/fl_source_addDefaultColumnFlowlet')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_PolicyAutoUnit')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_policy')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_policyRisk')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_source_policy_risk_emp')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Source Stage Data Flows/txnDataFlow"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_propertyUnits",
								"type": "DatasetReference"
							},
							"name": "PropertyUnits"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policy",
								"type": "DatasetReference"
							},
							"name": "stgPolicy"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRisk",
								"type": "DatasetReference"
							},
							"name": "riskStaging"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRisk",
								"type": "DatasetReference"
							},
							"name": "PolRisk"
						},
						{
							"name": "maxId"
						}
					],
					"transformations": [
						{
							"name": "flowlet1",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "stgPolicySelect"
						},
						{
							"name": "derivedColumn6"
						},
						{
							"name": "surrogateKey1"
						},
						{
							"name": "join1"
						}
					],
					"scriptLines": [
						"parameters{",
						"     policyPrefix as string,",
						"     policies as string[]",
						"}",
						"source(output(",
						"          PolicyPrefix as string,",
						"          Policy as string,",
						"          Policy_Sequence as string,",
						"          RowStatus as string,",
						"          EffectiveDate as timestamp,",
						"          ExpirationDate as timestamp,",
						"          LocationNumber as string,",
						"          LocationUnitNumber as string,",
						"          {UnitType/ModificationType} as string,",
						"          YearBuild as short,",
						"          UnitValue as decimal(13,0),",
						"          SquareFootage as integer,",
						"          RiskUseCode as string,",
						"          Occupancy as string,",
						"          RoofTypeCode as string,",
						"          RoofYear as short,",
						"          Make as string,",
						"          Model as string,",
						"          SerialNumber as string,",
						"          UnitWidth as short,",
						"          RiskType as string,",
						"          UnitLength as short,",
						"          PurchasePrice as decimal(9,0),",
						"          PurchaseDate as timestamp,",
						"          NewUsed as string,",
						"          ProtectionClass as string,",
						"          NumberOfSections as decimal(1,0),",
						"          AppraisalYear as short,",
						"          AppraisedValue as decimal(9,0),",
						"          ConstructionTypeCode as string,",
						"          ParkCode as string,",
						"          OrdinanceLawPercent as decimal(5,2),",
						"          PropertyLossScore as string,",
						"          ProtectedRiskFlag as string,",
						"          PreferredRiskFlag as string,",
						"          ReplaceOrFullRepair as string,",
						"          MineSubsidenceFlag as string,",
						"          NumberOfStories as decimal(3,0),",
						"          InZoneFlag as string,",
						"          BasicFlag as string,",
						"          DwellingUnits as string,",
						"          ElectricSystemTypeCode as string,",
						"          PlumbingSystemTypeCode as string,",
						"          ExtentOfRoofUpdateCode as string,",
						"          ElectricSystemYear as short,",
						"          ExtentOfElectricSystemUpdate as string,",
						"          PlumbingSystemYear as short,",
						"          ExtentOfPlumbingSystemUpdate as string,",
						"          HeatingSystemYear as short,",
						"          ExtentOfHeatingSystemUpdate as string,",
						"          MilesToFireDepartmentCode as string,",
						"          FeetToHydrantCode as string,",
						"          UnitDescription as string,",
						"          InflationGuardPercent as decimal(6,3),",
						"          NumberOfHouseholds as short,",
						"          AnimalUseCode as string,",
						"          AnimalOtherUse as string,",
						"          LeaseFlag as string,",
						"          ID as integer,",
						"          DataSource as string,",
						"          FirelineScore as string,",
						"          FirelineStatus as string,",
						"          FirelineDate as timestamp,",
						"          AnimalDOB as timestamp,",
						"          AnimalName as string,",
						"          AnimalBreed as string,",
						"          AnimalBreedOtherDescription as string,",
						"          AnimalSireName as string,",
						"          AnimalDamName as string,",
						"          AnimalSex as string,",
						"          DW_InsertDate as date,",
						"          CoveragePart as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from [dbo].[PolicyPropertyUnit_P]  where TRIM(AnimalUseCode) != '?' and TRIM(RowStatus) != 'D' and (TRIM(AnimalBreed) != '' or TRIM(AnimalUseCode) != '') and PolicyPrefix='{$policyPrefix}'\"+iif(size($policies) >0&& size($policies) ==1&&$policies[1] =='','','and policy in ('+dropLeft(toString(reduce($policies, \"'\", #acc + \",'\" + #item +\"'\", #result)), 2)+')')),",
						"     format: 'query') ~> PropertyUnits",
						"source(output(",
						"          POLICY_ID as long,",
						"          POLICY_VID as long,",
						"          REINSURANCE_DAC as string,",
						"          PREVIOUS_INSURANCE_NO_REMARKS as string,",
						"          AGENCY_ID as long,",
						"          AGENCY_OVID as long,",
						"          PRODUCER_ID as long,",
						"          PRODUCER_OVID as long,",
						"          PRODUCER_CONTACT_ID as long,",
						"          PRODUCER_CONTACT_OVID as long,",
						"          POLICY_NUMBER as string,",
						"          ENTITY_TYPE as string,",
						"          ENTITY_STATUS as string,",
						"          IS_RENEWAL_YN as string,",
						"          REVISION_NUMBER as integer,",
						"          PRODUCT_ID as long,",
						"          PRODUCT_OVID as long,",
						"          POLICY_EFFECTIVE_DATE as timestamp,",
						"          POLICY_EXPIRATION_DATE as timestamp,",
						"          NON_RENEWAL_CODE as string,",
						"          POLICY_RENEWED_YN as string,",
						"          CANCELLATION_DATE as timestamp,",
						"          IS_RENEWABLE_YN as string,",
						"          PREVIOUS_INSURANCE_NO_REASON as string,",
						"          POLICY_STATUS as string,",
						"          CANCEL_REASON_CODE as string,",
						"          CANCEL_REASON_DESCRIPTION as string,",
						"          CANCEL_METHOD as string,",
						"          CANCEL_METHOD_DESC as string,",
						"          LOSE_REASON_CODE as string,",
						"          LOSE_REASON_DESC as string,",
						"          DECLINATION_REASON_CODE as string,",
						"          DECLINATION_REASON_DESC as string,",
						"          NOT_WRITTEN_REASON_CODE as string,",
						"          NOT_WRITTEN_REASON_DESC as string,",
						"          POLICY_STATE_CODE as string,",
						"          PROGRAM_ID as long,",
						"          PROGRAM_OVID as long,",
						"          BILLING_TYPE_CODE as string,",
						"          UNDERWRITING_COMPANY_ID as long,",
						"          UNDERWRITING_COMPANY_OVID as long,",
						"          SUBMISSION_ID as long,",
						"          PREVIOUS_INSURANCE_YN as string,",
						"          LEGACY_POLICY_NUMBER as string,",
						"          STATE as string,",
						"          POLICY_POLICY as integer,",
						"          PAYMENT_PLAN as string,",
						"          APPLICATION_RECEIVED_DATE as timestamp,",
						"          INCEPTION_DATE as timestamp,",
						"          BILL_TYPE as string,",
						"          FORMS_LANGUAGE as string,",
						"          BASE_CURRENCY as string,",
						"          INVOICE_CURRENCY as string,",
						"          PREVIOUS_POLICY_ID as long,",
						"          PREVIOUS_POLICY_OVID as long,",
						"          REVISED_FROM_POLICY_ID as long,",
						"          REVISED_FROM_POLICY_OVID as long,",
						"          OPERATING_COMPANY_ID as long,",
						"          OPERATING_COMPANY_OVID as long,",
						"          CONVERTED_FROM_ID as long,",
						"          CONVERTED_FROM_OVID as long,",
						"          INSTALLMENT_RENEWAL as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> stgPolicy",
						"source(output(",
						"          riskid as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select isNull(MAX(RISK_ID),0) as riskid from POL_RISK',",
						"     format: 'query') ~> riskStaging",
						"derivedColumn6 compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet1@(output1)",
						"stgPolicy select(mapColumn(",
						"          POLICY_ID,",
						"          POLICY_VID",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> stgPolicySelect",
						"surrogateKey1 derive(RISK_ID = skey + maxId#outputs()[1].riskid,",
						"          RISK_VID = 1,",
						"          POLICY_ID = POLICY_ID,",
						"          RISK_IS_ACTIVE_YN = \"Y\",",
						"          RISK_EFF_DATE = EffectiveDate,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_EXP_DATE = ExpirationDate,",
						"          POLICY_OVID = POLICY_VID,",
						"          RISK_CODE = RiskUseCode,",
						"          RISK_NUMBER = concat(LocationNumber,'-',LocationUnitNumber)) ~> derivedColumn6",
						"join1 keyGenerate(output(skey as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> surrogateKey1",
						"PropertyUnits, stgPolicy join(Policy == POLICY_NUMBER,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"flowlet1@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_NUMBER as string,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          RISK_IS_ACTIVE_YN as string,",
						"          RISK_EFF_DATE as timestamp,",
						"          RISK_EXP_DATE as timestamp,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> PolRisk",
						"riskStaging sink(validateSchema: false,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     store: 'cache',",
						"     format: 'inline',",
						"     output: false,",
						"     saveOrder: 1) ~> maxId"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/fl_source_addDefaultColumnFlowlet')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_propertyUnits')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_policy')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_policyRisk')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_source_policy_section')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Source Stage Data Flows/txnDataFlow"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_policy",
								"type": "DatasetReference"
							},
							"name": "source1"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_polSection",
								"type": "DatasetReference"
							},
							"name": "source2"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_lob",
								"type": "DatasetReference"
							},
							"name": "lobStg"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_sub_LOB",
								"type": "DatasetReference"
							},
							"name": "subLobStg"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_polSection",
								"type": "DatasetReference"
							},
							"name": "sink1"
						},
						{
							"name": "sink2"
						}
					],
					"transformations": [
						{
							"name": "flowlet1",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "derivedColumn2"
						},
						{
							"name": "surrogateKey1"
						},
						{
							"name": "lobLookup"
						},
						{
							"name": "subLobCode"
						},
						{
							"name": "select1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          COVERAGE_ID as long,",
						"          COVERAGE_OVID as long,",
						"          LOCATION_ID as long,",
						"          LOCATION_OVID as long,",
						"          COVERAGE_CODE as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select pp.POLICY_ID,pp.POLICY_VID as POLICY_OVID,pc.COVERAGE_ID,pc.COVERAGE_VID as COVERAGE_OVID,pl.LOCATION_ID,pl.LOCATION_VID as LOCATION_OVID,pc.COVERAGE_CODE from POL_POLICY pp \\njoin POL_COVERAGE pc\\non pp.POLICY_ID = pc.POLICY_ID\\njoin POL_LOCATION pl\\non pl.POLICY_ID=pp.POLICY_ID',",
						"     format: 'query') ~> source1",
						"source(output(",
						"          SECTION_ID as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select MAX(SECTION_ID)  as SECTION_ID from dbo.POL_SECTION',",
						"     format: 'query') ~> source2",
						"source(output(",
						"          LOB_ID as long,",
						"          LOB_CODE as string,",
						"          LOB_NAME as string,",
						"          LOB_DESCRIPTION as string,",
						"          LOB_IS_VALID_YN as string,",
						"          LOB_VALID_START_DATE as timestamp,",
						"          LOB_VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> lobStg",
						"source(output(",
						"          SUB_LOB_ID as long,",
						"          SUB_LOB_CODE as string,",
						"          SUB_LOB_NAME as string,",
						"          SUB_LOB_DESCRIPTION as string,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> subLobStg",
						"select1 compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet1@(output1)",
						"surrogateKey1 derive(SECTION_ID = pkey + sink2#outputs()[1].SECTION_ID,",
						"          SECTION_VID = 1,",
						"          LOB_CODE = split(COVERAGE_CODE, '-')[3],",
						"          SUB_LOB_CODE = split(COVERAGE_CODE, '-')[4],",
						"          PRIMARY_POLICY_STATE = split(COVERAGE_CODE, '-')[2]) ~> derivedColumn1",
						"source2 derive(SECTION_ID = iifNull(SECTION_ID, 0, SECTION_ID)) ~> derivedColumn2",
						"source1 keyGenerate(output(pkey as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> surrogateKey1",
						"derivedColumn1, lobStg lookup(derivedColumn1@LOB_CODE == lobStg@LOB_CODE,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lobLookup",
						"lobLookup, subLobStg lookup(derivedColumn1@SUB_LOB_CODE == subLobStg@SUB_LOB_CODE,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> subLobCode",
						"subLobCode select(mapColumn(",
						"          POLICY_ID,",
						"          POLICY_OVID,",
						"          COVERAGE_ID,",
						"          COVERAGE_OVID,",
						"          LOCATION_ID,",
						"          LOCATION_OVID,",
						"          SECTION_ID,",
						"          SECTION_VID,",
						"          LOB_ID,",
						"          SUB_LOB_ID,",
						"          PRIMARY_POLICY_STATE",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"flowlet1@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          SECTION_ID as long,",
						"          SECTION_VID as long,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          COVERAGE_ID as long,",
						"          COVERAGE_OVID as long,",
						"          LOCATION_ID as long,",
						"          LOCATION_OVID as long,",
						"          LOB_ID as long,",
						"          SUB_LOB_ID as long,",
						"          RATE_SET_DATE as timestamp,",
						"          PRIMARY_POLICY_STATE as string,",
						"          BATCH_ID as long,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          DATA_HASH as binary,",
						"          SOURCE_KEY as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink1",
						"derivedColumn2 sink(validateSchema: false,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     store: 'cache',",
						"     format: 'inline',",
						"     output: false,",
						"     saveOrder: 1) ~> sink2"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/fl_source_addDefaultColumnFlowlet')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_policy')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_polSection')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_lob')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_sub_LOB')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_source_policy_tx_bridge')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Source Stage Data Flows/txnDataFlow/bridge"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_polTxn",
								"type": "DatasetReference"
							},
							"name": "polTxnStg"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_coverage",
								"type": "DatasetReference"
							},
							"name": "coverageStg"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRisk",
								"type": "DatasetReference"
							},
							"name": "source1"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_polSection",
								"type": "DatasetReference"
							},
							"name": "polSection"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_txnBridge",
								"type": "DatasetReference"
							},
							"name": "txnBridgeStagingMaxId"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policy",
								"type": "DatasetReference"
							},
							"name": "stagingPolicy"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_txnBridge",
								"type": "DatasetReference"
							},
							"name": "sink1"
						},
						{
							"name": "maxIdCache"
						}
					],
					"transformations": [
						{
							"name": "flowlet1",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "select1"
						},
						{
							"name": "lookup2"
						},
						{
							"name": "select2"
						},
						{
							"name": "surrogateKey1"
						},
						{
							"name": "select3"
						},
						{
							"name": "lookup3"
						},
						{
							"name": "derivedColumn2"
						},
						{
							"name": "join1"
						},
						{
							"name": "join2"
						},
						{
							"name": "select4"
						},
						{
							"name": "select6"
						}
					],
					"scriptLines": [
						"parameters{",
						"     policyPrefix as string ('EMP'),",
						"     policies as string[] ([\"EMP009688\"])",
						"}",
						"source(output(",
						"          TX_ID as long,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          TX_CODE as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT  distinct TX_ID,POLICY_ID,POLICY_OVID,TX_CODE FROM [DM_Source_Stage].[dbo].[POL_TX]  ',",
						"     format: 'query') ~> polTxnStg",
						"source(output(",
						"          COVERAGE_ID as long,",
						"          COVERAGE_VID as long,",
						"          COVERAGE_CODE_ID as long,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          COV_STATE_ID as long,",
						"          COVERAGE_EFFECTIVE_DATE as timestamp,",
						"          COVERAGE_EXPIRATION_DATE as timestamp,",
						"          ASL_CODE as string,",
						"          ASSL_CODE as string,",
						"          ASL_CODE_GBL as string,",
						"          ASSL_CODE_GBL as string,",
						"          CLASSIFICATION_CODE_ID as long,",
						"          CLASSIFICATION_CODE_OVID as long,",
						"          COVERAGE_CODE as string,",
						"          RETROACTIVE_DATE as timestamp,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select * from [dbo].[POL_COVERAGE] ',",
						"     format: 'query') ~> coverageStg",
						"source(output(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_NUMBER as string,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          RISK_IS_ACTIVE_YN as string,",
						"          RISK_EFF_DATE as timestamp,",
						"          RISK_EXP_DATE as timestamp,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select * FROM [DM_Source_Stage].[dbo].[POL_RISK] ',",
						"     format: 'query') ~> source1",
						"source(output(",
						"          SECTION_ID as long,",
						"          SECTION_VID as long,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          COVERAGE_ID as long,",
						"          COVERAGE_OVID as long,",
						"          LOCATION_ID as long,",
						"          LOCATION_OVID as long,",
						"          LOB_ID as long,",
						"          SUB_LOB_ID as long,",
						"          RATE_SET_DATE as timestamp,",
						"          PRIMARY_POLICY_STATE as string,",
						"          BATCH_ID as long,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          DATA_HASH as binary,",
						"          SOURCE_KEY as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> polSection",
						"source(output(",
						"          maxId as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT isnull(MAX(TX_BRIDGE_ID), 0) as maxId\\nFROM dbo.POL_TX_BRIDGE',",
						"     format: 'query') ~> txnBridgeStagingMaxId",
						"source(output(",
						"          POLICY_ID as long,",
						"          POLICY_VID as long,",
						"          REINSURANCE_DAC as string,",
						"          PREVIOUS_INSURANCE_NO_REMARKS as string,",
						"          AGENCY_ID as long,",
						"          AGENCY_OVID as long,",
						"          PRODUCER_ID as long,",
						"          PRODUCER_OVID as long,",
						"          PRODUCER_CONTACT_ID as long,",
						"          PRODUCER_CONTACT_OVID as long,",
						"          POLICY_NUMBER as string,",
						"          ENTITY_TYPE as string,",
						"          ENTITY_STATUS as string,",
						"          IS_RENEWAL_YN as string,",
						"          REVISION_NUMBER as integer,",
						"          PRODUCT_ID as long,",
						"          PRODUCT_OVID as long,",
						"          POLICY_EFFECTIVE_DATE as timestamp,",
						"          POLICY_EXPIRATION_DATE as timestamp,",
						"          NON_RENEWAL_CODE as string,",
						"          POLICY_RENEWED_YN as string,",
						"          CANCELLATION_DATE as timestamp,",
						"          IS_RENEWABLE_YN as string,",
						"          PREVIOUS_INSURANCE_NO_REASON as string,",
						"          POLICY_STATUS as string,",
						"          CANCEL_REASON_CODE as string,",
						"          CANCEL_REASON_DESCRIPTION as string,",
						"          CANCEL_METHOD as string,",
						"          CANCEL_METHOD_DESC as string,",
						"          LOSE_REASON_CODE as string,",
						"          LOSE_REASON_DESC as string,",
						"          DECLINATION_REASON_CODE as string,",
						"          DECLINATION_REASON_DESC as string,",
						"          NOT_WRITTEN_REASON_CODE as string,",
						"          NOT_WRITTEN_REASON_DESC as string,",
						"          POLICY_STATE_CODE as string,",
						"          PROGRAM_ID as long,",
						"          PROGRAM_OVID as long,",
						"          BILLING_TYPE_CODE as string,",
						"          UNDERWRITING_COMPANY_ID as long,",
						"          UNDERWRITING_COMPANY_OVID as long,",
						"          SUBMISSION_ID as long,",
						"          PREVIOUS_INSURANCE_YN as string,",
						"          LEGACY_POLICY_NUMBER as string,",
						"          STATE as string,",
						"          POLICY_POLICY as integer,",
						"          PAYMENT_PLAN as string,",
						"          APPLICATION_RECEIVED_DATE as timestamp,",
						"          INCEPTION_DATE as timestamp,",
						"          BILL_TYPE as string,",
						"          FORMS_LANGUAGE as string,",
						"          BASE_CURRENCY as string,",
						"          INVOICE_CURRENCY as string,",
						"          PREVIOUS_POLICY_ID as long,",
						"          PREVIOUS_POLICY_OVID as long,",
						"          REVISED_FROM_POLICY_ID as long,",
						"          REVISED_FROM_POLICY_OVID as long,",
						"          OPERATING_COMPANY_ID as long,",
						"          OPERATING_COMPANY_OVID as long,",
						"          CONVERTED_FROM_ID as long,",
						"          CONVERTED_FROM_OVID as long,",
						"          INSTALLMENT_RENEWAL as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from [dbo].[POL_POLICY] where ENTITY_TYPE ='{$policyPrefix}' \"+iif(size($policies) >0&& size($policies) ==1&&$policies[1] =='','','and policy_number in ('+dropLeft(toString(reduce($policies, \"'\", #acc + \",'\" + #item +\"'\", #result)), 2)+')')),",
						"     format: 'query') ~> stagingPolicy",
						"derivedColumn2 compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet1@(output1)",
						"join2 derive(POLICY_ID = select4@POLICY_ID,",
						"          POLICY_OVID = select4@POLICY_OVID,",
						"          COVERAGE_ID = COVERAGE_ID,",
						"          COVERAGE_VID = COVERAGE_VID) ~> derivedColumn1",
						"derivedColumn1 select(mapColumn(",
						"          TX_ID,",
						"          POLICY_ID,",
						"          POLICY_OVID,",
						"          TX_CODE,",
						"          COVERAGE_VID,",
						"          COVERAGE_CODE,",
						"          COVERAGE_ID",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"select1, select2 lookup(select1@POLICY_ID == select2@POLICY_ID",
						"     && concat(split(TX_CODE,'-')[2],'-',split(TX_CODE,'-')[3]) == RISK_NUMBER,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lookup2",
						"source1 select(mapColumn(",
						"          RISK_ID,",
						"          RISK_VID,",
						"          RISK_NUMBER,",
						"          POLICY_ID,",
						"          POLICY_OVID",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select2",
						"select3 keyGenerate(output(skey as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> surrogateKey1",
						"lookup3 select(mapColumn(",
						"          TX_ID,",
						"          POLICY_ID = select1@POLICY_ID,",
						"          POLICY_OVID = select1@POLICY_OVID,",
						"          TX_CODE,",
						"          COVERAGE_VID,",
						"          COVERAGE_CODE,",
						"          COVERAGE_ID = select1@COVERAGE_ID,",
						"          RISK_ID,",
						"          RISK_OVID = RISK_VID,",
						"          RISK_NUMBER,",
						"          SECTION_ID,",
						"          SECTION_VID",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select3",
						"lookup2, polSection lookup(select1@POLICY_ID == polSection@POLICY_ID",
						"     && select1@COVERAGE_ID == polSection@COVERAGE_ID,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lookup3",
						"surrogateKey1 derive(TX_BRIDGE_ID = skey + maxIdCache#outputs()[1].maxId) ~> derivedColumn2",
						"select4, select6 join(select4@POLICY_ID == select6@POLICY_ID,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"polTxnStg, join1 join(polTxnStg@POLICY_ID == select4@POLICY_ID",
						"     && concat(split(TX_CODE,'-')[4],'-',split(TX_CODE,'-')[5],'-',split(TX_CODE,'-')[6],'-',split(TX_CODE,'-')[7],'-',split(TX_CODE,'-')[8]) == COVERAGE_CODE,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join2",
						"coverageStg select(mapColumn(",
						"          COVERAGE_ID,",
						"          COVERAGE_VID,",
						"          COVERAGE_CODE_ID,",
						"          POLICY_ID,",
						"          POLICY_OVID,",
						"          COV_STATE_ID,",
						"          COVERAGE_CODE",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select4",
						"stagingPolicy select(mapColumn(",
						"          POLICY_ID,",
						"          POLICY_VID,",
						"          POLICY_NUMBER,",
						"          ENTITY_TYPE,",
						"          ENTITY_STATUS,",
						"          REVISION_NUMBER,",
						"          POLICY_STATUS",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select6",
						"flowlet1@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          TX_BRIDGE_ID as long,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          TX_ID as long,",
						"          SECTION_ID as long,",
						"          SECTION_VID as long,",
						"          RISK_ID as long,",
						"          RISK_OVID as long,",
						"          CLASSIFICATION_ID as long,",
						"          CLASSIFICATION_OVID as long,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          DATA_HASH as binary,",
						"          SOURCE_KEY as string,",
						"          COVERAGE_ID as long,",
						"          COVERAGE_VID as long",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink1",
						"txnBridgeStagingMaxId sink(validateSchema: false,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     store: 'cache',",
						"     format: 'inline',",
						"     output: false,",
						"     saveOrder: 1) ~> maxIdCache"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/fl_source_addDefaultColumnFlowlet')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_polTxn')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_coverage')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_policyRisk')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_polSection')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_txnBridge')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_policy')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_source_policy_txn')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Source Stage Data Flows/txnDataFlow"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_Fact_Coverage_Premium",
								"type": "DatasetReference"
							},
							"name": "coverages"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policy",
								"type": "DatasetReference"
							},
							"name": "polPolicy"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_polTxn",
								"type": "DatasetReference"
							},
							"name": "txnStagingMaxId"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_polTxn",
								"type": "DatasetReference"
							},
							"name": "polTxn"
						},
						{
							"name": "maxIdCache"
						}
					],
					"transformations": [
						{
							"name": "flowlet1",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "polSelect"
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "surrogateKey1"
						},
						{
							"name": "join1"
						}
					],
					"scriptLines": [
						"parameters{",
						"     policyPrefix as string,",
						"     policies as string[]",
						"}",
						"source(output(",
						"          Policy as string,",
						"          Policy_Sequence as string,",
						"          ARICLOB as string,",
						"          ARICGroupCode as string,",
						"          Description as string,",
						"          Product as string,",
						"          ARICCoverageCode as string,",
						"          ARICCoverageDescription as string,",
						"          EndorsementNumber as integer,",
						"          LocationNumber as string,",
						"          LocationUnitNumber as string,",
						"          BuildingNumber as string,",
						"          LocationName as string,",
						"          LocationAddress1 as string,",
						"          LocationAddress2 as string,",
						"          LocationAddress3 as string,",
						"          Occupancy as string,",
						"          LocationCity as string,",
						"          LocationZipCode as string,",
						"          LocationCounty as string,",
						"          Territory as string,",
						"          ConstructionCode as string,",
						"          ConstructionYear as integer,",
						"          NumberOfFloors as integer,",
						"          ProtectionClass as string,",
						"          GEOLatitude as decimal(11,8),",
						"          GEOLongitude as decimal(11,8),",
						"          CauseOfLoss as string,",
						"          BCEGClassCode as string,",
						"          CoverageForm as string,",
						"          DesignatedPremisis as string,",
						"          WindIndicatorFlag as string,",
						"          PurchaseCost as decimal(8,2),",
						"          dbo as string,",
						"          CoInsuranceBuilding as integer,",
						"          CoInsurancePersonalProperty as integer,",
						"          CoInsuranceBodilyInjury as integer,",
						"          CountryCode as string,",
						"          MunicipalityCode as string,",
						"          ParkName as string,",
						"          CountyCode as integer,",
						"          NumberParkSpaces as integer,",
						"          NumberOfAcres as integer,",
						"          OwnOrRent as string,",
						"          ResidenceTypeCode as string,",
						"          LocationZone as string,",
						"          ARICCoverageSequence as integer,",
						"          CoveragePart as string,",
						"          CoverageAddDate as timestamp,",
						"          CoverageDescription as string,",
						"          CoverageInternalCode as string,",
						"          CoverageAbbreviation as string,",
						"          CoveragePartSequence as integer,",
						"          CoverageISOLine as integer,",
						"          CoverageCATCode as string,",
						"          CoverageLine4 as integer,",
						"          CoverageAddUser as string,",
						"          CoverageUpdateDate as timestamp,",
						"          CoverageUpdateUser as string,",
						"          CoverageLineFlag as string,",
						"          LocationState as string,",
						"          ISOClassCode as string,",
						"          RetroEndorsementNumber as integer,",
						"          PolicyPrefix as string,",
						"          EffectiveDate as timestamp,",
						"          Policy_Accounting_date as timestamp,",
						"          ExpirationDate as timestamp,",
						"          CancelDate as timestamp,",
						"          CancelReason as string,",
						"          CancelReasonDescription as string,",
						"          PolicyTermMonths as integer,",
						"          InsuredName as string,",
						"          InsuredAddress1 as string,",
						"          InsuredAddress2 as string,",
						"          InsuredCity as string,",
						"          InsuredState as string,",
						"          InsuredZipCode as string,",
						"          CompanyCode as string,",
						"          CompanyName as string,",
						"          GroupName as string,",
						"          GBLICompanyCode as string,",
						"          AgentCode as string,",
						"          AgentName as string,",
						"          AgentOffice as string,",
						"          GroupCode as string,",
						"          AgentCity as string,",
						"          EMail as string,",
						"          AgentPhone as string,",
						"          AgentCounty as string,",
						"          AgentZipCode as string,",
						"          AgentAddress1 as string,",
						"          AgentAddress2 as string,",
						"          AgentState as string,",
						"          SubProducerNumber as string,",
						"          SubProducerCode as string,",
						"          SubProducerName as string,",
						"          SubproducerState as string,",
						"          SubProducerType as string,",
						"          ProductCode as string,",
						"          ProductCodeDescription as string,",
						"          PreviousPolicy as string,",
						"          OriginalPolicyYear as integer,",
						"          NonRenewalReason as string,",
						"          NonRenewalNoticeDate as timestamp,",
						"          DatabaseCode as string,",
						"          Policy_ID as integer,",
						"          MinimumPremium as decimal(13,0),",
						"          POlicy_Receive_date as timestamp,",
						"          MasterPolicy as string,",
						"          BillingType as string,",
						"          RowStatus as string,",
						"          OriginalInceptionDate as timestamp,",
						"          MultiplePolicyFlag as string,",
						"          ARICBusinessUnit as string,",
						"          HonorCurrentRateFlag as string,",
						"          FarmType as string,",
						"          PrimaryPremiumStateCode as string,",
						"          StateName as string,",
						"          Policy_Insert_Date as date,",
						"          BillingSystem as string,",
						"          Cov_effective_Date as timestamp,",
						"          Cov_Expiry_Date as timestamp,",
						"          ReceivedDate as date,",
						"          CoverageArrayNumber as integer,",
						"          LiabilityFlag as string,",
						"          ExperienceModFactor as decimal(7,4),",
						"          Exposure as decimal(8,0),",
						"          TaxFeeSurchargeFlag as string,",
						"          CancelReinstateFlag as string,",
						"          ReleasedFlag as string,",
						"          ReleaseDate as date,",
						"          Rate as decimal(12,6),",
						"          PremiumStateCode as string,",
						"          Coverage_ID as integer,",
						"          Coverage_accounting_date as timestamp,",
						"          Coverage_Insert_Date as date",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select  * from [dbo].[Fact_Coverage_Premium]  where PolicyPrefix='{$policyPrefix}'\"+iif(size($policies) >0&& size($policies) ==1&&$policies[1] =='','','and policy in ('+dropLeft(toString(reduce($policies, \"'\", #acc + \",'\" + #item +\"'\", #result)), 2)+')')),",
						"     format: 'query') ~> coverages",
						"source(output(",
						"          POLICY_ID as long,",
						"          POLICY_VID as long,",
						"          REINSURANCE_DAC as string,",
						"          PREVIOUS_INSURANCE_NO_REMARKS as string,",
						"          AGENCY_ID as long,",
						"          AGENCY_OVID as long,",
						"          PRODUCER_ID as long,",
						"          PRODUCER_OVID as long,",
						"          PRODUCER_CONTACT_ID as long,",
						"          PRODUCER_CONTACT_OVID as long,",
						"          POLICY_NUMBER as string,",
						"          ENTITY_TYPE as string,",
						"          ENTITY_STATUS as string,",
						"          IS_RENEWAL_YN as string,",
						"          REVISION_NUMBER as integer,",
						"          PRODUCT_ID as long,",
						"          PRODUCT_OVID as long,",
						"          POLICY_EFFECTIVE_DATE as timestamp,",
						"          POLICY_EXPIRATION_DATE as timestamp,",
						"          NON_RENEWAL_CODE as string,",
						"          POLICY_RENEWED_YN as string,",
						"          CANCELLATION_DATE as timestamp,",
						"          IS_RENEWABLE_YN as string,",
						"          PREVIOUS_INSURANCE_NO_REASON as string,",
						"          POLICY_STATUS as string,",
						"          CANCEL_REASON_CODE as string,",
						"          CANCEL_REASON_DESCRIPTION as string,",
						"          CANCEL_METHOD as string,",
						"          CANCEL_METHOD_DESC as string,",
						"          LOSE_REASON_CODE as string,",
						"          LOSE_REASON_DESC as string,",
						"          DECLINATION_REASON_CODE as string,",
						"          DECLINATION_REASON_DESC as string,",
						"          NOT_WRITTEN_REASON_CODE as string,",
						"          NOT_WRITTEN_REASON_DESC as string,",
						"          POLICY_STATE_CODE as string,",
						"          PROGRAM_ID as long,",
						"          PROGRAM_OVID as long,",
						"          BILLING_TYPE_CODE as string,",
						"          UNDERWRITING_COMPANY_ID as long,",
						"          UNDERWRITING_COMPANY_OVID as long,",
						"          SUBMISSION_ID as long,",
						"          PREVIOUS_INSURANCE_YN as string,",
						"          LEGACY_POLICY_NUMBER as string,",
						"          STATE as string,",
						"          POLICY_POLICY as integer,",
						"          PAYMENT_PLAN as string,",
						"          APPLICATION_RECEIVED_DATE as timestamp,",
						"          INCEPTION_DATE as timestamp,",
						"          BILL_TYPE as string,",
						"          FORMS_LANGUAGE as string,",
						"          BASE_CURRENCY as string,",
						"          INVOICE_CURRENCY as string,",
						"          PREVIOUS_POLICY_ID as long,",
						"          PREVIOUS_POLICY_OVID as long,",
						"          REVISED_FROM_POLICY_ID as long,",
						"          REVISED_FROM_POLICY_OVID as long,",
						"          OPERATING_COMPANY_ID as long,",
						"          OPERATING_COMPANY_OVID as long,",
						"          CONVERTED_FROM_ID as long,",
						"          CONVERTED_FROM_OVID as long,",
						"          INSTALLMENT_RENEWAL as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from [dbo].[POL_POLICY] where ENTITY_TYPE ='{$policyPrefix}' \"+iif(size($policies) >0&& size($policies) ==1&&$policies[1] =='','','and policy_number in ('+dropLeft(toString(reduce($policies, \"'\", #acc + \",'\" + #item +\"'\", #result)), 2)+')')),",
						"     format: 'query') ~> polPolicy",
						"source(output(",
						"          maxId as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT isnull(MAX(TX_ID), 0) as maxId\\nFROM dbo.POL_TX',",
						"     format: 'query') ~> txnStagingMaxId",
						"derivedColumn1 compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet1@(output1)",
						"polPolicy select(mapColumn(",
						"          POLICY_ID,",
						"          POLICY_VID,",
						"          POLICY_NUMBER",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> polSelect",
						"surrogateKey1 derive(TX_CODE = concat(Policy_Sequence,'-',LocationNumber,'-',LocationUnitNumber,'-',ARICGroupCode,'-',PrimaryPremiumStateCode,'-', ARICLOB,'-',ARICCoverageCode,'-',toString(ARICCoverageSequence)),",
						"          TX_ID = skey + maxIdCache#outputs()[1].maxId,",
						"          TYPE_OF_CHANGE = case(Policy_Sequence=='01','NBS' , ''),",
						"          POLICY_ID = polSelect@POLICY_ID,",
						"          POLICY_OVID = POLICY_VID) ~> derivedColumn1",
						"join1 keyGenerate(output(skey as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> surrogateKey1",
						"coverages, polSelect join(Policy == POLICY_NUMBER,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"flowlet1@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          TX_ID as long,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          TX_CODE as string,",
						"          SUB_ACTIVITY as string,",
						"          ENDORSEMENT_SEQ_NO as integer,",
						"          IS_SYSTEM_GENERATED_YN as string,",
						"          ENDORSEMENT_CHANGES as string,",
						"          TRANSACTION_EFFECTIVE_DATE as timestamp,",
						"          TRANSACTION_EXPIRY_DATE as timestamp,",
						"          TRANSACTION_BOOK_FLAG_DATE as timestamp,",
						"          PARENT_TRANSACTION_ID as integer,",
						"          TRANSACTION_TYPE_CODE as string,",
						"          TYPE_OF_CHANGE as string,",
						"          TRANSACTION_CREATED_DATE as timestamp,",
						"          TRANSACTION_MODIFIED_DATE as timestamp,",
						"          TRANSACTION_DISPLAY_NAME as string,",
						"          TRANSACTION_PERIOD_PRORATION as decimal(19,9),",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          DATA_HASH as binary,",
						"          SOURCE_KEY as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> polTxn",
						"txnStagingMaxId sink(validateSchema: false,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     store: 'cache',",
						"     format: 'inline',",
						"     output: false,",
						"     saveOrder: 1) ~> maxIdCache"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/fl_source_addDefaultColumnFlowlet')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_Fact_Coverage_Premium')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_policy')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_polTxn')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_source_producer')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Source Stage Data Flows/referenceDataFlow"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_producer",
								"type": "DatasetReference"
							},
							"name": "producerSource"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_agency",
								"type": "DatasetReference"
							},
							"name": "agencyStagingLookup"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_agency",
								"type": "DatasetReference"
							},
							"name": "agencyStaging"
						}
					],
					"transformations": [
						{
							"name": "metadataflowlet",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "deriveOtherRequiredColumns"
						},
						{
							"name": "producerSurrogateKey"
						},
						{
							"name": "selectRequiredProducerColumns"
						},
						{
							"name": "select2"
						},
						{
							"name": "groupByProducerName"
						},
						{
							"name": "deriveProducerName"
						}
					],
					"scriptLines": [
						"parameters{",
						"     DF_max_id as integer (1)",
						"}",
						"source(output(",
						"          SubProducerCode as string,",
						"          SubProducerName as string,",
						"          FergusonSubProducerFlag as string,",
						"          GroupCode as string,",
						"          SubProducerType as string,",
						"          SubproducerState as string,",
						"          DistributionTypeCode as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> producerSource",
						"source(output(",
						"          AGENCY_ID as long,",
						"          AGENCY_VID as long,",
						"          AGENCY_GEN_ADDRESS_ID as long,",
						"          AGENCY_CODE as string,",
						"          AGENCY_NAME as string,",
						"          AGENCY_STATUS as string,",
						"          AGENCY_CATEGORY as string,",
						"          DIRECT_BILL_FLAG_YN as string,",
						"          TELEPHONE as string,",
						"          FAX as string,",
						"          EMAIL_ID as string,",
						"          WEBSITE as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          ENTITY_TYPE as string,",
						"          ENTITY_PARENT_ID as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> agencyStagingLookup",
						"deriveOtherRequiredColumns compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> metadataflowlet@(output1)",
						"producerSurrogateKey derive(ENTITY_TYPE = \"PRODUCER\",",
						"          AGENCY_ID = skey + $DF_max_id,",
						"          AGENCY_VID = 1) ~> deriveOtherRequiredColumns",
						"groupByProducerName keyGenerate(output(skey as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> producerSurrogateKey",
						"producerSource select(mapColumn(",
						"          AGENCY_CODE = SubProducerCode,",
						"          GIVEN_AGENCY_NAME = SubProducerName,",
						"          AGENCY_CATEGORY = SubProducerType",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectRequiredProducerColumns",
						"agencyStagingLookup select(mapColumn(",
						"          AGENCY_CODE",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select2",
						"deriveProducerName aggregate(groupBy(AGENCY_NAME),",
						"     each(match(name!='AGENCY_NAME'), $$ = first($$))) ~> groupByProducerName",
						"selectRequiredProducerColumns derive(AGENCY_NAME = trim(GIVEN_AGENCY_NAME)) ~> deriveProducerName",
						"metadataflowlet@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          AGENCY_ID as long,",
						"          AGENCY_VID as long,",
						"          AGENCY_GEN_ADDRESS_ID as long,",
						"          AGENCY_CODE as string,",
						"          AGENCY_NAME as string,",
						"          AGENCY_STATUS as string,",
						"          AGENCY_CATEGORY as string,",
						"          DIRECT_BILL_FLAG_YN as string,",
						"          TELEPHONE as string,",
						"          FAX as string,",
						"          EMAIL_ID as string,",
						"          WEBSITE as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          ENTITY_TYPE as string,",
						"          ENTITY_PARENT_ID as long",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> agencyStaging"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/fl_source_addDefaultColumnFlowlet')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_producer')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_agency')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_source_state_lookup')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Source Stage Data Flows/referenceDataFlow"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_ecm_state_code",
								"type": "DatasetReference"
							},
							"name": "ecmStateRef"
						},
						{
							"dataset": {
								"referenceName": "StgLookUpType",
								"type": "DatasetReference"
							},
							"name": "lookupTypePkey"
						},
						{
							"dataset": {
								"referenceName": "lookup",
								"type": "DatasetReference"
							},
							"name": "lookupPkey"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "StgLookUpType",
								"type": "DatasetReference"
							},
							"name": "lookupType"
						},
						{
							"name": "lookupTypeID"
						},
						{
							"name": "lookupPkeyCache"
						}
					],
					"transformations": [
						{
							"name": "flowlet1",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "surrogateKey1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          StateCode as string,",
						"          StateAbbreviation as string,",
						"          StateName as string,",
						"          WCTypeOfLossGroupCode as string,",
						"          QuickRaterStateID as integer,",
						"          AutoDoNotRenewDays as integer,",
						"          AutoConditionalRenewalNoticeDays as integer,",
						"          AutoUMLimitFlag as string,",
						"          AutoStateBand as string,",
						"          AutoRegionID as integer,",
						"          StateTypeCode as string,",
						"          FIPSStateCode as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> ecmStateRef",
						"source(output(",
						"          LOOKUP_TYPE_ID as long,",
						"          LOOKUP_TYPE_DOMAIN as string,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          DATA_HASH as binary,",
						"          SOURCE_KEY as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select MAX(LOOKUP_TYPE_ID) as lookup_type_id from REF_LOOKUP_TYPE',",
						"     format: 'query') ~> lookupTypePkey",
						"source(output(",
						"          lookup_id as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select MAX(LOOKUP_ID) as lookup_id from REF_LOOKUP',",
						"     format: 'query') ~> lookupPkey",
						"derivedColumn1 compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet1@(output1)",
						"surrogateKey1 derive(LOOKUP_TYPE_ID = lookupTypeID#outputs()[1].LOOKUP_TYPE_ID + pkey,",
						"          LOOKUP_TYPE_DOMAIN = 'STATE') ~> derivedColumn1",
						"ecmStateRef keyGenerate(output(pkey as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> surrogateKey1",
						"flowlet1@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          LOOKUP_TYPE_ID as long,",
						"          LOOKUP_TYPE_DOMAIN as string,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          DATA_HASH as binary,",
						"          SOURCE_KEY as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     saveOrder: 0) ~> lookupType",
						"lookupTypePkey sink(validateSchema: false,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     store: 'cache',",
						"     format: 'inline',",
						"     output: false,",
						"     saveOrder: 0) ~> lookupTypeID",
						"lookupPkey sink(validateSchema: false,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     store: 'cache',",
						"     format: 'inline',",
						"     output: false,",
						"     saveOrder: 0) ~> lookupPkeyCache"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/fl_source_addDefaultColumnFlowlet')]",
				"[concat(variables('factoryId'), '/datasets/ds_ecm_state_code')]",
				"[concat(variables('factoryId'), '/datasets/StgLookUpType')]",
				"[concat(variables('factoryId'), '/datasets/lookup')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_stage_Deductible')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Target Stage Data Flows"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_POL_TX_LIMIT_DED_OPT",
								"type": "DatasetReference"
							},
							"name": "stageDeductible"
						},
						{
							"dataset": {
								"referenceName": "ECMBPA_COV_MAP",
								"type": "DatasetReference"
							},
							"name": "source1"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_coverage",
								"type": "DatasetReference"
							},
							"name": "source2"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_stage_deductible",
								"type": "DatasetReference"
							},
							"name": "TargetdeductSink"
						}
					],
					"transformations": [
						{
							"name": "aggByPolByCoverByRiskID"
						},
						{
							"name": "surrogateKey1"
						},
						{
							"name": "columnMapping"
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "join1"
						},
						{
							"name": "select1"
						},
						{
							"name": "lookup1"
						},
						{
							"name": "filter1"
						},
						{
							"name": "derivedColumn2"
						}
					],
					"scriptLines": [
						"source(output(",
						"          TX_LIMIT_DED_OPT_ID as long,",
						"          TX_ID as long,",
						"          LOCATION_ID as long,",
						"          LOCATION_OVID as long,",
						"          SECTION_ID as long,",
						"          SECTION_OVID as long,",
						"          TX_BRIDGE_ID as long,",
						"          RISK_ID as long,",
						"          RISK_OVID as long,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          LIMIT_DED_OPT_TYPE_ID as long,",
						"          LDO_FLAG as string,",
						"          LDO_CODE as string,",
						"          LIMIT_OCCURRENCE_FLAG as string,",
						"          LDO_VALUE as long,",
						"          LDO_VALUE_CCY_CODE as string,",
						"          LDO_PERCENTAGE as decimal(6,4),",
						"          LDO_TEXT as string,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          DATA_HASH as binary,",
						"          SOURCE_KEY as string,",
						"          COVERAGE_ID as long,",
						"          COVERAGE_OVID as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select *  from [dbo].[POL_TX_LIMIT_DED_OPT]  where LIMIT_DED_OPT_TYPE_ID =1 ',",
						"     format: 'query') ~> stageDeductible",
						"source(output(",
						"          COV_SEQ as string,",
						"          BPA_SECTION_CODE as string,",
						"          COVERAGE_CODE as string,",
						"          COVERAGE_CODE_DES as string,",
						"          BPA_COVERAGE_CODES as string,",
						"          BPA_COVERAGES as string,",
						"          COVERAGES as string,",
						"          BPA_PRODUCT_CODE as string,",
						"          SI_NO as string,",
						"          id as long,",
						"          BPA_SEC_NAME as string,",
						"          SOURCE_PRODUCT_CODE as string,",
						"          bpa_coverage_group as string,",
						"          bpa_coverage_level as string,",
						"          bpa_coverage_type as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> source1",
						"source(output(",
						"          COVERAGE_ID as long,",
						"          COVERAGE_VID as long,",
						"          COVERAGE_CODE_ID as long,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          COV_STATE_ID as long,",
						"          COVERAGE_EFFECTIVE_DATE as timestamp,",
						"          COVERAGE_EXPIRATION_DATE as timestamp,",
						"          ASL_CODE as string,",
						"          ASSL_CODE as string,",
						"          ASL_CODE_GBL as string,",
						"          ASSL_CODE_GBL as string,",
						"          CLASSIFICATION_CODE_ID as long,",
						"          CLASSIFICATION_CODE_OVID as long,",
						"          COVERAGE_CODE as string,",
						"          RETROACTIVE_DATE as timestamp,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> source2",
						"filter1 aggregate(groupBy(stageDeductible@POLICY_ID,",
						"          stageDeductible@COVERAGE_ID,",
						"          RISK_ID,",
						"          LDO_CODE),",
						"     json_data = toString(collect(@(typeCode=\"Per Claim\",name=toString(deductibleName),valueType='amount',value=LDO_VALUE,currencyCode='USD')))) ~> aggByPolByCoverByRiskID",
						"columnMapping keyGenerate(output(deductible_id as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> surrogateKey1",
						"aggByPolByCoverByRiskID derive(coverage_id = COVERAGE_ID,",
						"          risk_id = RISK_ID) ~> columnMapping",
						"source2 derive(seq = split(COVERAGE_CODE, '-')[5]) ~> derivedColumn1",
						"derivedColumn2, select1 join(COV_SEQ == seq,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"derivedColumn1 select(mapColumn(",
						"          COVERAGE_ID,",
						"          POLICY_ID,",
						"          COVERAGE_CODE,",
						"          seq",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"stageDeductible, join1 lookup(stageDeductible@COVERAGE_ID == select1@COVERAGE_ID,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lookup1",
						"lookup1 filter(!isNull(COV_SEQ)) ~> filter1",
						"source1 derive(deductibleName = case(BPA_COVERAGE_CODES=='EMMS', 'Major Medical Deductible', BPA_COVERAGE_CODES=='EMMSP','Major Medical Plus Deductible',BPA_COVERAGE_CODES=='EACI','Equine Accident Illness Deductible',BPA_COVERAGE_CODES=='EQSG','Equine Surgical Deductible',BPA_COVERAGE_CODES=='EQSG','Equine Surgical Deductible',BPA_COVERAGE_CODES=='EQCO','Equine Colic Deductible',",
						"BPA_COVERAGE_CODES=='HE001', 'Tack (personal property)',BPA_COVERAGE_CODES=='HE001', 'Non-owned personal property'",
						")) ~> derivedColumn2",
						"surrogateKey1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          deductible_id as integer,",
						"          coverage_id as integer,",
						"          json_data as string,",
						"          risk_id as long",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> TargetdeductSink"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ds_source_POL_TX_LIMIT_DED_OPT')]",
				"[concat(variables('factoryId'), '/datasets/ECMBPA_COV_MAP')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_coverage')]",
				"[concat(variables('factoryId'), '/datasets/ds_stage_deductible')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_stage_address')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Target Stage Data Flows/referenceDataFlow"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_genAddress",
								"type": "DatasetReference"
							},
							"name": "addressStaging"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_stage_address",
								"type": "DatasetReference"
							},
							"name": "addressTarget"
						}
					],
					"transformations": [
						{
							"name": "deriveJson"
						}
					],
					"scriptLines": [
						"source(output(",
						"          GEN_ADDRESS_UNIQ_ID as long,",
						"          ADDRESS_STREET1 as string,",
						"          ADDRESS_STREET2 as string,",
						"          COUNTY_CODE as string,",
						"          COUNTY as string,",
						"          ADDRESS_CITY as string,",
						"          ADD_DESCRIPTION as string,",
						"          STATE_PROVINCE_CODE as string,",
						"          POSTAL_CODE as string,",
						"          POSTAL_CODE_EXT as string,",
						"          COUNTRY_CODE as string,",
						"          SOURCE_INSERTED_ON as timestamp,",
						"          SOURCE_UPDATED_ON as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> addressStaging",
						"addressStaging derive(json_data = toString(@(line1=trim(ADDRESS_STREET1),",
						"          line2=trim(ADDRESS_STREET2),",
						"          city=trim(ADDRESS_CITY),",
						"          stateOrProvinceCode=STATE_PROVINCE_CODE,",
						"          postalCode=POSTAL_CODE,",
						"          countryCode=COUNTRY_CODE,",
						"          isPrimaryAddress=true(),",
						"          countyCode=COUNTY_CODE,",
						"          countyName=trim(COUNTY)))) ~> deriveJson",
						"deriveJson sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          address_id as integer,",
						"          json_data as string,",
						"          extendedattributes as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          address_id = GEN_ADDRESS_UNIQ_ID,",
						"          json_data",
						"     )) ~> addressTarget"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_genAddress')]",
				"[concat(variables('factoryId'), '/datasets/ds_stage_address')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_stage_agency')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Target Stage Data Flows/referenceDataFlow"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_agency",
								"type": "DatasetReference"
							},
							"name": "agencyStaging"
						},
						{
							"dataset": {
								"referenceName": "joinTableStageSQL",
								"type": "DatasetReference"
							},
							"name": "policyPartyRoleBridge"
						},
						{
							"dataset": {
								"referenceName": "ds_stage_agency",
								"type": "DatasetReference"
							},
							"name": "agencyTargetLookup"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_stage_agency",
								"type": "DatasetReference"
							},
							"name": "agencyTarget"
						}
					],
					"transformations": [
						{
							"name": "deriveJson"
						},
						{
							"name": "filter1"
						},
						{
							"name": "AlterRow1"
						},
						{
							"name": "exists2"
						},
						{
							"name": "lookup1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          AGENCY_ID as long,",
						"          AGENCY_VID as long,",
						"          AGENCY_GEN_ADDRESS_ID as long,",
						"          AGENCY_CODE as string,",
						"          AGENCY_NAME as string,",
						"          AGENCY_STATUS as string,",
						"          AGENCY_CATEGORY as string,",
						"          DIRECT_BILL_FLAG_YN as string,",
						"          TELEPHONE as string,",
						"          FAX as string,",
						"          EMAIL_ID as string,",
						"          WEBSITE as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          ENTITY_TYPE as string,",
						"          ENTITY_PARENT_ID as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> agencyStaging",
						"source(output(",
						"          PARTY_ID as long,",
						"          ROLE_CODE as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select distinct prb.PARTY_ID, pr.ROLE_CODE from POL_POLICY_PARTY_ROLE_BRIDGE as prb join POL_PARTY_ROLE as pr on prb.ROLE_ID = pr.ROLE_ID where pr.role_code in (\\'PRODUCER\\', \\'AGENCY\\') \\n',",
						"     format: 'query') ~> policyPartyRoleBridge",
						"source(output(",
						"          agency_id as integer,",
						"          json_data as string,",
						"          bpa_party_code as string,",
						"          bpa_party_id as string,",
						"          party_name as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> agencyTargetLookup",
						"lookup1 derive(json_data = toString(@(languageCode=array(\"EN\"),",
						"          name=@(fullName=AGENCY_NAME),",
						"          organization=@(fullName=AGENCY_NAME,",
						"          languageCode=array(\"EN\")),",
						"          partyRole=array(",
						"        @(",
						"               agencyType=\"wholesale\",",
						"            effectiveDate= toString(currentDate()),",
						"            roleType= \"agency\"",
						"        )",
						"    ),",
						"          partyStatus=\"active\",",
						"          partyTypeCode=\"organization\",",
						"          partyIdentity=array(@(createdDate=currentTimestamp(), modifiedDate=currentTimestamp(), isActive=true(), typeCode='AGCO', value=AGENCY_CODE))",
						"          ))) ~> deriveJson",
						"agencyTargetLookup filter(isNull(bpa_party_code)) ~> filter1",
						"deriveJson alterRow(upsertIf(!isNull(agencyStaging@AGENCY_ID))) ~> AlterRow1",
						"agencyStaging, policyPartyRoleBridge exists(AGENCY_ID == PARTY_ID,",
						"     negate:false,",
						"     broadcast: 'auto')~> exists2",
						"exists2, filter1 lookup(agencyStaging@AGENCY_ID == agencyTargetLookup@agency_id,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lookup1",
						"AlterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          agency_id as integer,",
						"          json_data as string,",
						"          bpa_party_code as string,",
						"          bpa_party_id as string,",
						"          party_name as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:true,",
						"     upsertable:true,",
						"     keys:['agency_id'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          agency_id = agencyStaging@AGENCY_ID,",
						"          json_data",
						"     )) ~> agencyTarget"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_agency')]",
				"[concat(variables('factoryId'), '/datasets/joinTableStageSQL')]",
				"[concat(variables('factoryId'), '/datasets/ds_stage_agency')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_stage_covLimit_policy_level')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Target Stage Data Flows/limits"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_POL_TX_LIMIT_DED_OPT",
								"type": "DatasetReference"
							},
							"name": "source1"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_coverageExt",
								"type": "DatasetReference"
							},
							"name": "osStagingCoverageExt"
						},
						{
							"dataset": {
								"referenceName": "ECMBPA_COV_MAP",
								"type": "DatasetReference"
							},
							"name": "srcBpaCovMap"
						},
						{
							"dataset": {
								"referenceName": "ds_BPA_limit",
								"type": "DatasetReference"
							},
							"name": "BPAlimitRef"
						},
						{
							"dataset": {
								"referenceName": "ds_stage_limit",
								"type": "DatasetReference"
							},
							"name": "source2"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_stage_limit",
								"type": "DatasetReference"
							},
							"name": "TargetlimitSink"
						},
						{
							"name": "sink2"
						}
					],
					"transformations": [
						{
							"name": "aggregate1"
						},
						{
							"name": "surrogateKey1"
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "join1"
						},
						{
							"name": "limitNameBySeq"
						},
						{
							"name": "join2"
						},
						{
							"name": "join3"
						},
						{
							"name": "derivedColumn2"
						},
						{
							"name": "filter1"
						},
						{
							"name": "filterByPolicyprefix"
						},
						{
							"name": "filter2"
						}
					],
					"scriptLines": [
						"parameters{",
						"     policyPrefix as string ('EMP'),",
						"     locationCode as string ('MT')",
						"}",
						"source(output(",
						"          TX_LIMIT_DED_OPT_ID as long,",
						"          TX_ID as long,",
						"          LOCATION_ID as long,",
						"          LOCATION_OVID as long,",
						"          SECTION_ID as long,",
						"          SECTION_OVID as long,",
						"          TX_BRIDGE_ID as long,",
						"          RISK_ID as long,",
						"          RISK_OVID as long,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          LIMIT_DED_OPT_TYPE_ID as long,",
						"          LDO_FLAG as string,",
						"          LDO_CODE as string,",
						"          LIMIT_OCCURRENCE_FLAG as string,",
						"          LDO_VALUE as long,",
						"          LDO_VALUE_CCY_CODE as string,",
						"          LDO_PERCENTAGE as decimal(6,4),",
						"          LDO_TEXT as string,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          DATA_HASH as binary,",
						"          SOURCE_KEY as string,",
						"          COVERAGE_ID as long,",
						"          COVERAGE_OVID as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select *  from [dbo].[POL_TX_LIMIT_DED_OPT]  where LIMIT_DED_OPT_TYPE_ID !=1  and LDO_CODE=\\'LIMIT1\\' ',",
						"     format: 'query') ~> source1",
						"source(output(",
						"          COVERAGE_ID as long,",
						"          POLICY_ID as long,",
						"          ARICCoverageSequence as integer,",
						"          ARICGroupCode as string,",
						"          ARICLOB as string,",
						"          CoverageDescription as string,",
						"          COVERAGE_CODE as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select ext.COVERAGE_ID AS COVERAGE_ID ,pc.POLICY_ID,ext.ARICCoverageSequence,ARICGroupCode,ARICLOB,CoverageDescription,pc.COVERAGE_CODE from [dbo].[POL_COVERAGE_EXT] ext\\njoin POL_COVERAGE pc on ext.COVERAGE_ID=pc.COVERAGE_ID\\n',",
						"     format: 'query') ~> osStagingCoverageExt",
						"source(output(",
						"          COV_SEQ as string,",
						"          BPA_SECTION_CODE as string,",
						"          COVERAGE_CODE as string,",
						"          COVERAGE_CODE_DES as string,",
						"          BPA_COVERAGE_CODES as string,",
						"          BPA_COVERAGES as string,",
						"          COVERAGES as string,",
						"          BPA_PRODUCT_CODE as string,",
						"          SI_NO as string,",
						"          id as long,",
						"          BPA_SEC_NAME as string,",
						"          SOURCE_PRODUCT_CODE as string,",
						"          bpa_coverage_group as string,",
						"          bpa_coverage_level as string,",
						"          bpa_coverage_type as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> srcBpaCovMap",
						"source(output(",
						"          limit_id as long,",
						"          coverageCode as string,",
						"          secCode as string,",
						"          limitValueType as string,",
						"          limitTypeCode as string,",
						"          limitName as string,",
						"          coverage_group_code as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> BPAlimitRef",
						"source(output(",
						"          limit_id as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select coalesce ( MAX(limit_id),0) as limit_id from cov_limit',",
						"     format: 'query') ~> source2",
						"filter1 aggregate(groupBy(source1@POLICY_ID,",
						"          source1@COVERAGE_ID,",
						"          limit_id,",
						"          LDO_CODE),",
						"     json_data = toString(collect(@(name=limitName,typeCode=limitTypeCode,valueType=limitValueType,value=LDO_VALUE,currencyCode='USD')))) ~> aggregate1",
						"derivedColumn1 keyGenerate(output(limit_id_pkey as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> surrogateKey1",
						"aggregate1 derive(coverage_id = COVERAGE_ID) ~> derivedColumn1",
						"osStagingCoverageExt, srcBpaCovMap join(split(osStagingCoverageExt@COVERAGE_CODE,'-')[4] == srcBpaCovMap@COVERAGE_CODE",
						"     && toString(ARICCoverageSequence) == COV_SEQ,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"join3 derive(srcCovId = COVERAGE_ID,",
						"          limitName = limitName) ~> limitNameBySeq",
						"source1, filterByPolicyprefix join(source1@POLICY_ID == osStagingCoverageExt@POLICY_ID",
						"     && source1@COVERAGE_ID == osStagingCoverageExt@COVERAGE_ID,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join2",
						"join1, filter2 join(BPA_COVERAGE_CODES == coverageCode,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join3",
						"surrogateKey1 derive(limit_id = sink2#outputs()[1].limit_id + limit_id_pkey) ~> derivedColumn2",
						"join2 filter(isNull(RISK_ID)) ~> filter1",
						"limitNameBySeq filter(SOURCE_PRODUCT_CODE == $policyPrefix) ~> filterByPolicyprefix",
						"BPAlimitRef filter(coverage_group_code == 'LI' ||coverage_group_code == 'PD' ||coverage_group_code == 'CN' || coverage_group_code == $locationCode || isNull(coverage_group_code)) ~> filter2",
						"derivedColumn2 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          limit_id as integer,",
						"          coverage_id as integer,",
						"          json_data as string,",
						"          risk_id as long",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     saveOrder: 2) ~> TargetlimitSink",
						"source2 sink(validateSchema: false,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     store: 'cache',",
						"     format: 'inline',",
						"     output: false,",
						"     saveOrder: 1) ~> sink2"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ds_source_POL_TX_LIMIT_DED_OPT')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_coverageExt')]",
				"[concat(variables('factoryId'), '/datasets/ECMBPA_COV_MAP')]",
				"[concat(variables('factoryId'), '/datasets/ds_BPA_limit')]",
				"[concat(variables('factoryId'), '/datasets/ds_stage_limit')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_stage_covLimit_risk_level_cov')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Target Stage Data Flows/limits"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_POL_TX_LIMIT_DED_OPT",
								"type": "DatasetReference"
							},
							"name": "source1"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_coverageExt",
								"type": "DatasetReference"
							},
							"name": "osStagingCoverageExt"
						},
						{
							"dataset": {
								"referenceName": "ECMBPA_COV_MAP",
								"type": "DatasetReference"
							},
							"name": "srcBpaCovMap"
						},
						{
							"dataset": {
								"referenceName": "ds_BPA_limit",
								"type": "DatasetReference"
							},
							"name": "BPAlimitRef"
						},
						{
							"dataset": {
								"referenceName": "ds_stage_limit",
								"type": "DatasetReference"
							},
							"name": "source2"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_stage_limit",
								"type": "DatasetReference"
							},
							"name": "TargetlimitSink"
						},
						{
							"name": "sink2"
						}
					],
					"transformations": [
						{
							"name": "aggregate1"
						},
						{
							"name": "surrogateKey1"
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "join1"
						},
						{
							"name": "limitNameBySeq"
						},
						{
							"name": "join2"
						},
						{
							"name": "join3"
						},
						{
							"name": "derivedColumn2"
						},
						{
							"name": "filter1"
						},
						{
							"name": "policyPrefixFilter"
						},
						{
							"name": "filter2"
						}
					],
					"scriptLines": [
						"parameters{",
						"     policyPrefix as string ('CFA'),",
						"     locationCode as string ('MT')",
						"}",
						"source(output(",
						"          TX_LIMIT_DED_OPT_ID as long,",
						"          TX_ID as long,",
						"          LOCATION_ID as long,",
						"          LOCATION_OVID as long,",
						"          SECTION_ID as long,",
						"          SECTION_OVID as long,",
						"          TX_BRIDGE_ID as long,",
						"          RISK_ID as long,",
						"          RISK_OVID as long,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          LIMIT_DED_OPT_TYPE_ID as long,",
						"          LDO_FLAG as string,",
						"          LDO_CODE as string,",
						"          LIMIT_OCCURRENCE_FLAG as string,",
						"          LDO_VALUE as long,",
						"          LDO_VALUE_CCY_CODE as string,",
						"          LDO_PERCENTAGE as decimal(6,4),",
						"          LDO_TEXT as string,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          DATA_HASH as binary,",
						"          SOURCE_KEY as string,",
						"          COVERAGE_ID as long,",
						"          COVERAGE_OVID as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select *  from [dbo].[POL_TX_LIMIT_DED_OPT]  where LIMIT_DED_OPT_TYPE_ID !=1  and LDO_CODE=\\'LIMIT1\\' ',",
						"     format: 'query') ~> source1",
						"source(output(",
						"          COVERAGE_ID as long,",
						"          POLICY_ID as long,",
						"          ARICCoverageSequence as integer,",
						"          ARICGroupCode as string,",
						"          ARICLOB as string,",
						"          CoverageDescription as string,",
						"          COVERAGE_CODE as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select ext.COVERAGE_ID AS COVERAGE_ID ,pc.POLICY_ID,ext.ARICCoverageSequence,ARICGroupCode,ARICLOB,CoverageDescription,pc.COVERAGE_CODE from [dbo].[POL_COVERAGE_EXT] ext\\njoin POL_COVERAGE pc on ext.COVERAGE_ID=pc.COVERAGE_ID\\n',",
						"     format: 'query') ~> osStagingCoverageExt",
						"source(output(",
						"          COV_SEQ as string,",
						"          BPA_SECTION_CODE as string,",
						"          COVERAGE_CODE as string,",
						"          COVERAGE_CODE_DES as string,",
						"          BPA_COVERAGE_CODES as string,",
						"          BPA_COVERAGES as string,",
						"          COVERAGES as string,",
						"          BPA_PRODUCT_CODE as string,",
						"          SI_NO as string,",
						"          id as long,",
						"          BPA_SEC_NAME as string,",
						"          SOURCE_PRODUCT_CODE as string,",
						"          bpa_coverage_group as string,",
						"          bpa_coverage_level as string,",
						"          bpa_coverage_type as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> srcBpaCovMap",
						"source(output(",
						"          limit_id as long,",
						"          coverageCode as string,",
						"          secCode as string,",
						"          limitValueType as string,",
						"          limitTypeCode as string,",
						"          limitName as string,",
						"          coverage_group_code as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> BPAlimitRef",
						"source(output(",
						"          limit_id as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select coalesce ( MAX(limit_id),0) as limit_id from cov_limit',",
						"     format: 'query') ~> source2",
						"filter1 aggregate(groupBy(source1@POLICY_ID,",
						"          source1@COVERAGE_ID,",
						"          RISK_ID,",
						"          limit_id,",
						"          LDO_CODE),",
						"     json_data = toString(collect(@(name=limitName,typeCode=limitTypeCode,valueType=limitValueType,value=LDO_VALUE,currencyCode='USD')))) ~> aggregate1",
						"derivedColumn1 keyGenerate(output(limit_id_pkey as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> surrogateKey1",
						"aggregate1 derive(coverage_id = COVERAGE_ID,",
						"          risk_id = RISK_ID) ~> derivedColumn1",
						"osStagingCoverageExt, srcBpaCovMap join(split(osStagingCoverageExt@COVERAGE_CODE,'-')[4] == srcBpaCovMap@COVERAGE_CODE",
						"     && toString(ARICCoverageSequence) == COV_SEQ,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"join3 derive(srcCovId = COVERAGE_ID,",
						"          limitName = limitName) ~> limitNameBySeq",
						"source1, policyPrefixFilter join(source1@POLICY_ID == osStagingCoverageExt@POLICY_ID",
						"     && source1@COVERAGE_ID == osStagingCoverageExt@COVERAGE_ID,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join2",
						"join1, filter2 join(BPA_COVERAGE_CODES == coverageCode,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join3",
						"surrogateKey1 derive(limit_id = sink2#outputs()[1].limit_id + limit_id_pkey) ~> derivedColumn2",
						"join2 filter(!isNull(RISK_ID)) ~> filter1",
						"limitNameBySeq filter(SOURCE_PRODUCT_CODE == $policyPrefix) ~> policyPrefixFilter",
						"BPAlimitRef filter(coverage_group_code == 'LI' ||coverage_group_code == 'PD' ||coverage_group_code == 'CN' || coverage_group_code == $locationCode || isNull(coverage_group_code)) ~> filter2",
						"derivedColumn2 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          limit_id as integer,",
						"          coverage_id as integer,",
						"          json_data as string,",
						"          risk_id as long",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     saveOrder: 2) ~> TargetlimitSink",
						"source2 sink(validateSchema: false,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     store: 'cache',",
						"     format: 'inline',",
						"     output: false,",
						"     saveOrder: 1) ~> sink2"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ds_source_POL_TX_LIMIT_DED_OPT')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_coverageExt')]",
				"[concat(variables('factoryId'), '/datasets/ECMBPA_COV_MAP')]",
				"[concat(variables('factoryId'), '/datasets/ds_BPA_limit')]",
				"[concat(variables('factoryId'), '/datasets/ds_stage_limit')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_stage_ecm_bpa_cov_mapping')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Target Stage Data Flows"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ECM_BPA_COV_Mapping",
								"type": "DatasetReference"
							},
							"name": "ecmCovMapping"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ECMBPA_COV_MAP",
								"type": "DatasetReference"
							},
							"name": "ecmBpaCovMapping"
						}
					],
					"transformations": [
						{
							"name": "surrogateKey1"
						},
						{
							"name": "derivedColumn1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          SI_NO as string,",
						"          COV_SEQ as string,",
						"          COVERAGE_CODE as string,",
						"          COVERAGE_CODE_DES as string,",
						"          COVERAGES as string,",
						"          BPA_SEC_NAME as string,",
						"          BPA_SECTION_CODE as string,",
						"          BPA_COVERAGES as string,",
						"          BPA_COVERAGE_CODES as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> ecmCovMapping",
						"ecmCovMapping keyGenerate(output(id as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> surrogateKey1",
						"surrogateKey1 derive(SOURCE_PRODUCT_CODE = 'EMP',",
						"          BPA_PRODUCT_CODE = 'EMP') ~> derivedColumn1",
						"derivedColumn1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          COV_SEQ as string,",
						"          BPA_SECTION_CODE as string,",
						"          COVERAGE_CODE as string,",
						"          COVERAGE_CODE_DES as string,",
						"          BPA_COVERAGE_CODES as string,",
						"          BPA_COVERAGES as string,",
						"          COVERAGES as string,",
						"          BPA_PRODUCT_CODE as string,",
						"          SI_NO as string,",
						"          id as long,",
						"          BPA_SEC_NAME as string,",
						"          SOURCE_PRODUCT_CODE as string,",
						"          bpa_coverage_group as string,",
						"          bpa_coverage_level as string,",
						"          bpa_coverage_type as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     recreate:true,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> ecmBpaCovMapping"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ECM_BPA_COV_Mapping')]",
				"[concat(variables('factoryId'), '/datasets/ECMBPA_COV_MAP')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_stage_horsedetails_lookup')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Target Stage Data Flows/lookupDataFlow"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_stage_horseBreed_lookup",
								"type": "DatasetReference"
							},
							"name": "horseBreedCodes"
						},
						{
							"dataset": {
								"referenceName": "ds_stage_horseDetailsLookup",
								"type": "DatasetReference"
							},
							"name": "stageHorseDetailsLookup"
						},
						{
							"dataset": {
								"referenceName": "ds_stage_horseSex_lookup",
								"type": "DatasetReference"
							},
							"name": "horseSexCodes"
						},
						{
							"dataset": {
								"referenceName": "ds_stage_horseUse_lookup",
								"type": "DatasetReference"
							},
							"name": "horseUseCodes"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_stage_horseDetailsLookup",
								"type": "DatasetReference"
							},
							"name": "horseDetailsBreedTarget"
						},
						{
							"name": "lookupCache"
						}
					],
					"transformations": [
						{
							"name": "derivedColumn1"
						},
						{
							"name": "derivedColumn2"
						},
						{
							"name": "surrogateKey1"
						},
						{
							"name": "select1"
						},
						{
							"name": "select2"
						},
						{
							"name": "select3"
						},
						{
							"name": "union1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          Code as string,",
						"          Description as string,",
						"          SubCode as string,",
						"          Order as string,",
						"          ExtendedAttributes as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> horseBreedCodes",
						"source(output(",
						"          id as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select MAX(lookup_id)  as id from bpa_horse_details_lookup',",
						"     format: 'query') ~> stageHorseDetailsLookup",
						"source(output(",
						"          Code as string,",
						"          Description as string,",
						"          SubCode as string,",
						"          Order as string,",
						"          ExtendedAttributes as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> horseSexCodes",
						"source(output(",
						"          Code as string,",
						"          Description as string,",
						"          SubCode as string,",
						"          Order as string,",
						"          ExtendedAttributes as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> horseUseCodes",
						"surrogateKey1 derive(lookup_id = pkey + lookupCache#outputs()[1].id,",
						"          desc = trim(Description)) ~> derivedColumn1",
						"stageHorseDetailsLookup derive(id = iifNull(id, 0, id)) ~> derivedColumn2",
						"union1 keyGenerate(output(pkey as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> surrogateKey1",
						"horseBreedCodes select(mapColumn(",
						"          Code,",
						"          Description",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"horseSexCodes select(mapColumn(",
						"          Code,",
						"          Description",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select2",
						"horseUseCodes select(mapColumn(",
						"          Code,",
						"          Description",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select3",
						"select1, select2, select3 union(byName: true)~> union1",
						"derivedColumn1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          lookup_id as integer,",
						"          bpa_code as string,",
						"          bpa_code_desc as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          lookup_id,",
						"          bpa_code = Code,",
						"          bpa_code_desc = desc",
						"     )) ~> horseDetailsBreedTarget",
						"derivedColumn2 sink(validateSchema: false,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     store: 'cache',",
						"     format: 'inline',",
						"     output: false,",
						"     saveOrder: 0) ~> lookupCache"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ds_stage_horseBreed_lookup')]",
				"[concat(variables('factoryId'), '/datasets/ds_stage_horseDetailsLookup')]",
				"[concat(variables('factoryId'), '/datasets/ds_stage_horseSex_lookup')]",
				"[concat(variables('factoryId'), '/datasets/ds_stage_horseUse_lookup')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_stage_location')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Target Stage Data Flows"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_location",
								"type": "DatasetReference"
							},
							"name": "locationStagingJoinStgingPolicy"
						},
						{
							"dataset": {
								"referenceName": "ds_stage_address",
								"type": "DatasetReference"
							},
							"name": "addressTarget"
						},
						{
							"dataset": {
								"referenceName": "ds_stage_policy",
								"type": "DatasetReference"
							},
							"name": "stgPolicy"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_stage_location",
								"type": "DatasetReference"
							},
							"name": "locationTarget"
						}
					],
					"transformations": [
						{
							"name": "select1"
						},
						{
							"name": "deriveLocationJson"
						},
						{
							"name": "join1"
						},
						{
							"name": "select2"
						},
						{
							"name": "addAddressJson"
						},
						{
							"name": "lookup1"
						},
						{
							"name": "filter1"
						},
						{
							"name": "renamePolicyIdCol"
						},
						{
							"name": "derivedColumn1"
						}
					],
					"scriptLines": [
						"parameters{",
						"     policyPrefix as string ('CFA')",
						"}",
						"source(output(",
						"          LOCATION_ID as long,",
						"          POLICY_ID as long,",
						"          LOCATION_EFF_DATE as timestamp,",
						"          LOCATION_EXP_DATE as timestamp,",
						"          GEN_ADDRESS_UNIQ_ID as long,",
						"          POLICY_NUMBER as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select pl.LOCATION_ID,pl.POLICY_ID,pl.LOCATION_EFF_DATE,PL.LOCATION_EXP_DATE,PL.GEN_ADDRESS_UNIQ_ID,p.POLICY_NUMBER,p.ENTITY_TYPE from POL_LOCATION  pl join POL_POLICY p on pl.POLICY_ID = p.POLICY_ID AND p.ENTITY_TYPE ='{$policyPrefix}'\"),",
						"     format: 'query') ~> locationStagingJoinStgingPolicy",
						"source(output(",
						"          address_id as integer,",
						"          json_data as string,",
						"          extendedattributes as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select * from address',",
						"     format: 'query') ~> addressTarget",
						"source(output(",
						"          policy_id as integer,",
						"          policy_number as string,",
						"          json_data as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> stgPolicy",
						"locationStagingJoinStgingPolicy select(mapColumn(",
						"          location_id = LOCATION_ID,",
						"          policy_id = POLICY_ID,",
						"          LOCATION_EFF_DATE,",
						"          LOCATION_EXP_DATE,",
						"          address_id = GEN_ADDRESS_UNIQ_ID,",
						"          POLICY_NUMBER",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"derivedColumn1 derive(derived_json_data = toString(@(typeCode=typeCode,\r",
						"          address=address_json_data,\r",
						"          earthquakeZone=false(),\r",
						"          effectiveDate=toString(toDate(toString(LOCATION_EFF_DATE))),\r",
						"          expirationDate=toString(toDate(toString(LOCATION_EXP_DATE))),\r",
						"          isCancelled=false(),\r",
						"          businessKey=toString(location_id)))) ~> deriveLocationJson",
						"select1, select2 join(select1@address_id == select2@address_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"addressTarget select(mapColumn(",
						"          address_id,",
						"          address_json_data = json_data",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select2",
						"deriveLocationJson derive(json_data = replace(replace(unescape(derived_json_data, 'json'), '\"{', '{'), '}\"', '}')) ~> addAddressJson",
						"join1, renamePolicyIdCol lookup(select1@POLICY_NUMBER == stgPolicy@policy_number,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lookup1",
						"lookup1 filter(!isNull(stgPolicy@policy_number)) ~> filter1",
						"stgPolicy derive(targetPolicyId = policy_id) ~> renamePolicyIdCol",
						"filter1 derive(policy_id = targetPolicyId,",
						"          typeCode = case($policyPrefix == 'CFA', 'PRIMARY_LOCATION', 'aquaCulture')) ~> derivedColumn1",
						"addAddressJson sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          location_id as integer,",
						"          policy_id as integer,",
						"          address_id as integer,",
						"          json_data as string,",
						"          extendedattributes as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> locationTarget"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_location')]",
				"[concat(variables('factoryId'), '/datasets/ds_stage_address')]",
				"[concat(variables('factoryId'), '/datasets/ds_stage_policy')]",
				"[concat(variables('factoryId'), '/datasets/ds_stage_location')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_stage_party')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Target Stage Data Flows/referenceDataFlow"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_party",
								"type": "DatasetReference"
							},
							"name": "partyStaging"
						},
						{
							"dataset": {
								"referenceName": "ds_stage_party",
								"type": "DatasetReference"
							},
							"name": "targetPartyLookup"
						},
						{
							"dataset": {
								"referenceName": "joinTableStageSQL",
								"type": "DatasetReference"
							},
							"name": "policyPartyRoleJoin"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_stage_party",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "deriveJson"
						},
						{
							"name": "derivedNames"
						},
						{
							"name": "filter1"
						},
						{
							"name": "exists1"
						},
						{
							"name": "alterRow1"
						},
						{
							"name": "lookup1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          PARTY_ID as long,",
						"          PARTY_VID as long,",
						"          NAME_PREFIX as string,",
						"          FIRST_NAME as string,",
						"          MIDDLE_NAME as string,",
						"          LAST_NAME as string,",
						"          FULL_NAME as string,",
						"          DATE_OF_BIRTH as timestamp,",
						"          GENDER as string,",
						"          SSN as string,",
						"          HIRE_DATE as timestamp,",
						"          POLICYINATION_DATE as timestamp,",
						"          EMAIL as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          PARTY_TYPE as string,",
						"          PHYSICAL_GEN_ADDRESS_ID as long,",
						"          HOME_PHONE_NUMBER as string,",
						"          FAX_NUMBER as string,",
						"          YEARS_WITH_EMPLOYER as integer,",
						"          NAME_SUFFIX as string,",
						"          MARITAL_STATUS as string,",
						"          OCCUPATION as string,",
						"          DOING_BUSINESS_AS as string,",
						"          DECEASED_DATE as timestamp,",
						"          IS_DECEASED_YN as string,",
						"          GEN_ADDRESS_UNIQ_ID as long,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> partyStaging",
						"source(output(",
						"          party_id as integer,",
						"          party_code as string,",
						"          parententityid as string,",
						"          json_data as string,",
						"          bpa_party_code as string,",
						"          bpa_party_id as string,",
						"          party_name as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> targetPartyLookup",
						"source(output(",
						"          PARTY_ID as long,",
						"          ROLE_CODE as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select distinct prb.PARTY_ID, pr.ROLE_CODE from POL_POLICY_PARTY_ROLE_BRIDGE as prb join POL_PARTY_ROLE as pr on prb.ROLE_ID = pr.ROLE_ID where pr.ROLE_CODE = \\'INSURED\\'\\n',",
						"     format: 'query') ~> policyPartyRoleJoin",
						"derivedNames derive(party_code = 1,",
						"          json_data = toString(@(partyTypeCode='person',\r",
						"   name=@(\r",
						"    fullName=derivedNames@full_name,\r",
						"    givenName=derivedNames@first_name,\r",
						"    surname=derivedNames@last_name\r",
						"   ),\r",
						"   person=@(birthDate=toString(toDate(toString(DATE_OF_BIRTH)))),\r",
						"   partyStatus= 'active',\r",
						"   partyRole= array(@(\r",
						"    effectiveDate=toString(currentDate()),\r",
						"    roleType='insured'\r",
						"   )),\r",
						"   languageCode=array('EN') \r",
						")),",
						"          party_name = derivedNames@full_name) ~> deriveJson",
						"lookup1 derive(full_name = iif(isNull(FULL_NAME)||equals(trim(FULL_NAME),''), concatWS(' ', trim(FIRST_NAME), trim(MIDDLE_NAME), trim(LAST_NAME)), FULL_NAME),",
						"          first_name = iif(isNull(FIRST_NAME)||equals(trim(FIRST_NAME),''), substringIndex(trim(FULL_NAME), ' ', size(split(trim(FULL_NAME), ' '))-1), FIRST_NAME),",
						"          last_name = iif(isNull(LAST_NAME)||equals(trim(LAST_NAME),''), (iif(size(split(trim(FULL_NAME), ' '))==1, split(trim(FULL_NAME), ' ')[1], split(trim(FULL_NAME), ' ')[size(split(trim(FULL_NAME), ' '))] )), LAST_NAME)) ~> derivedNames",
						"targetPartyLookup filter(isNull(bpa_party_code)) ~> filter1",
						"partyStaging, policyPartyRoleJoin exists(policyPartyRoleJoin@PARTY_ID == partyStaging@PARTY_ID,",
						"     negate:false,",
						"     broadcast: 'auto')~> exists1",
						"deriveJson alterRow(upsertIf(!isNull(partyStaging@PARTY_ID))) ~> alterRow1",
						"exists1, filter1 lookup(partyStaging@PARTY_ID == targetPartyLookup@party_id,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lookup1",
						"alterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          party_id as integer,",
						"          party_code as string,",
						"          parententityid as string,",
						"          json_data as string,",
						"          bpa_party_code as string,",
						"          bpa_party_id as string,",
						"          party_name as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:true,",
						"     keys:['party_id'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          party_id = partyStaging@PARTY_ID,",
						"          party_code,",
						"          json_data,",
						"          party_name",
						"     )) ~> sink1"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_party')]",
				"[concat(variables('factoryId'), '/datasets/ds_stage_party')]",
				"[concat(variables('factoryId'), '/datasets/joinTableStageSQL')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_stage_policy')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Target Stage Data Flows"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_policy",
								"type": "DatasetReference"
							},
							"name": "StagingPolicy"
						},
						{
							"dataset": {
								"referenceName": "ds_stage_policy",
								"type": "DatasetReference"
							},
							"name": "pkey"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_stage_policy",
								"type": "DatasetReference"
							},
							"name": "targetPolicyEMP"
						},
						{
							"name": "nextPkey"
						},
						{
							"dataset": {
								"referenceName": "ds_stage_policy",
								"type": "DatasetReference"
							},
							"name": "targetPolicyCFA"
						}
					],
					"transformations": [
						{
							"name": "policyDefaultJsonEMP"
						},
						{
							"name": "surrogateKey1"
						},
						{
							"name": "nbsCheck"
						},
						{
							"name": "select1"
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "derivedColumn2"
						},
						{
							"name": "split1"
						},
						{
							"name": "policyDefaultJsonCfa"
						},
						{
							"name": "select2"
						}
					],
					"scriptLines": [
						"parameters{",
						"     policyPrefix as string ('CFA')",
						"}",
						"source(output(",
						"          POLICY_ID as long,",
						"          POLICY_VID as long,",
						"          REINSURANCE_DAC as string,",
						"          PREVIOUS_INSURANCE_NO_REMARKS as string,",
						"          AGENCY_ID as long,",
						"          AGENCY_OVID as long,",
						"          PRODUCER_ID as long,",
						"          PRODUCER_OVID as long,",
						"          PRODUCER_CONTACT_ID as long,",
						"          PRODUCER_CONTACT_OVID as long,",
						"          POLICY_NUMBER as string,",
						"          ENTITY_TYPE as string,",
						"          ENTITY_STATUS as string,",
						"          IS_RENEWAL_YN as string,",
						"          REVISION_NUMBER as integer,",
						"          PRODUCT_ID as long,",
						"          PRODUCT_OVID as long,",
						"          POLICY_EFFECTIVE_DATE as timestamp,",
						"          POLICY_EXPIRATION_DATE as timestamp,",
						"          NON_RENEWAL_CODE as string,",
						"          POLICY_RENEWED_YN as string,",
						"          CANCELLATION_DATE as timestamp,",
						"          IS_RENEWABLE_YN as string,",
						"          PREVIOUS_INSURANCE_NO_REASON as string,",
						"          POLICY_STATUS as string,",
						"          CANCEL_REASON_CODE as string,",
						"          CANCEL_REASON_DESCRIPTION as string,",
						"          CANCEL_METHOD as string,",
						"          CANCEL_METHOD_DESC as string,",
						"          LOSE_REASON_CODE as string,",
						"          LOSE_REASON_DESC as string,",
						"          DECLINATION_REASON_CODE as string,",
						"          DECLINATION_REASON_DESC as string,",
						"          NOT_WRITTEN_REASON_CODE as string,",
						"          NOT_WRITTEN_REASON_DESC as string,",
						"          POLICY_STATE_CODE as string,",
						"          PROGRAM_ID as long,",
						"          PROGRAM_OVID as long,",
						"          BILLING_TYPE_CODE as string,",
						"          UNDERWRITING_COMPANY_ID as long,",
						"          UNDERWRITING_COMPANY_OVID as long,",
						"          SUBMISSION_ID as long,",
						"          PREVIOUS_INSURANCE_YN as string,",
						"          LEGACY_POLICY_NUMBER as string,",
						"          POLICY_POLICY as short,",
						"          PAYMENT_PLAN as string,",
						"          APPLICATION_RECEIVED_DATE as timestamp,",
						"          INCEPTION_DATE as timestamp,",
						"          BILL_TYPE as string,",
						"          FORMS_LANGUAGE as string,",
						"          BASE_CURRENCY as string,",
						"          INVOICE_CURRENCY as string,",
						"          PREVIOUS_POLICY_ID as long,",
						"          PREVIOUS_POLICY_OVID as long,",
						"          REVISED_FROM_POLICY_ID as long,",
						"          REVISED_FROM_POLICY_OVID as long,",
						"          OPERATING_COMPANY_ID as long,",
						"          OPERATING_COMPANY_OVID as long,",
						"          CONVERTED_FROM_ID as long,",
						"          CONVERTED_FROM_OVID as long,",
						"          INSTALLMENT_RENEWAL as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> StagingPolicy",
						"source(output(",
						"          policy_id as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select Max(policy_id) as policy_id from policy ',",
						"     format: 'query') ~> pkey",
						"split1@emp derive(json_data = toString(@(companyProductCode=\"EMPL\",",
						"          lineofBusinessCode=\"EQMR\",",
						"          isSTP=true(),",
						"          effectiveDate='2024-01-01',",
						"          expirationDate='2024-12-31',",
						"          policyTerm=PAYMENT_PLAN,",
						"          operatingCompanyCode=\"P204855\",",
						"          productVersion=\"1.0\",",
						"          statusCodeDisplayName=\"BoundPendingIssuance\",",
						"          paymentInfo=billingInfo,",
						"          carrierProcessingType=\"carrier\",",
						"          currencyCode=\"USD\",",
						"          section=array(),",
						"          clientParticipant=array(),",
						"          agent=array(),",
						"          extendedAttributes=array(extendedAttributes)))) ~> policyDefaultJsonEMP",
						"StagingPolicy keyGenerate(output(pkey as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> surrogateKey1",
						"derivedColumn1 derive(bptc = iif(REVISION_NUMBER==1,'NBS',''),",
						"          bpt = iif(REVISION_NUMBER==1,'NBS','New Business'),",
						"          clientParticipant = @(roleCode='insured',",
						"          partyCode='P216723',",
						"          subRoleCode='primaryInsured',",
						"          professionalRole='insured'),",
						"          agent = @(typeCode='writing',",
						"          agencyCode='P334416',",
						"          partyCode='P356264',",
						"          agencyType='wholesale',",
						"          agencyTier='T2'),",
						"          extendedAttributes = @(name='externalPolicyNo',",
						"          value=POLICY_NUMBER),",
						"          billingInfo = @(billingType='DBI',",
						"          paymentPlan='PPC001'),",
						"          policy_number = POLICY_NUMBER) ~> nbsCheck",
						"policyDefaultJsonEMP select(mapColumn(",
						"          policy_id = split1@emp@POLICY_ID,",
						"          policy_number = split1@emp@policy_number,",
						"          json_data",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"surrogateKey1 derive(effectiveDate = split(toString(POLICY_EFFECTIVE_DATE), ' ')[1],",
						"          expirationDate = split(toString(POLICY_EXPIRATION_DATE), ' ')[1],",
						"          policy_id = toLong(nextPkey#outputs()[1].policy_id)+pkey) ~> derivedColumn1",
						"pkey derive(policy_id = iifNull(policy_id, 0, policy_id)) ~> derivedColumn2",
						"nbsCheck split($policyPrefix == 'EMP' && ENTITY_TYPE=='EMP',",
						"     ENTITY_TYPE=='CFA' && $policyPrefix == 'CFA',",
						"     disjoint: false) ~> split1@(emp, cfa, others)",
						"split1@cfa derive(json_data = toString(@(companyProductCode=\"CFA1\",          lineofBusinessCode=\"CFA\",isSTP=true(),      effectiveDate= '2023-12-02' ,          expirationDate= '2024-12-31' ,         policyTerm=PAYMENT_PLAN,          operatingCompanyCode=\"P204855\",          productVersion=\"1.0\", statusCodeDisplayName=\"BoundPendingIssuance\",  paymentInfo=billingInfo   ,              carrierProcessingType=\"carrier\",                   currencyCode=\"USD\",         section=array(),clientParticipant=array(),agent=array(),extendedAttributes=array(extendedAttributes)))) ~> policyDefaultJsonCfa",
						"policyDefaultJsonCfa select(mapColumn(",
						"          policy_id = split1@cfa@policy_id,",
						"          policy_number = split1@cfa@policy_number,",
						"          json_data",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select2",
						"select1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          policy_id as integer,",
						"          policy_number as string,",
						"          json_data as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> targetPolicyEMP",
						"derivedColumn2 sink(validateSchema: false,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     store: 'cache',",
						"     format: 'inline',",
						"     output: false,",
						"     saveOrder: 1) ~> nextPkey",
						"select2 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          policy_id as integer,",
						"          policy_number as string,",
						"          json_data as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> targetPolicyCFA"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_policy')]",
				"[concat(variables('factoryId'), '/datasets/ds_stage_policy')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_stage_policyLevel_coverages')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Target Stage Data Flows"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_policy",
								"type": "DatasetReference"
							},
							"name": "ssCoverages"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_coverageExt",
								"type": "DatasetReference"
							},
							"name": "ssCoverageExt"
						},
						{
							"dataset": {
								"referenceName": "ECMBPA_COV_MAP",
								"type": "DatasetReference"
							},
							"name": "ecmBpaCovMap"
						},
						{
							"dataset": {
								"referenceName": "ds_stage_policy",
								"type": "DatasetReference"
							},
							"name": "targetPolicy"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policy",
								"type": "DatasetReference"
							},
							"name": "srcStgPolicy"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_stage_coverage",
								"type": "DatasetReference"
							},
							"name": "osStageCoverage"
						},
						{
							"name": "sink2"
						}
					],
					"transformations": [
						{
							"name": "sort1"
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "select1"
						},
						{
							"name": "derivedColumn2"
						},
						{
							"name": "derivedColumn4"
						},
						{
							"name": "derivedColumn5"
						},
						{
							"name": "join2"
						},
						{
							"name": "filterByPolicyLevel"
						},
						{
							"name": "filter1"
						},
						{
							"name": "targetPolicyID"
						},
						{
							"name": "joinByStgAndTargetPolicy"
						},
						{
							"name": "join3"
						},
						{
							"name": "filter2"
						},
						{
							"name": "filter3"
						},
						{
							"name": "filter4"
						}
					],
					"scriptLines": [
						"parameters{",
						"     isLimitUpdateOnlyForPolicy as boolean (false()),",
						"     policyPrefix as string ('CFA'),",
						"     locationState as string ('Montana')",
						"}",
						"source(output(",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          LOCATION_ID as long,",
						"          LOCATION_OVID as long,",
						"          COVERAGE_ID as long,",
						"          COVERAGE_OVID as long,",
						"          COVERAGE_CODE as string,",
						"          COVERAGE_EFFECTIVE_DATE as timestamp,",
						"          COVERAGE_EXPIRATION_DATE as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select distinct pp.POLICY_ID,pp.POLICY_VID as POLICY_OVID,pl.LOCATION_ID,pl.LOCATION_VID as LOCATION_OVID,pc.COVERAGE_ID,pc.COVERAGE_VID as COVERAGE_OVID,pc.COVERAGE_CODE,pc.COVERAGE_EFFECTIVE_DATE,pc.COVERAGE_EXPIRATION_DATE from POL_POLICY pp join POL_COVERAGE pc on pp.POLICY_ID = pc.POLICY_ID join POL_LOCATION pl on pl.POLICY_ID=pp.POLICY_ID  AND PL.LOCATION_NO IS NOT NULL   group by pp.POLICY_ID, pp.POLICY_VID,pl.LOCATION_ID,pl.LOCATION_VID,pc.COVERAGE_ID,pc.COVERAGE_VID,pc.COVERAGE_CODE,pc.COVERAGE_EFFECTIVE_DATE,pc.COVERAGE_EXPIRATION_DATE',",
						"     format: 'query') ~> ssCoverages",
						"source(output(",
						"          COVERAGE_ID as long,",
						"          ARICCoverageSequence as integer,",
						"          ARICGroupCode as string,",
						"          LocationState as string,",
						"          ARICLOB as string,",
						"          CoverageDescription as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select DISTINCT COVERAGE_ID,ARICCoverageSequence,ARICGroupCode,LocationState,ARICLOB,CoverageDescription from POL_COVERAGE_EXT',",
						"     format: 'query') ~> ssCoverageExt",
						"source(output(",
						"          COV_SEQ as string,",
						"          BPA_SECTION_CODE as string,",
						"          COVERAGE_CODE as string,",
						"          COVERAGE_CODE_DES as string,",
						"          BPA_COVERAGE_CODES as string,",
						"          BPA_COVERAGES as string,",
						"          COVERAGES as string,",
						"          BPA_PRODUCT_CODE as string,",
						"          SI_NO as string,",
						"          id as long,",
						"          BPA_SEC_NAME as string,",
						"          SOURCE_PRODUCT_CODE as string,",
						"          bpa_coverage_group as string,",
						"          bpa_coverage_level as string,",
						"          bpa_coverage_type as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> ecmBpaCovMap",
						"source(output(",
						"          policy_id as integer,",
						"          policy_number as string,",
						"          json_data as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> targetPolicy",
						"source(output(",
						"          POLICY_ID as long,",
						"          POLICY_VID as long,",
						"          REINSURANCE_DAC as string,",
						"          PREVIOUS_INSURANCE_NO_REMARKS as string,",
						"          AGENCY_ID as long,",
						"          AGENCY_OVID as long,",
						"          PRODUCER_ID as long,",
						"          PRODUCER_OVID as long,",
						"          PRODUCER_CONTACT_ID as long,",
						"          PRODUCER_CONTACT_OVID as long,",
						"          POLICY_NUMBER as string,",
						"          ENTITY_TYPE as string,",
						"          ENTITY_STATUS as string,",
						"          IS_RENEWAL_YN as string,",
						"          REVISION_NUMBER as integer,",
						"          PRODUCT_ID as long,",
						"          PRODUCT_OVID as long,",
						"          POLICY_EFFECTIVE_DATE as timestamp,",
						"          POLICY_EXPIRATION_DATE as timestamp,",
						"          NON_RENEWAL_CODE as string,",
						"          POLICY_RENEWED_YN as string,",
						"          CANCELLATION_DATE as timestamp,",
						"          IS_RENEWABLE_YN as string,",
						"          PREVIOUS_INSURANCE_NO_REASON as string,",
						"          POLICY_STATUS as string,",
						"          CANCEL_REASON_CODE as string,",
						"          CANCEL_REASON_DESCRIPTION as string,",
						"          CANCEL_METHOD as string,",
						"          CANCEL_METHOD_DESC as string,",
						"          LOSE_REASON_CODE as string,",
						"          LOSE_REASON_DESC as string,",
						"          DECLINATION_REASON_CODE as string,",
						"          DECLINATION_REASON_DESC as string,",
						"          NOT_WRITTEN_REASON_CODE as string,",
						"          NOT_WRITTEN_REASON_DESC as string,",
						"          POLICY_STATE_CODE as string,",
						"          PROGRAM_ID as long,",
						"          PROGRAM_OVID as long,",
						"          BILLING_TYPE_CODE as string,",
						"          UNDERWRITING_COMPANY_ID as long,",
						"          UNDERWRITING_COMPANY_OVID as long,",
						"          SUBMISSION_ID as long,",
						"          PREVIOUS_INSURANCE_YN as string,",
						"          LEGACY_POLICY_NUMBER as string,",
						"          STATE as string,",
						"          POLICY_POLICY as integer,",
						"          PAYMENT_PLAN as string,",
						"          APPLICATION_RECEIVED_DATE as timestamp,",
						"          INCEPTION_DATE as timestamp,",
						"          BILL_TYPE as string,",
						"          FORMS_LANGUAGE as string,",
						"          BASE_CURRENCY as string,",
						"          INVOICE_CURRENCY as string,",
						"          PREVIOUS_POLICY_ID as long,",
						"          PREVIOUS_POLICY_OVID as long,",
						"          REVISED_FROM_POLICY_ID as long,",
						"          REVISED_FROM_POLICY_OVID as long,",
						"          OPERATING_COMPANY_ID as long,",
						"          OPERATING_COMPANY_OVID as long,",
						"          CONVERTED_FROM_ID as long,",
						"          CONVERTED_FROM_OVID as long,",
						"          INSTALLMENT_RENEWAL as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> srcStgPolicy",
						"ssCoverages sort(asc(POLICY_ID, true)) ~> sort1",
						"derivedColumn4 derive(Policy_ID = targetPolicyID,",
						"          COVERAGE_ID = ssCoverages@COVERAGE_ID,",
						"          jsonData = @(typeCode=bpa_cov_codes,",
						"          coverageType=coverage_type,",
						"          displayName=trim(bpa_cov_desc),",
						"          parentEntityTypeName='Section',",
						"          fullPremium=0.0,",
						"          effectiveDate=toDate(COVERAGE_EFFECTIVE_DATE),",
						"          expirationDate=toDate(COVERAGE_EXPIRATION_DATE),",
						"          limit=array(),",
						"          deductible=array(),",
						"          option=array(),",
						"          isCancelled=false(),",
						"          tax=array(),",
						"          amountItem=array(),",
						"          extendedAttributes=array(),",
						"          coverageGroup=coverage_group,",
						"          appliesToLevel='SECT')) ~> derivedColumn1",
						"derivedColumn2 select(mapColumn(",
						"          policy_id = ssCoverages@POLICY_ID,",
						"          coverage_id = COVERAGE_ID,",
						"          coverage_code = COVERAGE_CODE,",
						"          json_data",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"derivedColumn1 derive(json_data = toString(jsonData)) ~> derivedColumn2",
						"join3 derive(bpaCodeLookup = sink2#lookup(toString(ARICCoverageSequence)),",
						"          bpa_cov_codes = sink2#lookup(toString(ARICCoverageSequence)).BPA_COVERAGE_CODES,",
						"          bpa_cov_desc = sink2#lookup(toString(ARICCoverageSequence)).BPA_COVERAGES,",
						"          coverage_type = sink2#lookup(toString(ARICCoverageSequence)).bpa_coverage_type,",
						"          coverage_group = sink2#lookup(toString(ARICCoverageSequence)).bpa_coverage_group) ~> derivedColumn4",
						"filter4 derive(ARICCoverageSequence = COV_SEQ) ~> derivedColumn5",
						"sort1, ssCoverageExt join(ssCoverages@COVERAGE_ID == ssCoverageExt@COVERAGE_ID,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join2",
						"join2 filter(sink2#lookup(toString(ARICCoverageSequence)).bpa_coverage_level == 'P') ~> filterByPolicyLevel",
						"ecmBpaCovMap filter(BPA_PRODUCT_CODE == $policyPrefix && bpa_coverage_level == 'P') ~> filter1",
						"targetPolicy derive(targetPolicyID = policy_id) ~> targetPolicyID",
						"targetPolicyID, filter2 join(targetPolicy@policy_number == srcStgPolicy@POLICY_NUMBER,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinByStgAndTargetPolicy",
						"filterByPolicyLevel, joinByStgAndTargetPolicy join(ssCoverages@POLICY_ID == targetPolicy@policy_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join3",
						"srcStgPolicy filter(ENTITY_TYPE==$policyPrefix) ~> filter2",
						"joinByStgAndTargetPolicy filter(ENTITY_TYPE == $policyPrefix) ~> filter3",
						"filter1 filter(isNull(bpa_coverage_group)||($policyPrefix == 'CFA' && (bpa_coverage_group == 'Liability' ||bpa_coverage_group == 'Physical Damage' ||bpa_coverage_group == $locationState || bpa_coverage_group == 'common'))) ~> filter4",
						"select1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          coverage_id as integer,",
						"          policy_id as integer,",
						"          json_data as string,",
						"          coverage_code as string,",
						"          risk_id as long,",
						"          location_id as long",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     saveOrder: 2) ~> osStageCoverage",
						"derivedColumn5 sink(validateSchema: false,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     keys:['ARICCoverageSequence'],",
						"     store: 'cache',",
						"     format: 'inline',",
						"     output: false,",
						"     saveOrder: 1) ~> sink2"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_policy')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_coverageExt')]",
				"[concat(variables('factoryId'), '/datasets/ECMBPA_COV_MAP')]",
				"[concat(variables('factoryId'), '/datasets/ds_stage_policy')]",
				"[concat(variables('factoryId'), '/datasets/ds_stage_coverage')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_stage_risk')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Target Stage Data Flows"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRisk",
								"type": "DatasetReference"
							},
							"name": "ssRisk"
						},
						{
							"dataset": {
								"referenceName": "ds_stage_riskDetail",
								"type": "DatasetReference"
							},
							"name": "riskDetails"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policy",
								"type": "DatasetReference"
							},
							"name": "stgPolicy"
						},
						{
							"dataset": {
								"referenceName": "StgRefLookUp",
								"type": "DatasetReference"
							},
							"name": "lookUp"
						},
						{
							"dataset": {
								"referenceName": "StgLookUpType",
								"type": "DatasetReference"
							},
							"name": "lookupType"
						},
						{
							"dataset": {
								"referenceName": "ds_stage_policy",
								"type": "DatasetReference"
							},
							"name": "targetPolicy"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_stage_risk",
								"type": "DatasetReference"
							},
							"name": "targetRisk"
						},
						{
							"dataset": {
								"referenceName": "ds_stage_risk",
								"type": "DatasetReference"
							},
							"name": "targetRiskCfa"
						}
					],
					"transformations": [
						{
							"name": "addRiskDetails"
						},
						{
							"name": "lookup1"
						},
						{
							"name": "derivedColumn2"
						},
						{
							"name": "stringify"
						},
						{
							"name": "AlterRow1"
						},
						{
							"name": "join1"
						},
						{
							"name": "split1"
						},
						{
							"name": "riskInfoCFA"
						},
						{
							"name": "alterRow2"
						},
						{
							"name": "join2"
						},
						{
							"name": "select1"
						},
						{
							"name": "typeLookup"
						},
						{
							"name": "targetPolicyWithStgPolicy"
						},
						{
							"name": "renamePolicyIDCol"
						},
						{
							"name": "select2"
						},
						{
							"name": "select3"
						},
						{
							"name": "aggregate1"
						},
						{
							"name": "derivedColumn3"
						},
						{
							"name": "derivedColumn4"
						},
						{
							"name": "select4"
						}
					],
					"scriptLines": [
						"parameters{",
						"     isRiskUpdateOnly as boolean (false()),",
						"     policyPrefix as string ('EMP')",
						"}",
						"source(output(",
						"          RISK_ID as long,",
						"          RISK_TYPE_CD as string,",
						"          POLICY_ID as long,",
						"          LOCATION_ID as long,",
						"          ENTITY_TYPE as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select pr.RISK_ID, pr.RISK_TYPE_CD,pr.POLICY_ID,lrb.LOCATION_ID,pl.ENTITY_TYPE from \\nPOL_RISK pr \\njoin [POL_POLICY] pl\\non pl.POLICY_ID = pr.POLICY_ID\\njoin [POL_LOCATION_RISK_BRIDGE] lrb\\non lrb.RISK_ID = pr.RISK_ID\\n',",
						"     format: 'query') ~> ssRisk",
						"source(output(",
						"          risk_detail_id as integer,",
						"          risk_id as integer,",
						"          policy_id as integer,",
						"          json_data as string,",
						"          extended_attributes as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT * FROM public.risk_detail ',",
						"     format: 'query') ~> riskDetails",
						"source(output(",
						"          POLICY_ID as long,",
						"          POLICY_VID as long,",
						"          REINSURANCE_DAC as string,",
						"          PREVIOUS_INSURANCE_NO_REMARKS as string,",
						"          AGENCY_ID as long,",
						"          AGENCY_OVID as long,",
						"          PRODUCER_ID as long,",
						"          PRODUCER_OVID as long,",
						"          PRODUCER_CONTACT_ID as long,",
						"          PRODUCER_CONTACT_OVID as long,",
						"          POLICY_NUMBER as string,",
						"          ENTITY_TYPE as string,",
						"          ENTITY_STATUS as string,",
						"          IS_RENEWAL_YN as string,",
						"          REVISION_NUMBER as integer,",
						"          PRODUCT_ID as long,",
						"          PRODUCT_OVID as long,",
						"          POLICY_EFFECTIVE_DATE as timestamp,",
						"          POLICY_EXPIRATION_DATE as timestamp,",
						"          NON_RENEWAL_CODE as string,",
						"          POLICY_RENEWED_YN as string,",
						"          CANCELLATION_DATE as timestamp,",
						"          IS_RENEWABLE_YN as string,",
						"          PREVIOUS_INSURANCE_NO_REASON as string,",
						"          POLICY_STATUS as string,",
						"          CANCEL_REASON_CODE as string,",
						"          CANCEL_REASON_DESCRIPTION as string,",
						"          CANCEL_METHOD as string,",
						"          CANCEL_METHOD_DESC as string,",
						"          LOSE_REASON_CODE as string,",
						"          LOSE_REASON_DESC as string,",
						"          DECLINATION_REASON_CODE as string,",
						"          DECLINATION_REASON_DESC as string,",
						"          NOT_WRITTEN_REASON_CODE as string,",
						"          NOT_WRITTEN_REASON_DESC as string,",
						"          POLICY_STATE_CODE as string,",
						"          PROGRAM_ID as long,",
						"          PROGRAM_OVID as long,",
						"          BILLING_TYPE_CODE as string,",
						"          UNDERWRITING_COMPANY_ID as long,",
						"          UNDERWRITING_COMPANY_OVID as long,",
						"          SUBMISSION_ID as long,",
						"          PREVIOUS_INSURANCE_YN as string,",
						"          LEGACY_POLICY_NUMBER as string,",
						"          STATE as string,",
						"          POLICY_POLICY as integer,",
						"          PAYMENT_PLAN as string,",
						"          APPLICATION_RECEIVED_DATE as timestamp,",
						"          INCEPTION_DATE as timestamp,",
						"          BILL_TYPE as string,",
						"          FORMS_LANGUAGE as string,",
						"          BASE_CURRENCY as string,",
						"          INVOICE_CURRENCY as string,",
						"          PREVIOUS_POLICY_ID as long,",
						"          PREVIOUS_POLICY_OVID as long,",
						"          REVISED_FROM_POLICY_ID as long,",
						"          REVISED_FROM_POLICY_OVID as long,",
						"          OPERATING_COMPANY_ID as long,",
						"          OPERATING_COMPANY_OVID as long,",
						"          CONVERTED_FROM_ID as long,",
						"          CONVERTED_FROM_OVID as long,",
						"          INSTALLMENT_RENEWAL as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select * from POL_POLICY ',",
						"     format: 'query') ~> stgPolicy",
						"source(output(",
						"          LOOKUP_ID as long,",
						"          LOOKUP_TYPE_ID as long,",
						"          LOOKUP_CODE as string,",
						"          LOOKUP_SHORT_DESCRIPTION as string,",
						"          LOOKUP_DESCRIPTION as string,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          DATA_HASH as binary,",
						"          SOURCE_KEY as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> lookUp",
						"source(output(",
						"          LOOKUP_TYPE_ID as long,",
						"          LOOKUP_TYPE_DOMAIN as string,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          DATA_HASH as binary,",
						"          SOURCE_KEY as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> lookupType",
						"source(output(",
						"          policy_id as integer,",
						"          policy_number as string,",
						"          json_data as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select * from policy',",
						"     format: 'query') ~> targetPolicy",
						"split1@emp derive(json_data = @(businessKey=split1@emp@RISK_ID,",
						"          typeCode='equine',",
						"          extendedAttributes=horseDetails,",
						"          appliesToLevel='LOC',",
						"          appliesToCode=LOCATION_ID,",
						"          isCancelled=false()),",
						"          policy_id = targetPolicyId,",
						"          location_id = LOCATION_ID) ~> addRiskDetails",
						"join1, derivedColumn2 lookup(ssRisk@RISK_ID == riskDetails@risk_id,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lookup1",
						"derivedColumn3 derive(horseDetails = json_data,",
						"          lookupRiskID = risk_id) ~> derivedColumn2",
						"addRiskDetails derive(json_data = toString(json_data),",
						"          risk_id = split1@emp@RISK_ID) ~> stringify",
						"select3 alterRow(updateIf(!isNull(lookupRiskID)&&$isRiskUpdateOnly),",
						"     insertIf(isNull(lookupRiskID))) ~> AlterRow1",
						"ssRisk, targetPolicyWithStgPolicy join(ssRisk@POLICY_ID == stgPolicy@POLICY_ID,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"aggregate1 split($policyPrefix == 'EMP' && ENTITY_TYPE == 'EMP',",
						"     $policyPrefix == 'CFA'  && ENTITY_TYPE == 'CFA',",
						"     disjoint: false) ~> split1@(emp, cfa, others)",
						"typeLookup derive(policy_id = targetPolicyId,",
						"          location_id = LOCATION_ID,",
						"          json_data = toString(@(businessKey=split1@cfa@RISK_ID,",
						"          typeCode=LOOKUP_DESCRIPTION,",
						"          extendedAttributes=horseDetails,",
						"          appliesToLevel='LOC',",
						"          appliesToCode=LOCATION_ID,",
						"          isCancelled=false()))) ~> riskInfoCFA",
						"select2 alterRow(updateIf(!isNull(lookupRiskID)&&$isRiskUpdateOnly),",
						"     insertIf(isNull(lookupRiskID))) ~> alterRow2",
						"lookUp, lookupType join(lookUp@LOOKUP_TYPE_ID == lookupType@LOOKUP_TYPE_ID,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join2",
						"join2 select(mapColumn(",
						"          LOOKUP_CODE,",
						"          LOOKUP_DESCRIPTION",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"split1@cfa, select1 lookup(RISK_TYPE_CD == LOOKUP_CODE,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> typeLookup",
						"derivedColumn4, renamePolicyIDCol join(stgPolicy@POLICY_NUMBER == targetPolicy@policy_number,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> targetPolicyWithStgPolicy",
						"targetPolicy derive(targetPolicyId = policy_id) ~> renamePolicyIDCol",
						"riskInfoCFA select(mapColumn(",
						"          RISK_ID = split1@cfa@RISK_ID,",
						"          LOCATION_ID = riskInfoCFA@location_id,",
						"          json_data,",
						"          POLICY_ID = targetPolicyId,",
						"          lookupRiskID",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select2",
						"stringify select(mapColumn(",
						"          risk_id = stringify@risk_id,",
						"          policy_id = targetPolicyId,",
						"          LOCATION_ID = split1@emp@LOCATION_ID,",
						"          json_data,",
						"          lookupRiskID",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select3",
						"select4 aggregate(groupBy(select4@RISK_ID),",
						"     each(match(name!='RISK_ID'), $$ = first($$))) ~> aggregate1",
						"riskDetails derive(rd_policyID = policy_id) ~> derivedColumn3",
						"stgPolicy derive(stg_policy_id = POLICY_ID) ~> derivedColumn4",
						"lookup1 select(mapColumn(",
						"          RISK_ID = ssRisk@RISK_ID,",
						"          RISK_TYPE_CD,",
						"          POLICY_ID = ssRisk@POLICY_ID,",
						"          LOCATION_ID,",
						"          ENTITY_TYPE = ssRisk@ENTITY_TYPE,",
						"          POLICY_NUMBER = stgPolicy@POLICY_NUMBER,",
						"          ENTITY_TYPE = stgPolicy@ENTITY_TYPE,",
						"          REVISION_NUMBER,",
						"          POLICY_STATUS,",
						"          POLICY_STATE_CODE,",
						"          LEGACY_POLICY_NUMBER,",
						"          STATE,",
						"          POLICY_POLICY,",
						"          stg_policy_id,",
						"          policy_id = targetPolicy@policy_id,",
						"          policy_number = targetPolicy@policy_number,",
						"          json_data = targetPolicy@json_data,",
						"          targetPolicyId,",
						"          risk_detail_id,",
						"          risk_id = riskDetails@risk_id,",
						"          policy_id = riskDetails@policy_id,",
						"          json_data = riskDetails@json_data,",
						"          extended_attributes,",
						"          rd_policyID,",
						"          horseDetails,",
						"          lookupRiskID,",
						"          RISK_ID = ssRisk@RISK_ID,",
						"          ENTITY_TYPE = ssRisk@ENTITY_TYPE",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select4",
						"AlterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          risk_id as integer,",
						"          policy_id as integer,",
						"          json_data as string,",
						"          location_id as long",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:true,",
						"     upsertable:true,",
						"     keys:['risk_id'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          risk_id,",
						"          policy_id,",
						"          json_data,",
						"          location_id = LOCATION_ID",
						"     )) ~> targetRisk",
						"alterRow2 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          risk_id as integer,",
						"          policy_id as integer,",
						"          json_data as string,",
						"          location_id as long",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:true,",
						"     upsertable:true,",
						"     keys:['risk_id'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          risk_id = RISK_ID,",
						"          policy_id = POLICY_ID,",
						"          json_data,",
						"          location_id = LOCATION_ID",
						"     )) ~> targetRiskCfa"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_policyRisk')]",
				"[concat(variables('factoryId'), '/datasets/ds_stage_riskDetail')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_policy')]",
				"[concat(variables('factoryId'), '/datasets/StgRefLookUp')]",
				"[concat(variables('factoryId'), '/datasets/StgLookUpType')]",
				"[concat(variables('factoryId'), '/datasets/ds_stage_policy')]",
				"[concat(variables('factoryId'), '/datasets/ds_stage_risk')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_stage_riskLevel_coverages')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Target Stage Data Flows"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_policy",
								"type": "DatasetReference"
							},
							"name": "ssCoverages"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_coverageExt",
								"type": "DatasetReference"
							},
							"name": "ssCoverageExt"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_locationRiskBridge",
								"type": "DatasetReference"
							},
							"name": "sslocation"
						},
						{
							"dataset": {
								"referenceName": "ECMBPA_COV_MAP",
								"type": "DatasetReference"
							},
							"name": "ecmBpaCovMap"
						},
						{
							"dataset": {
								"referenceName": "ds_stage_policy",
								"type": "DatasetReference"
							},
							"name": "targetPolicy"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policy",
								"type": "DatasetReference"
							},
							"name": "stgPolicy"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_stage_coverage",
								"type": "DatasetReference"
							},
							"name": "osStageCoverage"
						},
						{
							"name": "covCache"
						}
					],
					"transformations": [
						{
							"name": "sort1"
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "select1"
						},
						{
							"name": "derivedColumn2"
						},
						{
							"name": "locationSort"
						},
						{
							"name": "join1"
						},
						{
							"name": "derivedColumn4"
						},
						{
							"name": "derivedColumn5"
						},
						{
							"name": "join2"
						},
						{
							"name": "filterByNotPolicy"
						},
						{
							"name": "filter1"
						},
						{
							"name": "lookup1"
						},
						{
							"name": "joinStgPolAndTargetPolicy"
						},
						{
							"name": "derivedColumn6"
						},
						{
							"name": "join3"
						},
						{
							"name": "filterByEntityType"
						},
						{
							"name": "filter2"
						}
					],
					"scriptLines": [
						"parameters{",
						"     isLimitUpdateOnly as boolean (false()),",
						"     policyPrefix as string ('CFA'),",
						"     locationState as string ('Montana')",
						"}",
						"source(output(",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          LOCATION_ID as long,",
						"          LOCATION_OVID as long,",
						"          COVERAGE_ID as long,",
						"          COVERAGE_OVID as long,",
						"          COVERAGE_CODE as string,",
						"          COVERAGE_EFFECTIVE_DATE as timestamp,",
						"          COVERAGE_EXPIRATION_DATE as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select distinct pp.POLICY_ID,pp.POLICY_VID as POLICY_OVID,pl.LOCATION_ID,pl.LOCATION_VID as LOCATION_OVID,pc.COVERAGE_ID,pc.COVERAGE_VID as COVERAGE_OVID,pc.COVERAGE_CODE,pc.COVERAGE_EFFECTIVE_DATE,pc.COVERAGE_EXPIRATION_DATE from POL_POLICY pp join POL_COVERAGE pc on pp.POLICY_ID = pc.POLICY_ID join POL_LOCATION pl on pl.POLICY_ID=pp.POLICY_ID  AND PL.LOCATION_NO IS NOT NULL  group by pp.POLICY_ID, pp.POLICY_VID,pl.LOCATION_ID,pl.LOCATION_VID,pc.COVERAGE_ID,pc.COVERAGE_VID,pc.COVERAGE_CODE,pc.COVERAGE_EFFECTIVE_DATE,pc.COVERAGE_EXPIRATION_DATE\"),",
						"     format: 'query') ~> ssCoverages",
						"source(output(",
						"          COVERAGE_ID as long,",
						"          ARICCoverageSequence as integer,",
						"          ARICGroupCode as string,",
						"          LocationState as string,",
						"          ARICLOB as string,",
						"          CoverageDescription as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select DISTINCT COVERAGE_ID,ARICCoverageSequence,ARICGroupCode,LocationState,ARICLOB,CoverageDescription from POL_COVERAGE_EXT',",
						"     format: 'query') ~> ssCoverageExt",
						"source(output(",
						"          POLICY_ID as long,",
						"          LOCATION_ID as long,",
						"          COVERAGE_ID as long,",
						"          RISK_ID as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select plrd.POLICY_ID,pl.LOCATION_ID,plrd.COVERAGE_ID,plrd.RISK_ID from dbo.POL_TX_BRIDGE plrd join  POL_LOCATION pl on plrd.POLICY_ID = pl.POLICY_ID ',",
						"     format: 'query') ~> sslocation",
						"source(output(",
						"          COV_SEQ as string,",
						"          BPA_SECTION_CODE as string,",
						"          COVERAGE_CODE as string,",
						"          COVERAGE_CODE_DES as string,",
						"          BPA_COVERAGE_CODES as string,",
						"          BPA_COVERAGES as string,",
						"          COVERAGES as string,",
						"          BPA_PRODUCT_CODE as string,",
						"          SI_NO as string,",
						"          id as long,",
						"          BPA_SEC_NAME as string,",
						"          SOURCE_PRODUCT_CODE as string,",
						"          bpa_coverage_group as string,",
						"          bpa_coverage_level as string,",
						"          bpa_coverage_type as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> ecmBpaCovMap",
						"source(output(",
						"          policy_id as integer,",
						"          policy_number as string,",
						"          json_data as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> targetPolicy",
						"source(output(",
						"          POLICY_ID as long,",
						"          POLICY_VID as long,",
						"          REINSURANCE_DAC as string,",
						"          PREVIOUS_INSURANCE_NO_REMARKS as string,",
						"          AGENCY_ID as long,",
						"          AGENCY_OVID as long,",
						"          PRODUCER_ID as long,",
						"          PRODUCER_OVID as long,",
						"          PRODUCER_CONTACT_ID as long,",
						"          PRODUCER_CONTACT_OVID as long,",
						"          POLICY_NUMBER as string,",
						"          ENTITY_TYPE as string,",
						"          ENTITY_STATUS as string,",
						"          IS_RENEWAL_YN as string,",
						"          REVISION_NUMBER as integer,",
						"          PRODUCT_ID as long,",
						"          PRODUCT_OVID as long,",
						"          POLICY_EFFECTIVE_DATE as timestamp,",
						"          POLICY_EXPIRATION_DATE as timestamp,",
						"          NON_RENEWAL_CODE as string,",
						"          POLICY_RENEWED_YN as string,",
						"          CANCELLATION_DATE as timestamp,",
						"          IS_RENEWABLE_YN as string,",
						"          PREVIOUS_INSURANCE_NO_REASON as string,",
						"          POLICY_STATUS as string,",
						"          CANCEL_REASON_CODE as string,",
						"          CANCEL_REASON_DESCRIPTION as string,",
						"          CANCEL_METHOD as string,",
						"          CANCEL_METHOD_DESC as string,",
						"          LOSE_REASON_CODE as string,",
						"          LOSE_REASON_DESC as string,",
						"          DECLINATION_REASON_CODE as string,",
						"          DECLINATION_REASON_DESC as string,",
						"          NOT_WRITTEN_REASON_CODE as string,",
						"          NOT_WRITTEN_REASON_DESC as string,",
						"          POLICY_STATE_CODE as string,",
						"          PROGRAM_ID as long,",
						"          PROGRAM_OVID as long,",
						"          BILLING_TYPE_CODE as string,",
						"          UNDERWRITING_COMPANY_ID as long,",
						"          UNDERWRITING_COMPANY_OVID as long,",
						"          SUBMISSION_ID as long,",
						"          PREVIOUS_INSURANCE_YN as string,",
						"          LEGACY_POLICY_NUMBER as string,",
						"          STATE as string,",
						"          POLICY_POLICY as integer,",
						"          PAYMENT_PLAN as string,",
						"          APPLICATION_RECEIVED_DATE as timestamp,",
						"          INCEPTION_DATE as timestamp,",
						"          BILL_TYPE as string,",
						"          FORMS_LANGUAGE as string,",
						"          BASE_CURRENCY as string,",
						"          INVOICE_CURRENCY as string,",
						"          PREVIOUS_POLICY_ID as long,",
						"          PREVIOUS_POLICY_OVID as long,",
						"          REVISED_FROM_POLICY_ID as long,",
						"          REVISED_FROM_POLICY_OVID as long,",
						"          OPERATING_COMPANY_ID as long,",
						"          OPERATING_COMPANY_OVID as long,",
						"          CONVERTED_FROM_ID as long,",
						"          CONVERTED_FROM_OVID as long,",
						"          INSTALLMENT_RENEWAL as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from POL_POLICY where ENTITY_TYPE='{$policyPrefix}'\" ),",
						"     format: 'query') ~> stgPolicy",
						"ssCoverages sort(asc(POLICY_ID, true)) ~> sort1",
						"derivedColumn4 derive(COVERAGE_ID = ssCoverages@COVERAGE_ID,",
						"          jsonData = @(typeCode=bpa_cov_codes,",
						"          coverageType=bpa_coverage_type,",
						"          displayName=trim(bpa_cov_desc),",
						"          parentEntityTypeName='Section',",
						"          fullPremium=0.0,",
						"          effectiveDate=toDate(COVERAGE_EFFECTIVE_DATE),",
						"          expirationDate=toDate(COVERAGE_EXPIRATION_DATE),",
						"          limit=array(),",
						"          deductible=array(),",
						"          option=array(),",
						"          isCancelled=false(),",
						"          tax=array(),",
						"          amountItem=array(),",
						"          extendedAttributes=array(),",
						"          coverageGroupName=bpa_coverage_group,",
						"          appliesToLevel='RSKUNIT',",
						"          appliesToCode=toString(RISK_ID))) ~> derivedColumn1",
						"derivedColumn2 select(mapColumn(",
						"          policy_id = targetPolicyId,",
						"          coverage_id = COVERAGE_ID,",
						"          location_id = ssCoverages@LOCATION_ID,",
						"          coverage_code = ssCoverages@COVERAGE_CODE,",
						"          risk_id = RISK_ID,",
						"          json_data",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"derivedColumn1 derive(json_data = toString(jsonData)) ~> derivedColumn2",
						"sslocation sort(asc(POLICY_ID, false)) ~> locationSort",
						"filterByNotPolicy, locationSort join(ssCoverages@POLICY_ID == sslocation@POLICY_ID",
						"     && ssCoverages@COVERAGE_ID == sslocation@COVERAGE_ID",
						"     && ssCoverages@LOCATION_ID == sslocation@LOCATION_ID,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"join3 derive(bpa_cov_codes = BPA_COVERAGE_CODES,",
						"          bpa_cov_desc = BPA_COVERAGES,",
						"          bpa_coverage_type = bpa_coverage_type,",
						"          bpa_coverage_group = bpa_coverage_group) ~> derivedColumn4",
						"filter2 derive(ARICCoverageSequence = COV_SEQ) ~> derivedColumn5",
						"sort1, ssCoverageExt join(ssCoverages@COVERAGE_ID == ssCoverageExt@COVERAGE_ID,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join2",
						"lookup1 filter(!isNull(POLICY_ID) && !isNull(SI_NO) && bpa_coverage_level == 'U') ~> filterByNotPolicy",
						"ecmBpaCovMap filter(BPA_SECTION_CODE != 'SEC000' && BPA_PRODUCT_CODE ==$policyPrefix && trim(bpa_coverage_level) <=> 'U') ~> filter1",
						"join2, filter2 lookup(split(ssCoverages@COVERAGE_CODE,'-')[4] == trim(ecmBpaCovMap@COVERAGE_CODE)",
						"     && trim(toString(ARICCoverageSequence)) == trim(COV_SEQ),",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lookup1",
						"derivedColumn6, stgPolicy join(targetPolicy@policy_number == stgPolicy@POLICY_NUMBER,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinStgPolAndTargetPolicy",
						"targetPolicy derive(targetPolicyId = policy_id) ~> derivedColumn6",
						"join1, filterByEntityType join(ssCoverages@POLICY_ID == stgPolicy@POLICY_ID,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join3",
						"joinStgPolAndTargetPolicy filter(ENTITY_TYPE == $policyPrefix) ~> filterByEntityType",
						"filter1 filter(isNull(bpa_coverage_group)||($policyPrefix == 'CFA' && (bpa_coverage_group == 'Liability' ||bpa_coverage_group == 'Physical Damage' ||bpa_coverage_group == $locationState || bpa_coverage_group == 'common'))) ~> filter2",
						"select1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          coverage_id as integer,",
						"          policy_id as integer,",
						"          json_data as string,",
						"          coverage_code as string,",
						"          risk_id as long,",
						"          location_id as long",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     saveOrder: 2) ~> osStageCoverage",
						"derivedColumn5 sink(validateSchema: false,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     keys:['ARICCoverageSequence'],",
						"     store: 'cache',",
						"     format: 'inline',",
						"     output: false,",
						"     saveOrder: 1) ~> covCache"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_policy')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_coverageExt')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_locationRiskBridge')]",
				"[concat(variables('factoryId'), '/datasets/ECMBPA_COV_MAP')]",
				"[concat(variables('factoryId'), '/datasets/ds_stage_policy')]",
				"[concat(variables('factoryId'), '/datasets/ds_stage_coverage')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_stage_risk_Location_to_sections')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Target Stage Data Flows"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_stage_coverage",
								"type": "DatasetReference"
							},
							"name": "targetCoverage"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_coverage",
								"type": "DatasetReference"
							},
							"name": "stgCoverage"
						},
						{
							"dataset": {
								"referenceName": "ECMBPA_COV_MAP",
								"type": "DatasetReference"
							},
							"name": "srcCovergeBpaSectionMap"
						},
						{
							"dataset": {
								"referenceName": "ds_stage_risk",
								"type": "DatasetReference"
							},
							"name": "riskById"
						},
						{
							"dataset": {
								"referenceName": "targetSection",
								"type": "DatasetReference"
							},
							"name": "section"
						},
						{
							"dataset": {
								"referenceName": "ds_stage_location",
								"type": "DatasetReference"
							},
							"name": "targetLocation"
						},
						{
							"dataset": {
								"referenceName": "ds_stage_policy",
								"type": "DatasetReference"
							},
							"name": "source1"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "targetSection",
								"type": "DatasetReference"
							},
							"name": "sectionTarget"
						}
					],
					"transformations": [
						{
							"name": "lookup1"
						},
						{
							"name": "lookup2"
						},
						{
							"name": "splitCovCodeToIdentifyPartCov"
						},
						{
							"name": "derivedColumn2"
						},
						{
							"name": "aggregateRiskBySection"
						},
						{
							"name": "lookupForRiskId"
						},
						{
							"name": "riskJsonById"
						},
						{
							"name": "lookup4"
						},
						{
							"name": "replaceInsObjWithRiskJson"
						},
						{
							"name": "unescape"
						},
						{
							"name": "arrayStringCorrectionOpening"
						},
						{
							"name": "arrayStringCorrectionClosing"
						},
						{
							"name": "derivedColumn8"
						},
						{
							"name": "derivedColumn9"
						},
						{
							"name": "select1"
						},
						{
							"name": "onlyUpdateRiskJson"
						},
						{
							"name": "onlyMatchedRiskWithSection"
						},
						{
							"name": "riskByIdSelect"
						},
						{
							"name": "derivedColumn10"
						},
						{
							"name": "lookupByLocationId"
						},
						{
							"name": "locationDerived"
						},
						{
							"name": "derivedColumn11"
						},
						{
							"name": "filter1"
						},
						{
							"name": "derivedColumn12"
						},
						{
							"name": "onlyPolicy"
						},
						{
							"name": "filter2"
						},
						{
							"name": "join1"
						}
					],
					"scriptLines": [
						"parameters{",
						"     policyPrefix as string ('CFA')",
						"}",
						"source(output(",
						"          coverage_id as integer,",
						"          policy_id as integer,",
						"          json_data as string,",
						"          coverage_code as string,",
						"          risk_id as long,",
						"          location_id as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select * from coverage',",
						"     format: 'query') ~> targetCoverage",
						"source(output(",
						"          COVERAGE_ID as long,",
						"          COVERAGE_VID as long,",
						"          COVERAGE_CODE_ID as long,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          COV_STATE_ID as long,",
						"          COVERAGE_EFFECTIVE_DATE as timestamp,",
						"          COVERAGE_EXPIRATION_DATE as timestamp,",
						"          ASL_CODE as string,",
						"          ASSL_CODE as string,",
						"          ASL_CODE_GBL as string,",
						"          ASSL_CODE_GBL as string,",
						"          CLASSIFICATION_CODE_ID as long,",
						"          CLASSIFICATION_CODE_OVID as long,",
						"          COVERAGE_CODE as string,",
						"          RETROACTIVE_DATE as timestamp,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: '  select * from POL_COVERAGE ',",
						"     format: 'query') ~> stgCoverage",
						"source(output(",
						"          COV_SEQ as string,",
						"          BPA_SECTION_CODE as string,",
						"          COVERAGE_CODE as string,",
						"          COVERAGE_CODE_DES as string,",
						"          BPA_COVERAGE_CODES as string,",
						"          BPA_COVERAGES as string,",
						"          COVERAGES as string,",
						"          BPA_PRODUCT_CODE as string,",
						"          SI_NO as string,",
						"          id as long,",
						"          BPA_SEC_NAME as string,",
						"          SOURCE_PRODUCT_CODE as string,",
						"          bpa_coverage_group as string,",
						"          bpa_coverage_level as string,",
						"          bpa_coverage_type as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> srcCovergeBpaSectionMap",
						"source(output(",
						"          risk_id as integer,",
						"          policy_id as integer,",
						"          json_data as string,",
						"          location_id as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select * from risk ',",
						"     format: 'query') ~> riskById",
						"source(output(",
						"          section_id as integer,",
						"          policy_id as integer,",
						"          coverage_id as integer,",
						"          location_id as integer,",
						"          limit_id as integer,",
						"          deductible_id as integer,",
						"          insurableobject_id as integer,",
						"          json_data as string,",
						"          extendedattributes as string,",
						"          section_code as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select * from bpa_section ',",
						"     format: 'query') ~> section",
						"source(output(",
						"          location_id as integer,",
						"          policy_id as integer,",
						"          address_id as integer,",
						"          json_data as string,",
						"          extendedattributes as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> targetLocation",
						"source(output(",
						"          policy_id as integer,",
						"          policy_number as string,",
						"          json_data as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> source1",
						"targetCoverage, stgCoverage lookup(targetCoverage@coverage_id == stgCoverage@COVERAGE_ID,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lookup1",
						"splitCovCodeToIdentifyPartCov, derivedColumn2 lookup(CoverageCode == SRC_COVERAGE",
						"     && CoverageSeq == SRC_COVERAGE_SEQ,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lookup2",
						"join1 derive(CoverageCode = split(targetCoverage@coverage_code,'-')[4],",
						"          CoverageSeq = split(targetCoverage@coverage_code,'-')[5],",
						"          lob = split(targetCoverage@coverage_code,'-')[3]) ~> splitCovCodeToIdentifyPartCov",
						"srcCovergeBpaSectionMap derive(SRC_COVERAGE_SEQ = COV_SEQ,",
						"          SRC_COVERAGE = COVERAGE_CODE) ~> derivedColumn2",
						"filter1 aggregate(groupBy(targetCoverage@policy_id,",
						"          BPA_SECTION_CODE),",
						"     insurableObject = collect(riskJson),",
						"          location = collect(locationJson)) ~> aggregateRiskBySection",
						"lookup2, riskByIdSelect lookup(stgCoverage@POLICY_ID == riskByIdSelect@policy_id",
						"     && targetCoverage@risk_id === riskByIdSelect@risk_id,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lookupForRiskId",
						"riskById derive(riskJson = unescape(json_data,'json')) ~> riskJsonById",
						"derivedColumn10, section lookup(aggregateRiskBySection@policy_id == section@policy_id",
						"     && BPA_SECTION_CODE == section_code,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lookup4",
						"derivedColumn11 derive(json_data = replace(json_data,'\"insurableObject\":[]',concat('\"insurableObject\":',toString(insurableObject)))) ~> replaceInsObjWithRiskJson",
						"replaceInsObjWithRiskJson derive(json_data = unescape(json_data, 'json')) ~> unescape",
						"unescape derive(json_data = replace(json_data,'\"[','[')) ~> arrayStringCorrectionOpening",
						"arrayStringCorrectionOpening derive(json_data = replace(json_data,']\"',']')) ~> arrayStringCorrectionClosing",
						"arrayStringCorrectionClosing derive(json_data = replace(json_data,'\"{','{')) ~> derivedColumn8",
						"derivedColumn8 derive(json_data = replace(json_data,'}\"','}')) ~> derivedColumn9",
						"derivedColumn9 select(mapColumn(",
						"          section_id,",
						"          policy_id = section@policy_id,",
						"          coverage_id,",
						"          location_id,",
						"          limit_id,",
						"          deductible_id,",
						"          insurableobject_id,",
						"          json_data,",
						"          extendedattributes,",
						"          section_code",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"select1 alterRow(updateIf(!isNull(policy_id)&&!isNull(policy_id))) ~> onlyUpdateRiskJson",
						"lookup4 filter(!isNull(section_id)) ~> onlyMatchedRiskWithSection",
						"riskJsonById select(mapColumn(",
						"          risk_id,",
						"          policy_id,",
						"          location_id,",
						"          riskJson",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> riskByIdSelect",
						"aggregateRiskBySection derive(insurableObject = distinct(insurableObject),",
						"          location = distinct(location)) ~> derivedColumn10",
						"lookupForRiskId, locationDerived lookup(stgCoverage@POLICY_ID == targetLocation@policy_id",
						"     && targetCoverage@location_id == locationDerived@location_id,",
						"     multiple: false,",
						"     pickup: 'first',",
						"     asc(locationDerived@location_id, true),",
						"     broadcast: 'auto')~> lookupByLocationId",
						"targetLocation derive(location_id = location_id,",
						"          locationJson = json_data) ~> locationDerived",
						"onlyMatchedRiskWithSection derive(json_data = replace(json_data,'\"location\":[]',concat('\"location\":',toString(location)))) ~> derivedColumn11",
						"lookupByLocationId filter(BPA_SECTION_CODE != 'SEC000') ~> filter1",
						"source1 derive(targetPolicyID = policy_id,",
						"          policyPRefixTemp = substring(policy_number, 1, 3)) ~> derivedColumn12",
						"filter2 select(mapColumn(",
						"          policy_number,",
						"          targetPolicyID",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> onlyPolicy",
						"derivedColumn12 filter(policyPRefixTemp == $policyPrefix) ~> filter2",
						"lookup1, onlyPolicy join(stgCoverage@POLICY_ID == targetPolicyID,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"onlyUpdateRiskJson sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          section_id as integer,",
						"          policy_id as integer,",
						"          coverage_id as integer,",
						"          location_id as integer,",
						"          limit_id as integer,",
						"          deductible_id as integer,",
						"          insurableobject_id as integer,",
						"          json_data as string,",
						"          extendedattributes as string,",
						"          section_code as string",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:true,",
						"     keys:['policy_id','section_id','section_code'],",
						"     skipKeyWrites:true,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sectionTarget"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ds_stage_coverage')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_coverage')]",
				"[concat(variables('factoryId'), '/datasets/ECMBPA_COV_MAP')]",
				"[concat(variables('factoryId'), '/datasets/ds_stage_risk')]",
				"[concat(variables('factoryId'), '/datasets/targetSection')]",
				"[concat(variables('factoryId'), '/datasets/ds_stage_location')]",
				"[concat(variables('factoryId'), '/datasets/ds_stage_policy')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_stage_risk_details')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Target Stage Data Flows/emp"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "riskDetailsStaging"
						},
						{
							"dataset": {
								"referenceName": "ds_stage_risk",
								"type": "DatasetReference"
							},
							"name": "targetRisk"
						},
						{
							"dataset": {
								"referenceName": "ds_stage_horseDetailsLookup",
								"type": "DatasetReference"
							},
							"name": "horseDetailsLookup"
						},
						{
							"dataset": {
								"referenceName": "StgRefLookUp",
								"type": "DatasetReference"
							},
							"name": "sourceRefLookUp"
						},
						{
							"dataset": {
								"referenceName": "StgLookUpType",
								"type": "DatasetReference"
							},
							"name": "sourceRefLookUpType"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_stage_riskDetail",
								"type": "DatasetReference"
							},
							"name": "riskDetails",
							"rejectedDataLinkedService": {
								"referenceName": "AzureBlobStorage1",
								"type": "LinkedServiceReference"
							}
						}
					],
					"transformations": [
						{
							"name": "aggregate1"
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "surrogateKey1"
						},
						{
							"name": "select1"
						},
						{
							"name": "lookup1"
						},
						{
							"name": "filter1"
						},
						{
							"name": "select2"
						},
						{
							"name": "select3"
						},
						{
							"name": "join1"
						},
						{
							"name": "attributeNameLookup"
						},
						{
							"name": "codeDescriptionLookup"
						}
					],
					"scriptLines": [
						"source(output(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select  * from POL_RISK_DETAILS',",
						"     format: 'query') ~> riskDetailsStaging",
						"source(output(",
						"          risk_id as integer,",
						"          policy_id as integer,",
						"          json_data as string,",
						"          location_id as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> targetRisk",
						"source(output(",
						"          lookup_id as integer,",
						"          bpa_code as string,",
						"          bpa_code_desc as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> horseDetailsLookup",
						"source(output(",
						"          LOOKUP_ID as long,",
						"          LOOKUP_TYPE_ID as long,",
						"          LOOKUP_CODE as string,",
						"          LOOKUP_SHORT_DESCRIPTION as string,",
						"          LOOKUP_DESCRIPTION as string,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          DATA_HASH as binary,",
						"          SOURCE_KEY as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> sourceRefLookUp",
						"source(output(",
						"          LOOKUP_TYPE_ID as long,",
						"          LOOKUP_TYPE_DOMAIN as string,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          DATA_HASH as binary,",
						"          SOURCE_KEY as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> sourceRefLookUpType",
						"codeDescriptionLookup aggregate(groupBy(RISK_ID),",
						"     extAttributeList = collect(@(name=ATTRIBUTE_NAME,value=iif(in(['use', 'horseSex', 'horseBreed'], ATTRIBUTE_NAME), bpa_code, iif(length(ATTRIBUTE_VALUE)==0 || isNull(ATTRIBUTE_VALUE), \"\", trim(regexReplace(ATTRIBUTE_VALUE,'\"?\"','')) ))))) ~> aggregate1",
						"filter1 derive(json_data = toString(extAttributeList)) ~> derivedColumn1",
						"derivedColumn1 keyGenerate(output(riskDetail_id as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> surrogateKey1",
						"surrogateKey1 select(mapColumn(",
						"          risk_id = aggregate1@RISK_ID,",
						"          json_data,",
						"          risk_detail_id = riskDetail_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"aggregate1, targetRisk lookup(aggregate1@RISK_ID == targetRisk@risk_id,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lookup1",
						"lookup1 filter(!isNull(targetRisk@risk_id)) ~> filter1",
						"sourceRefLookUp select(mapColumn(",
						"          LOOKUP_ID,",
						"          LOOKUP_TYPE_ID,",
						"          LOOKUP_CODE,",
						"          LOOKUP_SHORT_DESCRIPTION,",
						"          LOOKUP_DESCRIPTION",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select2",
						"sourceRefLookUpType select(mapColumn(",
						"          LOOKUP_TYPE_ID,",
						"          LOOKUP_TYPE_DOMAIN",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select3",
						"select2, select3 join(select2@LOOKUP_TYPE_ID == select3@LOOKUP_TYPE_ID,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"riskDetailsStaging, join1 lookup(lower(ATTRIBUTE_NAME) == lower(LOOKUP_TYPE_DOMAIN)",
						"     && trim(ATTRIBUTE_VALUE) == trim(LOOKUP_CODE),",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> attributeNameLookup",
						"attributeNameLookup, horseDetailsLookup lookup(iif(isNull(LOOKUP_DESCRIPTION), '', lower(trim(LOOKUP_DESCRIPTION))) == iif(isNull(bpa_code_desc), '', lower(trim(bpa_code_desc))),",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> codeDescriptionLookup",
						"select1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          risk_detail_id as integer,",
						"          risk_id as integer,",
						"          policy_id as integer,",
						"          json_data as string,",
						"          extended_attributes as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> riskDetails"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_policyRiskDetails')]",
				"[concat(variables('factoryId'), '/datasets/ds_stage_risk')]",
				"[concat(variables('factoryId'), '/datasets/ds_stage_horseDetailsLookup')]",
				"[concat(variables('factoryId'), '/datasets/StgRefLookUp')]",
				"[concat(variables('factoryId'), '/datasets/StgLookUpType')]",
				"[concat(variables('factoryId'), '/datasets/ds_stage_riskDetail')]",
				"[concat(variables('factoryId'), '/linkedServices/AzureBlobStorage1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_stage_risk_details_cfa')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Target Stage Data Flows/cfa"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "riskDetailsStaging"
						},
						{
							"dataset": {
								"referenceName": "ds_stage_risk",
								"type": "DatasetReference"
							},
							"name": "targetRisk"
						},
						{
							"dataset": {
								"referenceName": "StgRefLookUp",
								"type": "DatasetReference"
							},
							"name": "sourceRefLookUp"
						},
						{
							"dataset": {
								"referenceName": "StgLookUpType",
								"type": "DatasetReference"
							},
							"name": "sourceRefLookUpType"
						},
						{
							"dataset": {
								"referenceName": "ds_stage_riskDetail",
								"type": "DatasetReference"
							},
							"name": "riskDetailMaxIdTarget"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_stage_riskDetail",
								"type": "DatasetReference"
							},
							"name": "riskDetails",
							"rejectedDataLinkedService": {
								"referenceName": "AzureBlobStorage1",
								"type": "LinkedServiceReference"
							}
						},
						{
							"name": "maxIdLookup"
						}
					],
					"transformations": [
						{
							"name": "aggregate1"
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "select1"
						},
						{
							"name": "lookup1"
						},
						{
							"name": "filter1"
						},
						{
							"name": "select2"
						},
						{
							"name": "select3"
						},
						{
							"name": "join1"
						},
						{
							"name": "attributeNameLookup"
						},
						{
							"name": "surrogateKey2"
						},
						{
							"name": "derivedColumn2"
						}
					],
					"scriptLines": [
						"source(output(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select  * from POL_RISK_DETAILS',",
						"     format: 'query') ~> riskDetailsStaging",
						"source(output(",
						"          risk_id as integer,",
						"          policy_id as integer,",
						"          json_data as string,",
						"          location_id as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> targetRisk",
						"source(output(",
						"          LOOKUP_ID as long,",
						"          LOOKUP_TYPE_ID as long,",
						"          LOOKUP_CODE as string,",
						"          LOOKUP_SHORT_DESCRIPTION as string,",
						"          LOOKUP_DESCRIPTION as string,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          DATA_HASH as binary,",
						"          SOURCE_KEY as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> sourceRefLookUp",
						"source(output(",
						"          LOOKUP_TYPE_ID as long,",
						"          LOOKUP_TYPE_DOMAIN as string,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          DATA_HASH as binary,",
						"          SOURCE_KEY as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> sourceRefLookUpType",
						"source(output(",
						"          maxid as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select MAX(risk_detail_id) as maxId from risk_detail',",
						"     format: 'query') ~> riskDetailMaxIdTarget",
						"attributeNameLookup aggregate(groupBy(RISK_ID),",
						"     extAttributeList = collect(@(name=ATTRIBUTE_NAME,value=iif(in(['use', 'vehicletypecode', 'radiusclass', 'vehiclesizeclass', 'businessuseclass', 'registeredstate_name'], lower(ATTRIBUTE_NAME)), LOOKUP_DESCRIPTION, iif(length(ATTRIBUTE_VALUE)==0 || isNull(ATTRIBUTE_VALUE), \"\", ATTRIBUTE_VALUE) )))) ~> aggregate1",
						"surrogateKey2 derive(json_data = toString(extAttributeList),",
						"          riskDetail_id = skey + maxIdLookup#outputs()[1].maxRiskDetailId) ~> derivedColumn1",
						"derivedColumn1 select(mapColumn(",
						"          risk_id = aggregate1@RISK_ID,",
						"          json_data,",
						"          risk_detail_id = riskDetail_id,",
						"          policy_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"aggregate1, targetRisk lookup(aggregate1@RISK_ID == targetRisk@risk_id,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lookup1",
						"lookup1 filter(!isNull(targetRisk@risk_id)) ~> filter1",
						"sourceRefLookUp select(mapColumn(",
						"          LOOKUP_ID,",
						"          LOOKUP_TYPE_ID,",
						"          LOOKUP_CODE,",
						"          LOOKUP_SHORT_DESCRIPTION,",
						"          LOOKUP_DESCRIPTION",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select2",
						"sourceRefLookUpType select(mapColumn(",
						"          LOOKUP_TYPE_ID,",
						"          LOOKUP_TYPE_DOMAIN",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select3",
						"select2, select3 join(select2@LOOKUP_TYPE_ID == select3@LOOKUP_TYPE_ID,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"riskDetailsStaging, join1 lookup(lower(ATTRIBUTE_NAME) == lower(LOOKUP_TYPE_DOMAIN)",
						"     && trim(ATTRIBUTE_VALUE) == trim(LOOKUP_CODE),",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> attributeNameLookup",
						"filter1 keyGenerate(output(skey as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> surrogateKey2",
						"riskDetailMaxIdTarget derive(maxRiskDetailId = iifNull(maxid, 0, maxid)) ~> derivedColumn2",
						"select1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          risk_detail_id as integer,",
						"          risk_id as integer,",
						"          policy_id as integer,",
						"          json_data as string,",
						"          extended_attributes as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> riskDetails",
						"derivedColumn2 sink(validateSchema: false,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     store: 'cache',",
						"     format: 'inline',",
						"     output: false,",
						"     saveOrder: 1) ~> maxIdLookup"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_policyRiskDetails')]",
				"[concat(variables('factoryId'), '/datasets/ds_stage_risk')]",
				"[concat(variables('factoryId'), '/datasets/StgRefLookUp')]",
				"[concat(variables('factoryId'), '/datasets/StgLookUpType')]",
				"[concat(variables('factoryId'), '/datasets/ds_stage_riskDetail')]",
				"[concat(variables('factoryId'), '/linkedServices/AzureBlobStorage1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_stage_section')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Target Stage Data Flows"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_coverage",
								"type": "DatasetReference"
							},
							"name": "SScoverages"
						},
						{
							"dataset": {
								"referenceName": "ECMBPA_COV_MAP",
								"type": "DatasetReference"
							},
							"name": "EcmBPACovMap"
						},
						{
							"dataset": {
								"referenceName": "ds_stage_coverage",
								"type": "DatasetReference"
							},
							"name": "targetCoverage"
						},
						{
							"dataset": {
								"referenceName": "ds_stage_policy",
								"type": "DatasetReference"
							},
							"name": "targetPolicy"
						},
						{
							"dataset": {
								"referenceName": "targetSection",
								"type": "DatasetReference"
							},
							"name": "source2"
						},
						{
							"dataset": {
								"referenceName": "ds_stage_policy",
								"type": "DatasetReference"
							},
							"name": "targetPolicyCopy"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policy",
								"type": "DatasetReference"
							},
							"name": "sourceStgPolicy"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "targetSection",
								"type": "DatasetReference"
							},
							"name": "targetSection"
						},
						{
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "derivedColumn1"
						},
						{
							"name": "derivedMap"
						},
						{
							"name": "onlymatchedCoverages"
						},
						{
							"name": "aggregateByPolivyIdByBPASecCode"
						},
						{
							"name": "derivedColumn2"
						},
						{
							"name": "reaplceCoverages"
						},
						{
							"name": "surrogateKey1"
						},
						{
							"name": "targetCoverageDerived"
						},
						{
							"name": "joinToSrcCoverageTemplate"
						},
						{
							"name": "derivedColumn3"
						},
						{
							"name": "join1"
						},
						{
							"name": "join2"
						},
						{
							"name": "derivedColumn4"
						},
						{
							"name": "filteredCov"
						},
						{
							"name": "filter1"
						},
						{
							"name": "join3"
						},
						{
							"name": "joinPolicy"
						},
						{
							"name": "derivedColumn6"
						},
						{
							"name": "split1"
						},
						{
							"name": "join4"
						},
						{
							"name": "filter2"
						},
						{
							"name": "derivedColumn7"
						},
						{
							"name": "aggregate1"
						},
						{
							"name": "derivedColumn8"
						},
						{
							"name": "union1"
						},
						{
							"name": "aggregate2"
						},
						{
							"name": "derivedColumn9"
						}
					],
					"scriptLines": [
						"parameters{",
						"     policyPrefix as string ('EMP')",
						"}",
						"source(output(",
						"          POLICY_ID as long,",
						"          COVERAGE_ID as long,",
						"          COVERAGE_CODE as string,",
						"          RISK_ID as long,",
						"          LOCATION_ID as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: ' select  pc.POLICY_ID,pc.COVERAGE_ID,pc.COVERAGE_CODE,ptl.RISK_ID,ptl.LOCATION_ID  from POL_COVERAGE pc join POL_TX_LIMIT_DED_OPT ptl on ptl.COVERAGE_ID=pc.COVERAGE_ID ',",
						"     format: 'query') ~> SScoverages",
						"source(output(",
						"          COV_SEQ as string,",
						"          BPA_SECTION_CODE as string,",
						"          COVERAGE_CODE as string,",
						"          COVERAGE_CODE_DES as string,",
						"          BPA_COVERAGE_CODES as string,",
						"          BPA_COVERAGES as string,",
						"          COVERAGES as string,",
						"          BPA_PRODUCT_CODE as string,",
						"          SI_NO as string,",
						"          id as long,",
						"          BPA_SEC_NAME as string,",
						"          SOURCE_PRODUCT_CODE as string,",
						"          bpa_coverage_group as string,",
						"          bpa_coverage_level as string,",
						"          bpa_coverage_type as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> EcmBPACovMap",
						"source(output(",
						"          coverage_id as integer,",
						"          policy_id as integer,",
						"          json_data as string,",
						"          coverage_code as string,",
						"          risk_id as long,",
						"          location_id as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select * from coverage ',",
						"     format: 'query') ~> targetCoverage",
						"source(output(",
						"          policy_id as integer,",
						"          policy_number as string,",
						"          json_data as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select * from policy',",
						"     format: 'query') ~> targetPolicy",
						"source(output(",
						"          section_id as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select coalesce(MAX(section_id),0) as section_id from bpa_section',",
						"     format: 'query') ~> source2",
						"source(output(",
						"          policy_id as integer,",
						"          policy_number as string,",
						"          json_data as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select * from policy ',",
						"     format: 'query') ~> targetPolicyCopy",
						"source(output(",
						"          POLICY_ID as long,",
						"          POLICY_VID as long,",
						"          REINSURANCE_DAC as string,",
						"          PREVIOUS_INSURANCE_NO_REMARKS as string,",
						"          AGENCY_ID as long,",
						"          AGENCY_OVID as long,",
						"          PRODUCER_ID as long,",
						"          PRODUCER_OVID as long,",
						"          PRODUCER_CONTACT_ID as long,",
						"          PRODUCER_CONTACT_OVID as long,",
						"          POLICY_NUMBER as string,",
						"          ENTITY_TYPE as string,",
						"          ENTITY_STATUS as string,",
						"          IS_RENEWAL_YN as string,",
						"          REVISION_NUMBER as integer,",
						"          PRODUCT_ID as long,",
						"          PRODUCT_OVID as long,",
						"          POLICY_EFFECTIVE_DATE as timestamp,",
						"          POLICY_EXPIRATION_DATE as timestamp,",
						"          NON_RENEWAL_CODE as string,",
						"          POLICY_RENEWED_YN as string,",
						"          CANCELLATION_DATE as timestamp,",
						"          IS_RENEWABLE_YN as string,",
						"          PREVIOUS_INSURANCE_NO_REASON as string,",
						"          POLICY_STATUS as string,",
						"          CANCEL_REASON_CODE as string,",
						"          CANCEL_REASON_DESCRIPTION as string,",
						"          CANCEL_METHOD as string,",
						"          CANCEL_METHOD_DESC as string,",
						"          LOSE_REASON_CODE as string,",
						"          LOSE_REASON_DESC as string,",
						"          DECLINATION_REASON_CODE as string,",
						"          DECLINATION_REASON_DESC as string,",
						"          NOT_WRITTEN_REASON_CODE as string,",
						"          NOT_WRITTEN_REASON_DESC as string,",
						"          POLICY_STATE_CODE as string,",
						"          PROGRAM_ID as long,",
						"          PROGRAM_OVID as long,",
						"          BILLING_TYPE_CODE as string,",
						"          UNDERWRITING_COMPANY_ID as long,",
						"          UNDERWRITING_COMPANY_OVID as long,",
						"          SUBMISSION_ID as long,",
						"          PREVIOUS_INSURANCE_YN as string,",
						"          LEGACY_POLICY_NUMBER as string,",
						"          STATE as string,",
						"          POLICY_POLICY as integer,",
						"          PAYMENT_PLAN as string,",
						"          APPLICATION_RECEIVED_DATE as timestamp,",
						"          INCEPTION_DATE as timestamp,",
						"          BILL_TYPE as string,",
						"          FORMS_LANGUAGE as string,",
						"          BASE_CURRENCY as string,",
						"          INVOICE_CURRENCY as string,",
						"          PREVIOUS_POLICY_ID as long,",
						"          PREVIOUS_POLICY_OVID as long,",
						"          REVISED_FROM_POLICY_ID as long,",
						"          REVISED_FROM_POLICY_OVID as long,",
						"          OPERATING_COMPANY_ID as long,",
						"          OPERATING_COMPANY_OVID as long,",
						"          CONVERTED_FROM_ID as long,",
						"          CONVERTED_FROM_OVID as long,",
						"          INSTALLMENT_RENEWAL as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select * from pol_policy ',",
						"     format: 'query') ~> sourceStgPolicy",
						"SScoverages derive(lob = case(split(COVERAGE_CODE,'-')[3] == '091','CFA',split(COVERAGE_CODE,'-')[3] == '087','EMP'),",
						"          srcCoverageGrCode = split(COVERAGE_CODE,'-')[4],",
						"          srcCoverageSeq = split(COVERAGE_CODE,'-')[5],",
						"          productCode = $policyPrefix) ~> derivedColumn1",
						"EcmBPACovMap derive(COVERAGE_CODE = COVERAGE_CODE) ~> derivedMap",
						"join3 filter(!isNull(COV_SEQ)) ~> onlymatchedCoverages",
						"derivedColumn2 aggregate(groupBy(policy_id = targetPolicy_id,",
						"          BPA_SECTION_CODE),",
						"     coverage = collect(coverageJson)) ~> aggregateByPolivyIdByBPASecCode",
						"filter1 derive(lineOfBusinessCode = case(lob=='CFA','CAUT',",
						"     lob=='EMP','EQMR'),",
						"          coverTypeCode = BPA_SECTION_CODE) ~> derivedColumn2",
						"surrogateKey1 derive(policy_id = policy_id,",
						"          json_data = toString(@(lineOfBusinessCode='EQMR',",
						"          coverTypeCode=BPA_SECTION_CODE,",
						"          coverage=coverage,",
						"          insurableObject=array(),",
						"          location=array()",
						"          )),",
						"          section_code = BPA_SECTION_CODE,",
						"          section_id = sink1#outputs()[1].section_id + pkey) ~> reaplceCoverages",
						"derivedColumn9 keyGenerate(output(pkey as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> surrogateKey1",
						"targetCoverage derive(json_data = unescape(json_data, 'json'),",
						"          targetPolicyID = policy_id) ~> targetCoverageDerived",
						"derivedColumn1, derivedMap join(lob == BPA_PRODUCT_CODE",
						"     && srcCoverageGrCode == derivedMap@COVERAGE_CODE",
						"     && srcCoverageSeq == COV_SEQ,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinToSrcCoverageTemplate",
						"aggregateByPolivyIdByBPASecCode derive(coverage = distinct(coverage)) ~> derivedColumn3",
						"split1@unitLevelaggregation, filteredCov join(targetPolicy_id == targetPolicy@policy_id",
						"     && split1@unitLevelaggregation@COVERAGE_ID == targetCoverage@coverage_id",
						"     && split1@unitLevelaggregation@RISK_ID == targetCoverage@risk_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"targetCoverageDerived, targetPolicy join(targetCoverage@policy_id == targetPolicy@policy_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join2",
						"join2 derive(policyPrefixTemp = substring(policy_number,1, 3),",
						"          coverageJson = targetCoverageDerived@json_data) ~> derivedColumn4",
						"derivedColumn4 filter(policyPrefixTemp == $policyPrefix) ~> filteredCov",
						"join1 filter(lob == $policyPrefix && !isNull(targetPolicyID)) ~> filter1",
						"joinToSrcCoverageTemplate, joinPolicy join(SScoverages@POLICY_ID == targetPolicyCopy@policy_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join3",
						"derivedColumn6, sourceStgPolicy join(targetPolicyCopy@policy_number == sourceStgPolicy@POLICY_NUMBER,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinPolicy",
						"targetPolicyCopy derive(targetPolicy_id = policy_id) ~> derivedColumn6",
						"onlymatchedCoverages split(!isNull(RISK_ID),",
						"     disjoint: false) ~> split1@(unitLevelaggregation, policyLevelaggregation)",
						"split1@policyLevelaggregation, filteredCov join(targetPolicy_id == targetCoverage@policy_id",
						"     && split1@policyLevelaggregation@COVERAGE_ID == targetCoverage@coverage_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join4",
						"join4 filter(lob == $policyPrefix && !isNull(targetPolicyID)) ~> filter2",
						"filter2 derive(lineOfBusinessCode = case(lob=='CFA','CAUT',     lob=='EMP','EQMR'),",
						"          coverTypeCode = BPA_SECTION_CODE) ~> derivedColumn7",
						"derivedColumn7 aggregate(groupBy(targetPolicy_id,",
						"          BPA_SECTION_CODE),",
						"     coverage = collect(coverageJson)) ~> aggregate1",
						"aggregate1 derive(coverage = distinct(coverage),",
						"          policy_id = targetPolicy_id) ~> derivedColumn8",
						"derivedColumn3, derivedColumn8 union(byName: true)~> union1",
						"union1 aggregate(groupBy(policy_id,",
						"          BPA_SECTION_CODE),",
						"     coverage = collect(coverage)) ~> aggregate2",
						"aggregate2 derive(coverage = flatten(coverage)) ~> derivedColumn9",
						"reaplceCoverages sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          section_id as integer,",
						"          policy_id as integer,",
						"          coverage_id as integer,",
						"          location_id as integer,",
						"          limit_id as integer,",
						"          deductible_id as integer,",
						"          insurableobject_id as integer,",
						"          json_data as string,",
						"          extendedattributes as string,",
						"          section_code as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> targetSection",
						"source2 sink(validateSchema: false,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     store: 'cache',",
						"     format: 'inline',",
						"     output: false,",
						"     saveOrder: 1) ~> sink1"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_coverage')]",
				"[concat(variables('factoryId'), '/datasets/ECMBPA_COV_MAP')]",
				"[concat(variables('factoryId'), '/datasets/ds_stage_coverage')]",
				"[concat(variables('factoryId'), '/datasets/ds_stage_policy')]",
				"[concat(variables('factoryId'), '/datasets/targetSection')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_policy')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_target_premiumComparison_policy')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "utility"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_target_quoteInfo",
								"type": "DatasetReference"
							},
							"name": "targetQuoteInfo"
						},
						{
							"dataset": {
								"referenceName": "ds_source_Fact_Coverage_Premium",
								"type": "DatasetReference"
							},
							"name": "sourcePremium"
						},
						{
							"dataset": {
								"referenceName": "ECMBPA_COV_MAP",
								"type": "DatasetReference"
							},
							"name": "coverageSectionLookup"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_target_rater_report",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "parse1"
						},
						{
							"name": "select1"
						},
						{
							"name": "flatten1"
						},
						{
							"name": "select2"
						},
						{
							"name": "select3"
						},
						{
							"name": "filter1"
						},
						{
							"name": "coveragePremiumLookup"
						},
						{
							"name": "derivedColumn2"
						},
						{
							"name": "select4"
						},
						{
							"name": "lookup1"
						},
						{
							"name": "select5"
						},
						{
							"name": "MapDrifted1",
							"description": "Creates an explicit mapping for each drifted column"
						},
						{
							"name": "derivedColumn4"
						},
						{
							"name": "MapDrifted2",
							"description": "Creates an explicit mapping for each drifted column"
						},
						{
							"name": "filter2"
						}
					],
					"scriptLines": [
						"parameters{",
						"     policyPrefix as string,",
						"     policies as string[]",
						"}",
						"source(output(",
						"          policy_number as string,",
						"          policy_id as integer,",
						"          policy_reference as string,",
						"          quote_number as string,",
						"          quote as string,",
						"          status as string,",
						"          response as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from quote_info where status='success' \"+iif(size($policies) >0&& size($policies) ==1&&$policies[1] =='','','and policy_number in ('+dropLeft(toString(reduce($policies, \"'\", #acc + \",'\" + #item +\"'\", #result)), 2)+')')),",
						"     format: 'query') ~> targetQuoteInfo",
						"source(output(",
						"          Policy as string,",
						"          Policy_Sequence as string,",
						"          PolicyPrefix as string,",
						"          ARICLOB as string,",
						"          ARICGroupCode as string,",
						"          Description as string,",
						"          Product as string,",
						"          ARICCoverageCode as string,",
						"          ARICCoverageDescription as string,",
						"          PrimaryPremiumStateCode as string,",
						"          LocationNumber as string,",
						"          LocationUnitNumber as string,",
						"          ARICCoverageSequence as string,",
						"          CoveragePart as string,",
						"          CoverageAddDate as timestamp,",
						"          CoverageDescription as string,",
						"          Limit1 as decimal(38,0),",
						"          Limit2 as decimal(38,0),",
						"          PremiumAmount as decimal(38,2)",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from Fact_Coverage_Premium where PolicyPrefix = '{$policyPrefix}'\"+iif(size($policies) >0&& size($policies) ==1&&$policies[1] =='','','and policy in ('+dropLeft(toString(reduce($policies, \"'\", #acc + \",'\" + #item +\"'\", #result)), 2)+')')),",
						"     format: 'query') ~> sourcePremium",
						"source(output(",
						"          COV_SEQ as string,",
						"          BPA_SECTION_CODE as string,",
						"          COVERAGE_CODE as string,",
						"          COVERAGE_CODE_DES as string,",
						"          BPA_COVERAGE_CODES as string,",
						"          BPA_COVERAGES as string,",
						"          COVERAGES as string,",
						"          BPA_PRODUCT_CODE as string,",
						"          SI_NO as string,",
						"          id as long,",
						"          BPA_SEC_NAME as string,",
						"          SOURCE_PRODUCT_CODE as string,",
						"          bpa_coverage_group as string,",
						"          bpa_coverage_level as string,",
						"          bpa_coverage_type as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> coverageSectionLookup",
						"targetQuoteInfo parse(quote_json = response ? (agent as (agencyCode as string,",
						"          agencyTier as string,",
						"          agencyType as string,",
						"          id as string,",
						"          isCancelled as string,",
						"          maintenanceAgency as string,",
						"          number as string,",
						"          parentEntityId as string,",
						"          parentEntityTypeName as string,",
						"          partyCode as string,",
						"          partyIdentifiers as string[],",
						"          partyName as string,",
						"          typeCode as string),",
						"          amountItem as (appliesToCode as string, currencyCode as string, description as string, editableOnTransaction as string, isAggregate as string, isMtaImpacted as string, isRefundable as string, levelCode as string, maxValue as string, minValue as string, originalAmount as string, pricedAmount as string, pricedValue as string, sequenceNumber as string, subTypeCode as string, typeCode as string, value as string, valueType as string)[],",
						"          businessPurposeType as string,",
						"          businessPurposeTypeCode as string,",
						"          carrierProcessingType as string,",
						"          claim as string[],",
						"          clientParticipant as (effectiveDate as string, expirationDate as string, extendedAttributes as (name as string)[], id as string, isCancelled as string, originalPartyName as string, parentEntityId as string, parentEntityTypeName as string, partyCode as string, partyName as string, professionalRole as string, questionAnswer as string[], roleCode as string, subRoleCode as string)[],",
						"          companyProductCode as string,",
						"          coverage as string[],",
						"          coverageGroup as string[],",
						"          createdBy as string,",
						"          createdDate as string,",
						"          currencyCode as string,",
						"          desiredEffectiveDate as string,",
						"          endorsement as (amountItem as (appliesToCode as string, currencyCode as string, editableOnTransaction as string, levelCode as string, originalAmount as string, pricedAmount as string, typeCode as string, valueType as string), clauses as string[], coverageCode as string, editionNumber as string, effectiveDate as string, endorsedPolicyReference as string, endorsementCode as string, endorsementNumber as string, endorsementType as string, expirationDate as string, extendedAttributes as string[], formCode as string, id as string, insurableObjectId as string, isCancelled as string, questionAnswer as string[], reasonCodes as string[], sectionCode as string, sourcePolicyReference as string)[],",
						"          extendedAttributes as (name as string, value as string)[],",
						"          firmRatingTrackingNumber as string,",
						"          forms as string[],",
						"          groupCode as string,",
						"          id as string,",
						"          initialRequestDate as string,",
						"          iterationNumber as string,",
						"          lineofBusinessCode as string,",
						"          location as string[],",
						"          majorVersion as string,",
						"          mgaParticipant as string[],",
						"          minorVersion as string,",
						"          operatingCompanyCode as string,",
						"          originalBusinessPurposeType as string,",
						"          originalBusinessPurposeTypeCode as string,",
						"          parentEntityId as string,",
						"          parentEntityTypeName as string,",
						"          policyEffectiveDate as string,",
						"          policyExpirationDate as string,",
						"          policyStage as string,",
						"          policyStatus as string,",
						"          policyStatusCodeDisplayName as string,",
						"          policyTerm as string,",
						"          preparedDate as string,",
						"          priorPolicy as string[],",
						"          productVersion as string,",
						"          questionAnswer as (answerCode as string, extendedAttributes as string[], id as string, isCancelled as string, parentEntityId as string, parentEntityTypeName as string, questionCode as string, questionText as string, value as string)[],",
						"          quoteNumber as string,",
						"          ratedIndicator as string,",
						"          reasons as string[],",
						"          referenceNumber as string,",
						"          sanctionCheckInfo as string[],",
						"          section as (amountItem as (appliesToCode as string, currencyCode as string, description as string, editableOnTransaction as string, isAggregate as string, isMtaImpacted as string, isRefundable as string, levelCode as string, maxValue as string, minValue as string, originalAmount as string, pricedAmount as string, pricedValue as string, sequenceNumber as string, subTypeCode as string, typeCode as string, value as string, valueType as string)[], carrierParticipant as string[], commissionAmountBasis as string, coverTypeCode as string, coverage as (amountItem as string[], appliesToCode as string, appliesToLevel as string, deductible as (currencyCode as string, id as string, name as string, parentEntityId as string, parentEntityTypeName as string, sequenceNumber as string, typeCode as string, value as string, valueType as string)[], effectiveDate as string, expirationDate as string, extendedAttributes as string[], fullPremium as string, id as string, isCancelled as string, limit as (currencyCode as string, id as string, name as string, parentEntityId as string, parentEntityTypeName as string, sequenceNumber as string, typeCode as string, value as string, valueType as string)[], option as string[], parentEntityId as string, parentEntityTypeName as string, sequenceNumber as string, tax as string[], typeCode as string)[], coverageGroup as string[], declinedIndicator as string, effectiveDate as string, expirationDate as string, extendedAttributes as string[], feeAmountBasis as string, id as string, insurableObject as (businessKey as string, extendedAttributes as (name as string, value as string)[], id as string, isCancelled as string, parentEntityId as string, parentEntityTypeName as string, sequenceNumber as string, typeCode as string)[], insurableObjectParticipant as (effectiveDate as string, expirationDate as string, extendedAttributes as string[], id as string, insurableObjectId as string, isCancelled as string, parentEntityId as string, parentEntityTypeName as string)[], isCancelled as string, isSharedCarrier as string, lineOfBusinessCode as string, location as string[], mappedLocations as string[], parentEntityId as string, parentEntityTypeName as string, premiumAmountBasis as string, pricedIndicator as string, pricingFactor as string[], primaryRatingState as string, questionAnswer as (answerCode as string, appliesToCode as string, extendedAttributes as string[], id as string, isCancelled as string, parentEntityId as string, parentEntityTypeName as string, questionCode as string, questionText as string, value as string)[], sectionItem as string[], sequenceNumber as string, subjectivity as string[], tax as string[], taxAmountBasis as string, taxJurisdiction as string[], triaRate as string, underwritingYear as string)[],",
						"          sectionWiseLocationAllocation as string,",
						"          sequenceNumber as string,",
						"          statusCode as string,",
						"          statusCodeDisplayName as string,",
						"          submissionCreatedBy as string,",
						"          submissionCreationDate as string,",
						"          tax as string[],",
						"          trackingNumber as string,",
						"          typeCode as string,",
						"          underlyingPolicies as string[],",
						"          underwriterDecisionInfo as string[],",
						"          validUntilDate as string),",
						"     format: 'json',",
						"     documentForm: 'singleDocument') ~> parse1",
						"parse1 select(mapColumn(",
						"          policy_number,",
						"          policy_id,",
						"          policy_reference,",
						"          quote_number,",
						"          sections = quote_json.section,",
						"          policy_reference",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"select1 foldDown(unrollMultiple(sections,sections.amountItem,every(match(name=='coverage'))),",
						"     mapColumn(",
						"          policy_number,",
						"          coverage = sections.coverage,",
						"          sectionCode = sections.coverTypeCode,",
						"          premiumLevelCode = sections.amountItem.levelCode,",
						"          premiumTypeCode = sections.amountItem.typeCode,",
						"          premiumAppliesToCode = sections.amountItem.appliesToCode,",
						"          premiumAmount = sections.amountItem.originalAmount,",
						"          stage_policy_number = policy_id,",
						"          policy_reference",
						"     ),",
						"     skipDuplicateMapInputs: false,",
						"     skipDuplicateMapOutputs: false) ~> flatten1",
						"derivedColumn4 select(mapColumn(",
						"          policy_number,",
						"          sectionCode,",
						"          premiumLevelCode,",
						"          premiumTypeCode,",
						"          premiumAppliesToCode,",
						"          targetPremiumAmount = premiumAmount,",
						"          stage_policy_number,",
						"          transaction_type,",
						"          target_coverage_code,",
						"          product_code,",
						"          policy_reference",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select2",
						"sourcePremium select(mapColumn(",
						"          Policy,",
						"          PolicyPrefix,",
						"          Description,",
						"          ARICCoverageCode,",
						"          ARICCoverageDescription,",
						"          LocationNumber,",
						"          LocationUnitNumber,",
						"          ARICCoverageSequence,",
						"          CoverageDescription,",
						"          Limit1,",
						"          Limit2,",
						"          SourcePremiumAmount = PremiumAmount",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select3",
						"select2 filter(premiumLevelCode == 'policy' && premiumTypeCode == 'tack_premium' && sectionCode == 'SEC000') ~> filter1",
						"select3, filter2 join(ARICCoverageCode == COVERAGE_CODE",
						"     && ARICCoverageSequence == COV_SEQ,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> coveragePremiumLookup",
						"coveragePremiumLookup derive(source_risk_id = LocationNumber+'-'+LocationUnitNumber,",
						"          source_coverage_code = toString(ARICCoverageCode)+'-'+toString(ARICCoverageSequence)) ~> derivedColumn2",
						"derivedColumn2 select(mapColumn(",
						"          source_policy_number = Policy,",
						"          Description,",
						"          ARICCoverageDescription,",
						"          CoverageDescription,",
						"          ARICCoverageCode,",
						"          ARICCoverageSequence,",
						"          LocationNumber,",
						"          LocationUnitNumber,",
						"          SourcePremiumAmount,",
						"          COVERAGE_NAME = COVERAGES,",
						"          BPA_COVERAGES,",
						"          BPA_SEC_NAME,",
						"          BPA_SECTION_CODE,",
						"          BPA_COVERAGE_CODES,",
						"          source_coverage_code",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select4",
						"filter1, select4 lookup(policy_number == source_policy_number",
						"     && sectionCode == BPA_SECTION_CODE,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lookup1",
						"MapDrifted2 select(mapColumn(",
						"          target_section = sectionCode,",
						"          premiumLevelCode,",
						"          premiumTypeCode,",
						"          target_premium = targetPremiumAmount,",
						"          target_coverage_code,",
						"          source_policy_number,",
						"          Description,",
						"          ARICCoverageDescription,",
						"          source_coverage_name = CoverageDescription,",
						"          ARICCoverageCode,",
						"          ARICCoverageSequence,",
						"          LocationNumber,",
						"          LocationUnitNumber,",
						"          source_premium = SourcePremiumAmount,",
						"          COVERAGE_NAME,",
						"          target_coverage_name = BPA_COVERAGES,",
						"          target_section_name = BPA_SEC_NAME,",
						"          BPA_SECTION_CODE,",
						"          BPA_COVERAGE_CODES,",
						"          target_coverage_code,",
						"          stage_policy_number,",
						"          product_code,",
						"          transaction_type,",
						"          source_coverage_code,",
						"          target_policy_number = policy_reference",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select5",
						"flatten1 derive(coverage = coverage,",
						"          sectionCode = toString(byName('sectionCode')),",
						"          premiumLevelCode = toString(byName('premiumLevelCode')),",
						"          premiumTypeCode = toString(byName('premiumTypeCode')),",
						"          premiumAppliesToCode = toString(byName('premiumAppliesToCode')),",
						"          premiumAmount = toString(byName('premiumAmount'))) ~> MapDrifted1",
						"MapDrifted1 derive(target_coverage_code = coverage[1].typeCode,",
						"          transaction_type = 'premium',",
						"          product_code = $policyPrefix) ~> derivedColumn4",
						"lookup1 derive({ageInYears } = trim(toString(byName('ageInYears '))),",
						"          {horseBreed } = trim(toString(byName('horseBreed '))),",
						"          {horseName } = trim(toString(byName('horseName '))),",
						"          {horseSex } = trim(toString(byName('horseSex '))),",
						"          {purchaseDate } = trim(toString(byName('purchaseDate '))),",
						"          {purchasePrice } = trim(toString(byName('purchasePrice '))),",
						"          {requestedLimit } = trim(toString(byName('requestedLimit '))),",
						"          {use } = trim(toString(byName('use '))),",
						"          {yearBorn } = trim(toString(byName('yearBorn ')))) ~> MapDrifted2",
						"coverageSectionLookup filter(bpa_coverage_level == 'P' && BPA_PRODUCT_CODE == $policyPrefix) ~> filter2",
						"select5 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          source_policy_number as string,",
						"          stage_policy_number as string,",
						"          target_policy_number as string,",
						"          transaction_type as string,",
						"          source_coverage_code as string,",
						"          target_coverage_code as string,",
						"          source_insurable_object as string,",
						"          target_insurable_object as string,",
						"          target_section as string,",
						"          source_premium as string,",
						"          target_premium as string,",
						"          batch_id as integer,",
						"          bpa_tenant_id as string,",
						"          product_code as string,",
						"          created_at as timestamp,",
						"          updated_at as timestamp,",
						"          horse_breed as string,",
						"          horse_sex as string,",
						"          use as string,",
						"          age_in_years as string,",
						"          year_born as string,",
						"          purchase_date as string,",
						"          purchase_price as string,",
						"          requested_limit as string,",
						"          location_state as string,",
						"          target_section_name as string,",
						"          target_coverage_name as string,",
						"          source_coverage_name as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink1"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ds_target_quoteInfo')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_Fact_Coverage_Premium')]",
				"[concat(variables('factoryId'), '/datasets/ECMBPA_COV_MAP')]",
				"[concat(variables('factoryId'), '/datasets/ds_target_rater_report')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_target_premiumComparison_risk')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "utility"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_target_quoteInfo",
								"type": "DatasetReference"
							},
							"name": "targetQuoteInfo"
						},
						{
							"dataset": {
								"referenceName": "ds_source_Fact_Coverage_Premium",
								"type": "DatasetReference"
							},
							"name": "sourcePremium"
						},
						{
							"dataset": {
								"referenceName": "ECMBPA_COV_MAP",
								"type": "DatasetReference"
							},
							"name": "coverageSectionLookup"
						},
						{
							"dataset": {
								"referenceName": "joinTableStageSQL",
								"type": "DatasetReference"
							},
							"name": "stagingPolicyRisk"
						},
						{
							"dataset": {
								"referenceName": "joinTableStageSQL",
								"type": "DatasetReference"
							},
							"name": "stageRiskDetails"
						},
						{
							"dataset": {
								"referenceName": "joinTableSourceSQL",
								"type": "DatasetReference"
							},
							"name": "sourceLocation"
						},
						{
							"dataset": {
								"referenceName": "StgRefLookUp",
								"type": "DatasetReference"
							},
							"name": "horseLookup"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_target_rater_report",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "parse1"
						},
						{
							"name": "select1"
						},
						{
							"name": "flatten1"
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "select2"
						},
						{
							"name": "select3"
						},
						{
							"name": "filter1"
						},
						{
							"name": "coveragePremiumLookup"
						},
						{
							"name": "derivedColumn2"
						},
						{
							"name": "join1"
						},
						{
							"name": "select4"
						},
						{
							"name": "lookup1"
						},
						{
							"name": "select5"
						},
						{
							"name": "MapDrifted1",
							"description": "Creates an explicit mapping for each drifted column"
						},
						{
							"name": "derivedColumn4"
						},
						{
							"name": "pivot1"
						},
						{
							"name": "lookup2"
						},
						{
							"name": "MapDrifted2",
							"description": "Creates an explicit mapping for each drifted column"
						},
						{
							"name": "lookup3"
						},
						{
							"name": "lookup4"
						},
						{
							"name": "derivedColumn5"
						},
						{
							"name": "filter2"
						}
					],
					"scriptLines": [
						"parameters{",
						"     policyPrefix as string,",
						"     policies as string[]",
						"}",
						"source(output(",
						"          policy_number as string,",
						"          policy_id as integer,",
						"          policy_reference as string,",
						"          quote_number as string,",
						"          quote as string,",
						"          status as string,",
						"          response as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from quote_info where status='success' \"+iif(size($policies) >0&& size($policies) ==1&&$policies[1] =='','','and policy_number in ('+dropLeft(toString(reduce($policies, \"'\", #acc + \",'\" + #item +\"'\", #result)), 2)+')')),",
						"     format: 'query') ~> targetQuoteInfo",
						"source(output(",
						"          Policy as string,",
						"          Policy_Sequence as string,",
						"          PolicyPrefix as string,",
						"          ARICLOB as string,",
						"          ARICGroupCode as string,",
						"          Description as string,",
						"          Product as string,",
						"          ARICCoverageCode as string,",
						"          ARICCoverageDescription as string,",
						"          PrimaryPremiumStateCode as string,",
						"          LocationNumber as string,",
						"          LocationUnitNumber as string,",
						"          ARICCoverageSequence as string,",
						"          CoveragePart as string,",
						"          CoverageAddDate as timestamp,",
						"          CoverageDescription as string,",
						"          Limit1 as decimal(38,0),",
						"          Limit2 as decimal(38,0),",
						"          PremiumAmount as decimal(38,2)",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from Fact_Coverage_Premium where PolicyPrefix = '{$policyPrefix}'\"+iif(size($policies) >0&& size($policies) ==1&&$policies[1] =='','','and policy in ('+dropLeft(toString(reduce($policies, \"'\", #acc + \",'\" + #item +\"'\", #result)), 2)+')')),",
						"     format: 'query') ~> sourcePremium",
						"source(output(",
						"          COV_SEQ as string,",
						"          BPA_SECTION_CODE as string,",
						"          COVERAGE_CODE as string,",
						"          COVERAGE_CODE_DES as string,",
						"          BPA_COVERAGE_CODES as string,",
						"          BPA_COVERAGES as string,",
						"          COVERAGES as string,",
						"          BPA_PRODUCT_CODE as string,",
						"          SI_NO as string,",
						"          id as long,",
						"          BPA_SEC_NAME as string,",
						"          SOURCE_PRODUCT_CODE as string,",
						"          bpa_coverage_group as string,",
						"          bpa_coverage_level as string,",
						"          bpa_coverage_type as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> coverageSectionLookup",
						"source(output(",
						"          RISK_ID as string,",
						"          RISK_NUMBER as string,",
						"          POLICY_ID as long,",
						"          POLICY_NUMBER as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: ('select pr.RISK_ID, pr.RISK_NUMBER, pr.POLICY_ID, pp.POLICY_NUMBER from POL_RISK pr join POL_POLICY pp on pr.POLICY_ID = pp.POLICY_ID'),",
						"     format: 'query') ~> stagingPolicyRisk",
						"source(output(",
						"          RISK_ID as long,",
						"          RISK_NUMBER as string,",
						"          POLICY_ID as long,",
						"          POLICY_NUMBER as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select pr.RISK_ID, pr.RISK_NUMBER, pr.POLICY_ID, pp.POLICY_NUMBER, prd.ATTRIBUTE_NAME, prd.ATTRIBUTE_VALUE from POL_RISK pr join POL_POLICY pp on pr.POLICY_ID = pp.POLICY_ID join POL_RISK_DETAILS prd on prd.RISK_ID = pr.RISK_ID where prd.RISK_TYPE_CD = 'HO'\"),",
						"     format: 'query') ~> stageRiskDetails",
						"source(output(",
						"          Policy as string,",
						"          LocationNumber as string,",
						"          LocationUnitNumber as string,",
						"          LocationState as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select distinct Policy, LocationNumber, LocationUnitNumber, LocationState from Policy_Coverage where LocationNumber != '000' and PolicyPrefix = '{$policyPrefix}'\"+iif(size($policies) >0&& size($policies) ==1&&$policies[1] =='','','and policy in ('+dropLeft(toString(reduce($policies, \"'\", #acc + \",'\" + #item +\"'\", #result)), 2)+')')),",
						"     format: 'query') ~> sourceLocation",
						"source(output(",
						"          LOOKUP_ID as long,",
						"          LOOKUP_TYPE_ID as long,",
						"          LOOKUP_CODE as string,",
						"          LOOKUP_SHORT_DESCRIPTION as string,",
						"          LOOKUP_DESCRIPTION as string,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          DATA_HASH as binary,",
						"          SOURCE_KEY as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from ref_lookup where lookup_type_id in (1,2,3)\"),",
						"     format: 'query') ~> horseLookup",
						"targetQuoteInfo parse(quote_json = response ? (agent as (agencyCode as string,",
						"          agencyTier as string,",
						"          agencyType as string,",
						"          id as string,",
						"          isCancelled as string,",
						"          maintenanceAgency as string,",
						"          number as string,",
						"          parentEntityId as string,",
						"          parentEntityTypeName as string,",
						"          partyCode as string,",
						"          partyIdentifiers as string[],",
						"          partyName as string,",
						"          typeCode as string),",
						"          amountItem as (appliesToCode as string, currencyCode as string, description as string, editableOnTransaction as string, isAggregate as string, isMtaImpacted as string, isRefundable as string, levelCode as string, maxValue as string, minValue as string, originalAmount as string, pricedAmount as string, pricedValue as string, sequenceNumber as string, subTypeCode as string, typeCode as string, value as string, valueType as string)[],",
						"          businessPurposeType as string,",
						"          businessPurposeTypeCode as string,",
						"          carrierProcessingType as string,",
						"          claim as string[],",
						"          clientParticipant as (effectiveDate as string, expirationDate as string, extendedAttributes as (name as string)[], id as string, isCancelled as string, originalPartyName as string, parentEntityId as string, parentEntityTypeName as string, partyCode as string, partyName as string, professionalRole as string, questionAnswer as string[], roleCode as string, subRoleCode as string)[],",
						"          companyProductCode as string,",
						"          coverage as string[],",
						"          coverageGroup as string[],",
						"          createdBy as string,",
						"          createdDate as string,",
						"          currencyCode as string,",
						"          desiredEffectiveDate as string,",
						"          endorsement as (amountItem as (appliesToCode as string, currencyCode as string, editableOnTransaction as string, levelCode as string, originalAmount as string, pricedAmount as string, typeCode as string, valueType as string), clauses as string[], coverageCode as string, editionNumber as string, effectiveDate as string, endorsedPolicyReference as string, endorsementCode as string, endorsementNumber as string, endorsementType as string, expirationDate as string, extendedAttributes as string[], formCode as string, id as string, insurableObjectId as string, isCancelled as string, questionAnswer as string[], reasonCodes as string[], sectionCode as string, sourcePolicyReference as string)[],",
						"          extendedAttributes as (name as string, value as string)[],",
						"          firmRatingTrackingNumber as string,",
						"          forms as string[],",
						"          groupCode as string,",
						"          id as string,",
						"          initialRequestDate as string,",
						"          iterationNumber as string,",
						"          lineofBusinessCode as string,",
						"          location as string[],",
						"          majorVersion as string,",
						"          mgaParticipant as string[],",
						"          minorVersion as string,",
						"          operatingCompanyCode as string,",
						"          originalBusinessPurposeType as string,",
						"          originalBusinessPurposeTypeCode as string,",
						"          parentEntityId as string,",
						"          parentEntityTypeName as string,",
						"          policyEffectiveDate as string,",
						"          policyExpirationDate as string,",
						"          policyStage as string,",
						"          policyStatus as string,",
						"          policyStatusCodeDisplayName as string,",
						"          policyTerm as string,",
						"          preparedDate as string,",
						"          priorPolicy as string[],",
						"          productVersion as string,",
						"          questionAnswer as (answerCode as string, extendedAttributes as string[], id as string, isCancelled as string, parentEntityId as string, parentEntityTypeName as string, questionCode as string, questionText as string, value as string)[],",
						"          quoteNumber as string,",
						"          ratedIndicator as string,",
						"          reasons as string[],",
						"          referenceNumber as string,",
						"          sanctionCheckInfo as string[],",
						"          section as (amountItem as (appliesToCode as string, currencyCode as string, description as string, editableOnTransaction as string, isAggregate as string, isMtaImpacted as string, isRefundable as string, levelCode as string, maxValue as string, minValue as string, originalAmount as string, pricedAmount as string, pricedValue as string, sequenceNumber as string, subTypeCode as string, typeCode as string, value as string, valueType as string)[], carrierParticipant as string[], commissionAmountBasis as string, coverTypeCode as string, coverage as (amountItem as string[], appliesToCode as string, appliesToLevel as string, deductible as (currencyCode as string, id as string, name as string, parentEntityId as string, parentEntityTypeName as string, sequenceNumber as string, typeCode as string, value as string, valueType as string)[], effectiveDate as string, expirationDate as string, extendedAttributes as string[], fullPremium as string, id as string, isCancelled as string, limit as (currencyCode as string, id as string, name as string, parentEntityId as string, parentEntityTypeName as string, sequenceNumber as string, typeCode as string, value as string, valueType as string)[], option as string[], parentEntityId as string, parentEntityTypeName as string, sequenceNumber as string, tax as string[], typeCode as string)[], coverageGroup as string[], declinedIndicator as string, effectiveDate as string, expirationDate as string, extendedAttributes as string[], feeAmountBasis as string, id as string, insurableObject as (businessKey as string, extendedAttributes as (name as string, value as string)[], id as string, isCancelled as string, parentEntityId as string, parentEntityTypeName as string, sequenceNumber as string, typeCode as string)[], insurableObjectParticipant as (effectiveDate as string, expirationDate as string, extendedAttributes as string[], id as string, insurableObjectId as string, isCancelled as string, parentEntityId as string, parentEntityTypeName as string)[], isCancelled as string, isSharedCarrier as string, lineOfBusinessCode as string, location as string[], mappedLocations as string[], parentEntityId as string, parentEntityTypeName as string, premiumAmountBasis as string, pricedIndicator as string, pricingFactor as string[], primaryRatingState as string, questionAnswer as (answerCode as string, appliesToCode as string, extendedAttributes as string[], id as string, isCancelled as string, parentEntityId as string, parentEntityTypeName as string, questionCode as string, questionText as string, value as string)[], sectionItem as string[], sequenceNumber as string, subjectivity as string[], tax as string[], taxAmountBasis as string, taxJurisdiction as string[], triaRate as string, underwritingYear as string)[],",
						"          sectionWiseLocationAllocation as string,",
						"          sequenceNumber as string,",
						"          statusCode as string,",
						"          statusCodeDisplayName as string,",
						"          submissionCreatedBy as string,",
						"          submissionCreationDate as string,",
						"          tax as string[],",
						"          trackingNumber as string,",
						"          typeCode as string,",
						"          underlyingPolicies as string[],",
						"          underwriterDecisionInfo as string[],",
						"          validUntilDate as string),",
						"     format: 'json',",
						"     documentForm: 'singleDocument') ~> parse1",
						"parse1 select(mapColumn(",
						"          policy_number,",
						"          policy_id,",
						"          policy_reference,",
						"          quote_number,",
						"          sections = quote_json.section,",
						"          policy_reference",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"select1 foldDown(unrollMultiple(sections,sections.amountItem,every(match(name=='coverage'))),",
						"     mapColumn(",
						"          policy_number,",
						"          coverage = sections.coverage,",
						"          sectionCode = sections.coverTypeCode,",
						"          premiumLevelCode = sections.amountItem.levelCode,",
						"          premiumTypeCode = sections.amountItem.typeCode,",
						"          premiumAppliesToCode = sections.amountItem.appliesToCode,",
						"          premiumAmount = sections.amountItem.originalAmount,",
						"          stage_policy_number = policy_id,",
						"          policy_reference",
						"     ),",
						"     skipDuplicateMapInputs: false,",
						"     skipDuplicateMapOutputs: false) ~> flatten1",
						"MapDrifted1 derive(coverageCode = mapIf(coverage, #item.appliesToCode ==premiumAppliesToCode && #item.appliesToLevel == 'RSKUNT', #item.typeCode)) ~> derivedColumn1",
						"derivedColumn4 select(mapColumn(",
						"          policy_number,",
						"          sectionCode,",
						"          premiumLevelCode,",
						"          premiumTypeCode,",
						"          premiumAppliesToCode,",
						"          targetPremiumAmount = premiumAmount,",
						"          coverageCode,",
						"          stage_policy_number,",
						"          transaction_type,",
						"          target_coverage_code,",
						"          product_code,",
						"          policy_reference",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select2",
						"sourcePremium select(mapColumn(",
						"          Policy,",
						"          PolicyPrefix,",
						"          Description,",
						"          ARICCoverageCode,",
						"          ARICCoverageDescription,",
						"          LocationNumber,",
						"          LocationUnitNumber,",
						"          ARICCoverageSequence,",
						"          CoverageDescription,",
						"          Limit1,",
						"          Limit2,",
						"          SourcePremiumAmount = PremiumAmount",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select3",
						"select2 filter(premiumLevelCode ==",
						"'riskUnit'",
						"&& ((premiumTypeCode ==",
						"'premium'",
						"&& sectionCode ==",
						"'SEC001'",
						") || ((premiumTypeCode ==",
						"'medical_cov_premium'",
						"&& sectionCode ==",
						"'SEC002'",
						"))) && size(coverageCode) !=",
						"0) ~> filter1",
						"select3, filter2 join(ARICCoverageCode == COVERAGE_CODE",
						"     && ARICCoverageSequence == COV_SEQ,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> coveragePremiumLookup",
						"coveragePremiumLookup derive(source_risk_id = LocationNumber+'-'+LocationUnitNumber,",
						"          source_coverage_code = toString(ARICCoverageCode)+'-'+toString(ARICCoverageSequence)) ~> derivedColumn2",
						"derivedColumn2, stagingPolicyRisk join(Policy == POLICY_NUMBER",
						"     && source_risk_id == RISK_NUMBER,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"join1 select(mapColumn(",
						"          source_policy_number = Policy,",
						"          Description,",
						"          ARICCoverageDescription,",
						"          CoverageDescription,",
						"          ARICCoverageCode,",
						"          ARICCoverageSequence,",
						"          LocationNumber,",
						"          LocationUnitNumber,",
						"          SourcePremiumAmount,",
						"          COVERAGE_NAME = COVERAGES,",
						"          BPA_COVERAGES,",
						"          BPA_SEC_NAME,",
						"          BPA_SECTION_CODE,",
						"          BPA_COVERAGE_CODES,",
						"          source_insurable_object = RISK_ID,",
						"          RISK_NUMBER,",
						"          POLICY_ID,",
						"          POLICY_NUMBER,",
						"          source_coverage_code",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select4",
						"filter1, lookup2 lookup(select2@policy_number == source_policy_number",
						"     && premiumAppliesToCode == source_insurable_object",
						"     && sectionCode == BPA_SECTION_CODE",
						"     && trim(target_coverage_code) == trim(BPA_COVERAGE_CODES),",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lookup1",
						"MapDrifted2 select(mapColumn(",
						"          target_section = sectionCode,",
						"          premiumLevelCode,",
						"          premiumTypeCode,",
						"          target_insurable_object = premiumAppliesToCode,",
						"          target_premium = targetPremiumAmount,",
						"          target_coverage_code,",
						"          source_policy_number,",
						"          Description,",
						"          ARICCoverageDescription,",
						"          source_coverage_name = CoverageDescription,",
						"          ARICCoverageCode,",
						"          ARICCoverageSequence,",
						"          LocationNumber = select4@LocationNumber,",
						"          LocationUnitNumber = select4@LocationUnitNumber,",
						"          source_premium = SourcePremiumAmount,",
						"          COVERAGE_NAME,",
						"          target_coverage_name = BPA_COVERAGES,",
						"          target_section_name = BPA_SEC_NAME,",
						"          BPA_SECTION_CODE,",
						"          BPA_COVERAGE_CODES,",
						"          source_insurable_object,",
						"          RISK_NUMBER = select4@RISK_NUMBER,",
						"          POLICY_ID,",
						"          target_coverage_code,",
						"          stage_policy_number,",
						"          product_code,",
						"          transaction_type,",
						"          source_coverage_code,",
						"          horse_breed = {horseBreed },",
						"          horse_sex = {horseSex },",
						"          use = {use },",
						"          requested_limit = {requestedLimit },",
						"          age_in_years = {ageInYears },",
						"          year_born = {yearBorn },",
						"          purchase_price = {purchasePrice },",
						"          purchase_date = {purchaseDate },",
						"          location_state = LocationState,",
						"          target_policy_number = policy_reference",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select5",
						"flatten1 derive(coverage = coverage,",
						"          sectionCode = toString(byName('sectionCode')),",
						"          premiumLevelCode = toString(byName('premiumLevelCode')),",
						"          premiumTypeCode = toString(byName('premiumTypeCode')),",
						"          premiumAppliesToCode = toString(byName('premiumAppliesToCode')),",
						"          premiumAmount = toString(byName('premiumAmount'))) ~> MapDrifted1",
						"derivedColumn1 derive(target_coverage_code = replace(regexReplace(toString(byName('coverageCode')),`@\"\\s+|\\[+|\\]+`,''), '\"', ''),",
						"          transaction_type = 'premium',",
						"          product_code = $policyPrefix) ~> derivedColumn4",
						"derivedColumn5 pivot(groupBy(POLICY_NUMBER,",
						"          RISK_NUMBER),",
						"     pivotBy(ATTRIBUTE_NAME),",
						"     { } = first(final_attribute_value),",
						"     columnNaming: '$V$N',",
						"     lateral: true) ~> pivot1",
						"lookup3, pivot1 lookup(source_policy_number == pivot1@POLICY_NUMBER",
						"     && select4@RISK_NUMBER == pivot1@RISK_NUMBER,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lookup2",
						"lookup1 derive({ageInYears } = trim(toString(byName('ageInYears '))),",
						"          {horseBreed } = trim(toString(byName('horseBreed '))),",
						"          {horseName } = trim(toString(byName('horseName '))),",
						"          {horseSex } = trim(toString(byName('horseSex '))),",
						"          {purchaseDate } = trim(toString(byName('purchaseDate '))),",
						"          {purchasePrice } = trim(toString(byName('purchasePrice '))),",
						"          {requestedLimit } = trim(toString(byName('requestedLimit '))),",
						"          {use } = trim(toString(byName('use '))),",
						"          {yearBorn } = trim(toString(byName('yearBorn ')))) ~> MapDrifted2",
						"select4, sourceLocation lookup(source_policy_number == Policy",
						"     && select4@LocationNumber == sourceLocation@LocationNumber",
						"     && select4@LocationUnitNumber == sourceLocation@LocationUnitNumber,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lookup3",
						"stageRiskDetails, horseLookup lookup(trim(ATTRIBUTE_VALUE) == trim(LOOKUP_CODE),",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lookup4",
						"lookup4 derive(final_attribute_value = iif(isNull(LOOKUP_DESCRIPTION), ATTRIBUTE_VALUE, LOOKUP_DESCRIPTION)) ~> derivedColumn5",
						"coverageSectionLookup filter(bpa_coverage_level == 'U') ~> filter2",
						"select5 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          source_policy_number as string,",
						"          stage_policy_number as string,",
						"          target_policy_number as string,",
						"          transaction_type as string,",
						"          source_coverage_code as string,",
						"          target_coverage_code as string,",
						"          source_insurable_object as string,",
						"          target_insurable_object as string,",
						"          target_section as string,",
						"          source_premium as string,",
						"          target_premium as string,",
						"          batch_id as integer,",
						"          bpa_tenant_id as string,",
						"          product_code as string,",
						"          created_at as timestamp,",
						"          updated_at as timestamp,",
						"          horse_breed as string,",
						"          horse_sex as string,",
						"          use as string,",
						"          age_in_years as string,",
						"          year_born as string,",
						"          purchase_date as string,",
						"          purchase_price as string,",
						"          requested_limit as string,",
						"          location_state as string,",
						"          target_section_name as string,",
						"          target_coverage_name as string,",
						"          source_coverage_name as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink1"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ds_target_quoteInfo')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_Fact_Coverage_Premium')]",
				"[concat(variables('factoryId'), '/datasets/ECMBPA_COV_MAP')]",
				"[concat(variables('factoryId'), '/datasets/joinTableStageSQL')]",
				"[concat(variables('factoryId'), '/datasets/joinTableSourceSQL')]",
				"[concat(variables('factoryId'), '/datasets/StgRefLookUp')]",
				"[concat(variables('factoryId'), '/datasets/ds_target_rater_report')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_target_premium_report')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "utility"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_target_rater_report",
								"type": "DatasetReference"
							},
							"name": "source1"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "rater_report",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [],
					"scriptLines": [
						"source(output(",
						"          source_policy_number as string,",
						"          stage_policy_number as string,",
						"          target_policy_number as string,",
						"          transaction_type as string,",
						"          source_coverage_code as string,",
						"          target_coverage_code as string,",
						"          source_insurable_object as string,",
						"          target_insurable_object as string,",
						"          target_section as string,",
						"          source_premium as string,",
						"          target_premium as string,",
						"          batch_id as integer,",
						"          bpa_tenant_id as string,",
						"          product_code as string,",
						"          created_at as timestamp,",
						"          updated_at as timestamp,",
						"          horse_breed as string,",
						"          horse_sex as string,",
						"          use as string,",
						"          age_in_years as string,",
						"          year_born as string,",
						"          purchase_date as string,",
						"          purchase_price as string,",
						"          requested_limit as string,",
						"          location_state as string,",
						"          target_section_name as string,",
						"          target_coverage_name as string,",
						"          source_coverage_name as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> source1",
						"source1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          Code as string,",
						"          Description as string,",
						"          SubCode as string,",
						"          Order as string,",
						"          ExtendedAttributes as string",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink1"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ds_target_rater_report')]",
				"[concat(variables('factoryId'), '/datasets/rater_report')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_target_quoteInfo_deprecated')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "utility"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_stage_policy",
								"type": "DatasetReference"
							},
							"name": "policyTarget"
						},
						{
							"dataset": {
								"referenceName": "ds_stage_policytracker",
								"type": "DatasetReference"
							},
							"name": "policyTrackerTarget"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_target_quoteInfo",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "retrieveQuoteInfoAPI",
							"linkedService": {
								"referenceName": "RestService2",
								"type": "LinkedServiceReference"
							}
						},
						{
							"name": "searchQuoteAPI",
							"linkedService": {
								"referenceName": "RestService2",
								"type": "LinkedServiceReference"
							}
						},
						{
							"name": "searchPolicyAPI",
							"linkedService": {
								"referenceName": "RestService2",
								"type": "LinkedServiceReference"
							}
						},
						{
							"name": "select1"
						},
						{
							"name": "select4"
						},
						{
							"name": "select6"
						},
						{
							"name": "join2"
						},
						{
							"name": "derivedColumn8"
						},
						{
							"name": "derivedColumn9"
						},
						{
							"name": "select13"
						},
						{
							"name": "AlterRow1"
						},
						{
							"name": "searchParamsRenewalOf"
						}
					],
					"scriptLines": [
						"parameters{",
						"     policyPrefix as string,",
						"     policies as string[]",
						"}",
						"source(output(",
						"          policy_id as integer,",
						"          policy_number as string,",
						"          json_data as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from policy \"+iif(size($policies) >0&& size($policies) ==1&&$policies[1] =='','','where policy_number in ('+dropLeft(toString(reduce($policies, \"'\", #acc + \",'\" + #item +\"'\", #result)), 2)+')')),",
						"     format: 'query') ~> policyTarget",
						"source(output(",
						"          policy_id as integer,",
						"          policy_number as string,",
						"          bpa_tracking_number as string,",
						"          bpa_tenant_id as string,",
						"          bpa_username as string,",
						"          status as string,",
						"          created_at as timestamp,",
						"          updated_at as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select * from policy_tracker where status = \\'200\\'',",
						"     format: 'query') ~> policyTrackerTarget",
						"derivedColumn8 call(mapColumn(",
						"          policy_policy_number,",
						"          policy_reference,",
						"          quote_number,",
						"          queryParams",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     output(",
						"          retrieveQuoteResponse as (quote as string)",
						"     ),",
						"     allowSchemaDrift: true,",
						"     format: 'rest',",
						"     store: 'restservice',",
						"     timeout: 30,",
						"     requestInterval: 0,",
						"     httpMethod: 'GET',",
						"     rowRelativeUrl: 'queryParams',",
						"     entity: ('/policyadmin-api/retrieveQuoteInformation/v1/quote/'),",
						"     bodyColumnName: 'retrieveQuoteResponse',",
						"     requestFormat: ['type' -> 'json'],",
						"     responseFormat: ['type' -> 'json', 'documentForm' -> 'documentPerLine']) ~> retrieveQuoteInfoAPI",
						"derivedColumn9 call(mapColumn(",
						"          searchParams",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     output(",
						"          searchQuoteResponse as (quote as (quoteNumber as string)[])",
						"     ),",
						"     allowSchemaDrift: true,",
						"     format: 'rest',",
						"     store: 'restservice',",
						"     timeout: 30,",
						"     requestInterval: 0,",
						"     httpMethod: 'POST',",
						"     entity: (\"/policyadmin-api/searchQuote/v1/quote\"),",
						"     bodyColumnName: 'searchQuoteResponse',",
						"     requestFormat: ['type' -> 'json'],",
						"     responseFormat: ['type' -> 'json', 'documentForm' -> 'documentPerLine']) ~> searchQuoteAPI",
						"searchParamsRenewalOf call(mapColumn(",
						"          searchParams",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     output(",
						"          headers as [string,string],",
						"          searchPolicyResponse as (policy as (referenceNumber as string)[]),",
						"          status as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     format: 'rest',",
						"     store: 'restservice',",
						"     timeout: 30,",
						"     requestInterval: 0,",
						"     httpMethod: 'POST',",
						"     entity: ('/policyadmin-api/searchPolicyInformation/v1/policy'),",
						"     headerColumnName: 'headers',",
						"     bodyColumnName: 'searchPolicyResponse',",
						"     statusColumnName: 'status',",
						"     addResponseCode: true,",
						"     requestFormat: ['type' -> 'json'],",
						"     responseFormat: ['type' -> 'json', 'documentForm' -> 'documentPerLine']) ~> searchPolicyAPI",
						"policyTrackerTarget select(mapColumn(",
						"          tracker_policy_number = policy_number",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"policyTarget select(mapColumn(",
						"          policy_id,",
						"          policy_policy_number = policy_number",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select4",
						"retrieveQuoteInfoAPI select(mapColumn(",
						"          policy_number = policy_policy_number,",
						"          policy_reference,",
						"          quote_number,",
						"          quote = retrieveQuoteResponse.quote,",
						"          policy_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select6",
						"select4, select1 join(policy_policy_number == tracker_policy_number,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join2",
						"searchQuoteAPI derive(quote_number = searchQuoteResponse.quote[1].quoteNumber,",
						"          queryParams = searchQuoteResponse.quote[1].quoteNumber+'?identifierType=number') ~> derivedColumn8",
						"searchPolicyAPI derive(policy_reference = searchPolicyResponse.policy[1].referenceNumber,",
						"          searchParams = 'referenceNumber:*' + searchPolicyResponse.policy[1].referenceNumber +'*') ~> derivedColumn9",
						"join2 select(mapColumn(",
						"          policy_policy_number,",
						"          policy_id",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select13",
						"select6 alterRow(upsertIf(!isNull(policy_number)&&!isNull(quote_number))) ~> AlterRow1",
						"select13 derive(searchParams = 'renewalOf:'+policy_policy_number) ~> searchParamsRenewalOf",
						"AlterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          policy_number as string,",
						"          policy_id as integer,",
						"          policy_reference as string,",
						"          quote_number as string,",
						"          quote as string,",
						"          status as string,",
						"          response as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:true,",
						"     keys:['policy_number'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink1"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ds_stage_policy')]",
				"[concat(variables('factoryId'), '/datasets/ds_stage_policytracker')]",
				"[concat(variables('factoryId'), '/datasets/ds_target_quoteInfo')]",
				"[concat(variables('factoryId'), '/linkedServices/RestService2')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_update_stage_policyWithSection')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Target Stage Data Flows/updateJsonDataFlow"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_stage_policy",
								"type": "DatasetReference"
							},
							"name": "source1"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_stage_policy",
								"type": "DatasetReference"
							},
							"name": "sink1",
							"rejectedDataLinkedService": {
								"referenceName": "AzureBlobStorage1",
								"type": "LinkedServiceReference"
							}
						}
					],
					"transformations": [
						{
							"name": "derivedColumn1"
						},
						{
							"name": "select1"
						},
						{
							"name": "AlterRow1"
						},
						{
							"name": "derivedColumn2"
						},
						{
							"name": "aggregate1"
						},
						{
							"name": "derivedColumn3"
						},
						{
							"name": "derivedColumn4"
						},
						{
							"name": "derivedColumn5"
						},
						{
							"name": "derivedColumn6"
						},
						{
							"name": "derivedColumn7"
						},
						{
							"name": "derivedColumn8"
						},
						{
							"name": "derivedColumn9"
						},
						{
							"name": "derivedColumn10"
						},
						{
							"name": "derivedColumn11"
						},
						{
							"name": "filter1"
						}
					],
					"scriptLines": [
						"parameters{",
						"     policyPrefix as string ('CFA')",
						"}",
						"source(output(",
						"          policy_id as integer,",
						"          policy_number as string,",
						"          policyjson as string,",
						"          sectionjson as string,",
						"          section_code as string,",
						"          section_id as integer",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     batchSize: 0,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select pc.policy_id,pc.policy_number,pc.json_data  as policyJson ,sc.json_data as sectionJson ,sc.section_code,sc.section_id from policy pc\\njoin bpa_section sc \\non pc.policy_id=sc.policy_id',",
						"     format: 'query') ~> source1",
						"aggregate1 derive(finalPolicy = replace(policyjson,'\"section\":[]',concat('\"section\":',toString(sections)))) ~> derivedColumn1",
						"derivedColumn10 select(mapColumn(",
						"          policy_id,",
						"          policy_number,",
						"          json_data = finalPolicy",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"select1 alterRow(updateIf(!isNull(policy_id))) ~> AlterRow1",
						"derivedColumn1 derive(finalPolicy = unescape(finalPolicy, 'json')) ~> derivedColumn2",
						"filter1 aggregate(groupBy(policy_id,",
						"          policy_number,",
						"          policyjson),",
						"     sections = collect(sectionjson)) ~> aggregate1",
						"derivedColumn2 derive(finalPolicy = replace(finalPolicy,'[\"{','[{')) ~> derivedColumn3",
						"derivedColumn6 derive(finalPolicy = replace(finalPolicy,'}\"]','}]')) ~> derivedColumn4",
						"derivedColumn4 derive(finalPolicy = replace(finalPolicy, '\"{', '{')) ~> derivedColumn5",
						"derivedColumn3 derive(finalPolicy = unescape(finalPolicy, 'json')) ~> derivedColumn6",
						"derivedColumn5 derive(finalPolicy = replace(finalPolicy, '}\"', '}')) ~> derivedColumn7",
						"derivedColumn7 derive(finalPolicy = regexReplace(finalPolicy,'\"\"([^\"]*)\"\"', '\"$1\"')) ~> derivedColumn8",
						"derivedColumn8 derive(finalPolicy = replace(finalPolicy,'\"[','[')) ~> derivedColumn9",
						"derivedColumn9 derive(finalPolicy = replace(finalPolicy,']\"',']')) ~> derivedColumn10",
						"source1 derive(policyPrefixTemp = substring(policy_number, 1, 3)) ~> derivedColumn11",
						"derivedColumn11 filter(policyPrefixTemp == $policyPrefix) ~> filter1",
						"AlterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          policy_id as integer,",
						"          policy_number as string,",
						"          json_data as string",
						"     ),",
						"     deletable:false,",
						"     insertable:false,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['policy_id'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink1"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ds_stage_policy')]",
				"[concat(variables('factoryId'), '/linkedServices/AzureBlobStorage1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_update_stage_policyWithSection1')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "Flowlet",
				"typeProperties": {
					"sources": [],
					"sinks": [],
					"transformations": [
						{
							"name": "derivedColumn3"
						},
						{
							"name": "derivedColumn4"
						},
						{
							"name": "derivedColumn5"
						},
						{
							"name": "derivedColumn6"
						},
						{
							"name": "derivedColumn7"
						},
						{
							"name": "input1"
						},
						{
							"name": "output1"
						}
					],
					"scriptLines": [
						"input(output(",
						"          json as string,",
						"          id as long,",
						"          sec_id as long,",
						"          sec_code as string,",
						"          filteredSection as string",
						"     ),",
						"     order: 0,",
						"     allowSchemaDrift: true) ~> input1",
						"input1 derive(finalJson = replace(json,'[\"{','[{')) ~> derivedColumn3",
						"derivedColumn6 derive(finalJson = replace(finalJson,'}\"]','}]')) ~> derivedColumn4",
						"derivedColumn4 derive(finalJson = replace(finalJson, '\"{', '{')) ~> derivedColumn5",
						"derivedColumn3 derive(finalJson = unescape(finalJson, 'json')) ~> derivedColumn6",
						"derivedColumn5 derive(finalJson = replace(finalJson, '}\"', '}')) ~> derivedColumn7",
						"derivedColumn7 output() ~> output1"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_update_stage_policy_agent_clientparticipant')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Target Stage Data Flows/updateJsonDataFlow"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_policy_partyrole_bridge",
								"type": "DatasetReference"
							},
							"name": "policyPartyBridgeStaging"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_partyrole",
								"type": "DatasetReference"
							},
							"name": "partyroleStaging"
						},
						{
							"dataset": {
								"referenceName": "ds_stage_agency",
								"type": "DatasetReference"
							},
							"name": "agencyTarget"
						},
						{
							"dataset": {
								"referenceName": "ds_stage_policy",
								"type": "DatasetReference"
							},
							"name": "policyTarget"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_stage_policy",
								"type": "DatasetReference"
							},
							"name": "policyTargetSink"
						}
					],
					"transformations": [
						{
							"name": "join1"
						},
						{
							"name": "split1"
						},
						{
							"name": "join3"
						},
						{
							"name": "derivedColumn2"
						},
						{
							"name": "select1"
						},
						{
							"name": "select2"
						},
						{
							"name": "join4"
						},
						{
							"name": "join5"
						},
						{
							"name": "derivedColumn3"
						},
						{
							"name": "select3"
						},
						{
							"name": "alterRow1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          POLICY_PARTY_ROLE_BRIDGE_ID as long,",
						"          ROLE_ID as long,",
						"          ROLE_OVID as long,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          PARTY_ID as long,",
						"          PARTY_OVID as long,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          SOURCE_SYSTEM as string,",
						"          SOURCE_KEY as string,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DATA_HASH as binary,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT *\\n  FROM [DM_Source_Stage].[dbo].[POL_POLICY_PARTY_ROLE_BRIDGE]',",
						"     format: 'query') ~> policyPartyBridgeStaging",
						"source(output(",
						"          ROLE_ID as long,",
						"          ROLE_VID as long,",
						"          ROLE_CODE as string,",
						"          ROLE_DESCRIPTION as string,",
						"          IS_PRIMARY_INSURED_YN as string,",
						"          IS_DRIVER_YN as string,",
						"          IS_CUSTOMER_YN as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> partyroleStaging",
						"source(output(",
						"          agency_id as integer,",
						"          json_data as string,",
						"          bpa_party_code as string,",
						"          bpa_party_id as string,",
						"          party_name as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> agencyTarget",
						"source(output(",
						"          policy_id as integer,",
						"          policy_number as string,",
						"          json_data as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> policyTarget",
						"policyPartyBridgeStaging, partyroleStaging join(policyPartyBridgeStaging@ROLE_ID == partyroleStaging@ROLE_ID,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"join1 split(ROLE_CODE=='INSURED',",
						"     ROLE_CODE=='AGENCY',",
						"     disjoint: false) ~> split1@(split1, split2, default)",
						"split1@split2, agencyTarget join(PARTY_ID == agency_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join3",
						"join3 derive(agency_json_data = @(agencyCode=bpa_party_code,",
						"          partyName=party_name)) ~> derivedColumn2",
						"split1@split1 select(mapColumn(",
						"          POLICY_ID",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"derivedColumn2 select(mapColumn(",
						"          agency_json_data,",
						"          POLICY_ID",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select2",
						"select1, select2 join(select1@POLICY_ID == select2@POLICY_ID,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join4",
						"join4, policyTarget join(select1@POLICY_ID == policyTarget@policy_id,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join5",
						"join5 derive(policy_json_data = replace(json_data,'\"agent\":[]', concat('\"agent\":', iif(isNull(agency_json_data), 'null', toString(agency_json_data))))) ~> derivedColumn3",
						"derivedColumn3 select(mapColumn(",
						"          policy_id = policyTarget@policy_id,",
						"          json_data = policy_json_data",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select3",
						"select3 alterRow(updateIf(!isNull(json_data))) ~> alterRow1",
						"alterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          policy_id as integer,",
						"          policy_number as string,",
						"          json_data as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['policy_id'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     mapColumn(",
						"          policy_id,",
						"          json_data",
						"     )) ~> policyTargetSink"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_policy_partyrole_bridge')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_partyrole')]",
				"[concat(variables('factoryId'), '/datasets/ds_stage_agency')]",
				"[concat(variables('factoryId'), '/datasets/ds_stage_policy')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/fl_emp_premium_calc')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "utility/flowlet"
				},
				"type": "Flowlet",
				"typeProperties": {
					"sources": [],
					"sinks": [],
					"transformations": [
						{
							"name": "filter1"
						},
						{
							"name": "split1"
						},
						{
							"name": "derivedColumn2"
						},
						{
							"name": "derivedColumn3"
						},
						{
							"name": "join1"
						},
						{
							"name": "derivedColumn4"
						},
						{
							"name": "select8"
						},
						{
							"name": "derivedColumn5"
						},
						{
							"name": "derivedColumn6"
						},
						{
							"name": "union1"
						},
						{
							"name": "select9"
						},
						{
							"name": "select10"
						},
						{
							"name": "select12"
						},
						{
							"name": "targetPremiumDetails"
						},
						{
							"name": "output1"
						}
					],
					"scriptLines": [
						"input(output(",
						"          policy as string,",
						"          amountItem as (appliesToCode as string, currencyCode as string, description as string, editableOnTransaction as string, isAggregate as string, isMtaImpacted as string, isRefundable as string, levelCode as string, maxValue as string, minValue as string, originalAmount as string, pricedAmount as string, pricedValue as string, sequenceNumber as string, subTypeCode as string, typeCode as string, value as string, valueType as string)",
						"     ),",
						"     order: 0,",
						"     allowSchemaDrift: true) ~> targetPremiumDetails",
						"targetPremiumDetails filter((amountItem.typeCode == 'premium' && amountItem.levelCode == 'section' && (amountItem.appliesToCode == 'SEC001' || amountItem.appliesToCode == 'SEC002')) || (amountItem.typeCode == 'tack_premium' && ((amountItem.levelCode == 'policy' && amountItem.appliesToCode == 'SEC000') || (amountItem.levelCode == 'section' && amountItem.appliesToCode == 'SEC002')))) ~> filter1",
						"filter1 split(amountItem.appliesToCode == 'SEC001',",
						"     amountItem.appliesToCode == 'SEC002' && amountItem.typeCode == 'tack_premium',",
						"     amountItem.appliesToCode == 'SEC000',",
						"     amountItem.appliesToCode == 'SEC002' && amountItem.typeCode == 'premium',",
						"     disjoint: false) ~> split1@(section1, section2TrackPremium, section0, section2)",
						"split1@section2TrackPremium derive(tack_premium = toDecimal(amountItem.originalAmount),",
						"          section = amountItem.appliesToCode) ~> derivedColumn2",
						"split1@section2 derive(premium = toDecimal(amountItem.originalAmount),",
						"          section = amountItem.appliesToCode) ~> derivedColumn3",
						"derivedColumn3, derivedColumn2 join(derivedColumn3@section == derivedColumn2@section",
						"     && split1@section2@policy == split1@section2TrackPremium@policy,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'right')~> join1",
						"join1 derive(section2_premium = premium - tack_premium,",
						"          section = split1@section2@amountItem.appliesToCode) ~> derivedColumn4",
						"derivedColumn4 select(mapColumn(",
						"          section_premium = section2_premium,",
						"          section,",
						"          policy = split1@section2@policy",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select8",
						"split1@section0 derive(section_premium = toDecimal(amountItem.originalAmount),",
						"          section = amountItem.appliesToCode) ~> derivedColumn5",
						"split1@section1 derive(section_premium = toDecimal(amountItem.originalAmount),",
						"          section = amountItem.appliesToCode) ~> derivedColumn6",
						"select10, select9, select8 union(byName: true)~> union1",
						"derivedColumn5 select(mapColumn(",
						"          section_premium,",
						"          section,",
						"          policy",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select9",
						"derivedColumn6 select(mapColumn(",
						"          section_premium,",
						"          section,",
						"          policy",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select10",
						"union1 select(mapColumn(",
						"          section_premium,",
						"          section,",
						"          policy",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select12",
						"select12 output() ~> output1"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/fl_rater_api_requests')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "utility/flowlet"
				},
				"type": "Flowlet",
				"typeProperties": {
					"sources": [],
					"sinks": [],
					"transformations": [
						{
							"name": "calculatePremiumAPI",
							"linkedService": {
								"referenceName": "RestService2",
								"type": "LinkedServiceReference"
							}
						},
						{
							"name": "retrieveQuoteInfoAPI",
							"linkedService": {
								"referenceName": "RestService2",
								"type": "LinkedServiceReference"
							}
						},
						{
							"name": "retrievePolicyInfoAPI",
							"linkedService": {
								"referenceName": "RestService2",
								"type": "LinkedServiceReference"
							}
						},
						{
							"name": "searchQuoteAPI",
							"linkedService": {
								"referenceName": "RestService2",
								"type": "LinkedServiceReference"
							}
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "select6"
						},
						{
							"name": "flatten1"
						},
						{
							"name": "select7"
						},
						{
							"name": "derivedColumn7"
						},
						{
							"name": "derivedColumn8"
						},
						{
							"name": "policyTarget"
						},
						{
							"name": "output1"
						}
					],
					"scriptLines": [
						"input(output(",
						"          policy_policy_number as string,",
						"          tracker_policy_number as string,",
						"          ref_pol as string",
						"     ),",
						"     order: 0,",
						"     allowSchemaDrift: true) ~> policyTarget",
						"derivedColumn1 call(mapColumn(",
						"          quote_number,",
						"          quote = retrieveQuoteResponse.quote,",
						"          messageInformation",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     output(",
						"          raterResponse as (messageInformation as (businessPurposeTypeCode as string, messageStatus as (statusCode as string, statusDescription as string, successStatusCode as string), trackingNumber as string, userInfo as (userName as string), userJourneyType as string), riskDetail as (agent as (agencyCode as string, agencyTier as string, agencyType as string, id as string, isCancelled as string, maintenanceAgency as string, number as string, parentEntityId as string, parentEntityTypeName as string, partyCode as string, partyIdentifiers as string[], partyName as string, typeCode as string), amountItem as string[], businessPurposeType as string, businessPurposeTypeCode as string, carrierProcessingType as string, claim as string[], clientParticipant as (effectiveDate as string, expirationDate as string, extendedAttributes as (name as string)[], id as string, isCancelled as string, originalPartyName as string, parentEntityId as string, parentEntityTypeName as string, partyCode as string, partyName as string, professionalRole as string, questionAnswer as string[], roleCode as string, subRoleCode as string)[], companyProductCode as string, coverage as string[], coverageGroup as string[], createdBy as string, createdDate as string, currencyCode as string, desiredEffectiveDate as string, endorsement as (amountItem as (appliesToCode as string, currencyCode as string, editableOnTransaction as string, levelCode as string, originalAmount as string, pricedAmount as string, typeCode as string, valueType as string), clauses as string[], coverageCode as string, editionNumber as string, effectiveDate as string, endorsedPolicyReference as string, endorsementCode as string, endorsementNumber as string, endorsementType as string, expirationDate as string, extendedAttributes as string[], formCode as string, id as string, insurableObjectId as string, isCancelled as string, questionAnswer as string[], reasonCodes as string[], sectionCode as string, sourcePolicyReference as string)[], extendedAttributes as (name as string, value as string)[], firmRatingTrackingNumber as string, forms as string[], groupCode as string, id as string, initialRequestDate as string, iterationNumber as string, lineofBusinessCode as string, location as string[], majorVersion as string, mgaParticipant as string[], minorVersion as string, operatingCompanyCode as string, originalBusinessPurposeType as string, originalBusinessPurposeTypeCode as string, parentEntityId as string, parentEntityTypeName as string, policyEffectiveDate as string, policyExpirationDate as string, policyStage as string, policyStatus as string, policyStatusCodeDisplayName as string, policyTerm as string, preparedDate as string, priorPolicy as string[], productVersion as string, questionAnswer as (answerCode as string, extendedAttributes as string[], id as string, isCancelled as string, parentEntityId as string, parentEntityTypeName as string, questionCode as string, questionText as string, value as string)[], quoteNumber as string, ratedIndicator as string, reasons as string[], referenceNumber as string, sanctionCheckInfo as string[], section as (amountItem as (appliesToCode as string, currencyCode as string, description as string, editableOnTransaction as string, isAggregate as string, isMtaImpacted as string, isRefundable as string, levelCode as string, maxValue as string, minValue as string, originalAmount as string, pricedAmount as string, pricedValue as string, sequenceNumber as string, subTypeCode as string, typeCode as string, value as string, valueType as string)[], carrierParticipant as string[], commissionAmountBasis as string, coverTypeCode as string, coverage as (amountItem as string[], appliesToCode as string, appliesToLevel as string, deductible as (currencyCode as string, id as string, name as string, parentEntityId as string, parentEntityTypeName as string, sequenceNumber as string, typeCode as string, value as string, valueType as string)[], effectiveDate as string, expirationDate as string, extendedAttributes as string[], fullPremium as string, id as string, isCancelled as string, limit as (currencyCode as string, id as string, name as string, parentEntityId as string, parentEntityTypeName as string, sequenceNumber as string, typeCode as string, value as string, valueType as string)[], option as string[], parentEntityId as string, parentEntityTypeName as string, sequenceNumber as string, tax as string[], typeCode as string)[], coverageGroup as string[], declinedIndicator as string, effectiveDate as string, expirationDate as string, extendedAttributes as string[], feeAmountBasis as string, id as string, insurableObject as (businessKey as string, extendedAttributes as (name as string, value as string)[], id as string, isCancelled as string, parentEntityId as string, parentEntityTypeName as string, sequenceNumber as string, typeCode as string)[], insurableObjectParticipant as (effectiveDate as string, expirationDate as string, extendedAttributes as string[], id as string, insurableObjectId as string, isCancelled as string, parentEntityId as string, parentEntityTypeName as string)[], isCancelled as string, isSharedCarrier as string, lineOfBusinessCode as string, location as string[], mappedLocations as string[], parentEntityId as string, parentEntityTypeName as string, premiumAmountBasis as string, pricedIndicator as string, pricingFactor as string[], primaryRatingState as string, questionAnswer as (answerCode as string, appliesToCode as string, extendedAttributes as string[], id as string, isCancelled as string, parentEntityId as string, parentEntityTypeName as string, questionCode as string, questionText as string, value as string)[], sectionItem as string[], sequenceNumber as string, subjectivity as string[], tax as string[], taxAmountBasis as string, taxJurisdiction as string[], triaRate as string, underwritingYear as string)[], sectionWiseLocationAllocation as string, sequenceNumber as string, statusCode as string, statusCodeDisplayName as string, submissionCreatedBy as string, submissionCreationDate as string, tax as string[], trackingNumber as string, typeCode as string, underlyingPolicies as string[], underwriterDecisionInfo as string[], validUntilDate as string))",
						"     ),",
						"     allowSchemaDrift: true,",
						"     format: 'rest',",
						"     store: 'restservice',",
						"     timeout: 30,",
						"     requestInterval: 0,",
						"     httpMethod: 'POST',",
						"     rowRelativeUrl: 'quote_number',",
						"     entity: ('/policyadmin-api/calculateRatedValues/v1/quote/'),",
						"     bodyColumnName: 'raterResponse',",
						"     requestFormat: ['type' -> 'json'],",
						"     responseFormat: ['type' -> 'json', 'documentForm' -> 'documentPerLine']) ~> calculatePremiumAPI",
						"derivedColumn8 call(mapColumn(",
						"          policy_policy_number,",
						"          tracker_policy_number,",
						"          retrievePolicyInfoResponse,",
						"          policy_reference,",
						"          searchParams,",
						"          searchQuoteResponse,",
						"          quote_number,",
						"          queryParams,",
						"          ref_pol",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     output(",
						"          retrieveQuoteResponse as (quote as (agent as (agencyCode as string, agencyTier as string, agencyType as string, id as string, isCancelled as string, maintenanceAgency as string, number as string, parentEntityId as string, parentEntityTypeName as string, partyCode as string, partyIdentifiers as (id as string, partyCode as string, identifierType as string, identifierValue as string)[], partyName as string, typeCode as string), amountItem as string[], businessPurposeType as string, businessPurposeTypeCode as string, carrierProcessingType as string, claim as string[], clientParticipant as (effectiveDate as string, expirationDate as string, extendedAttributes as (name as string, value as string)[], id as string, isCancelled as string, originalPartyName as string, parentEntityId as string, parentEntityTypeName as string, partyCode as string, partyName as string, professionalRole as string, questionAnswer as string[], roleCode as string, subRoleCode as string)[], companyProductCode as string, coverage as string[], coverageGroup as string[], createdBy as string, createdDate as string, currencyCode as string, desiredEffectiveDate as string, endorsement as (clauses as string[], coverageCode as string, editionNumber as string, effectiveDate as string, endorsedPolicyReference as string, endorsementCode as string, endorsementNumber as string, endorsementType as string, expirationDate as string, extendedAttributes as (name as string, value as string)[], formCode as string, id as string, insurableObjectId as string, isCancelled as string, questionAnswer as string[], reasonCodes as string[], sectionCode as string, sourcePolicyReference as string)[], extendedAttributes as (name as string, value as string)[], forms as string[], groupCode as string, id as string, initialRequestDate as string, iterationNumber as string, lineofBusinessCode as string, location as (address as (line1 as string, line2 as string, city as string, postalCode as string, isPrimaryAddress as string, countyName as string), id as string, typeCode as string, parentEntityId as string, parentEntityTypeName as string, earthquakeZone as string, effectiveDate as string, expirationDate as string, isCancelled as string, tax as string[], amountItem as string[], extendedAttributes as (name as string, value as string)[], insurableObject as string[], businessKey as string)[], majorVersion as string, mgaParticipant as string[], minorVersion as string, operatingCompanyCode as string, originalBusinessPurposeType as string, originalBusinessPurposeTypeCode as string, parentEntityId as string, parentEntityTypeName as string, policyEffectiveDate as string, policyExpirationDate as string, policyStage as string, policyStatus as string, policyStatusCodeDisplayName as string, policyTerm as string, preparedDate as string, priorPolicy as string[], productVersion as string, questionAnswer as (answerCode as string, extendedAttributes as (name as string, value as string)[], id as string, isCancelled as string, parentEntityId as string, parentEntityTypeName as string, questionCode as string, questionText as string, value as string)[], quoteNumber as string, ratedIndicator as string, reasons as string[], referenceNumber as string, sanctionCheckInfo as string[], section as (amountItem as string[], carrierParticipant as string[], coverTypeCode as string, coverage as (amountItem as string[], appliesToCode as string, appliesToLevel as string, deductible as (currencyCode as string, id as string, name as string, parentEntityId as string, parentEntityTypeName as string, sequenceNumber as string, typeCode as string, value as string, valueType as string)[], effectiveDate as string, expirationDate as string, extendedAttributes as (name as string, value as string)[], fullPremium as string, id as string, isCancelled as string, limit as (currencyCode as string, id as string, name as string, parentEntityId as string, parentEntityTypeName as string, sequenceNumber as string, typeCode as string, value as string, valueType as string)[], option as string[], parentEntityId as string, parentEntityTypeName as string, sequenceNumber as string, tax as string[], typeCode as string)[], coverageGroup as string[], declinedIndicator as string, effectiveDate as string, expirationDate as string, extendedAttributes as (name as string, value as string)[], id as string, insurableObject as (businessKey as string, extendedAttributes as (name as string, value as string)[], id as string, isCancelled as string, parentEntityId as string, parentEntityTypeName as string, sequenceNumber as string, typeCode as string)[], insurableObjectParticipant as (effectiveDate as string, expirationDate as string, extendedAttributes as (name as string, value as string)[], id as string, insurableObjectId as string, isCancelled as string, parentEntityId as string, parentEntityTypeName as string)[], isCancelled as string, isSharedCarrier as string, lineOfBusinessCode as string, location as (address as (line1 as string, line2 as string, city as string, postalCode as string, isPrimaryAddress as string, countyName as string), id as string, typeCode as string, parentEntityId as string, parentEntityTypeName as string, earthquakeZone as string, effectiveDate as string, expirationDate as string, isCancelled as string, tax as string[], amountItem as string[], extendedAttributes as (name as string, value as string)[], insurableObject as string[], businessKey as string)[], mappedLocations as string[], parentEntityId as string, parentEntityTypeName as string, premiumAmountBasis as string, pricedIndicator as string, pricingFactor as string[], primaryRatingState as string, questionAnswer as (answerCode as string, appliesToCode as string, extendedAttributes as (name as string, value as string)[], id as string, isCancelled as string, parentEntityId as string, parentEntityTypeName as string, questionCode as string, questionText as string, value as string)[], sectionItem as string[], sequenceNumber as string, subjectivity as string[], tax as string[], taxAmountBasis as string, taxJurisdiction as string[], triaRate as string, underwritingYear as string)[], sectionWiseLocationAllocation as string, sequenceNumber as string, statusCode as string, statusCodeDisplayName as string, submissionCreatedBy as string, submissionCreationDate as string, tax as string[], trackingNumber as string, typeCode as string, underlyingPolicies as string[], underwriterDecisionInfo as string[], validUntilDate as string))",
						"     ),",
						"     allowSchemaDrift: true,",
						"     format: 'rest',",
						"     store: 'restservice',",
						"     timeout: 30,",
						"     requestInterval: 0,",
						"     httpMethod: 'GET',",
						"     rowRelativeUrl: 'queryParams',",
						"     entity: ('/policyadmin-api/retrieveQuoteInformation/v1/quote/'),",
						"     bodyColumnName: 'retrieveQuoteResponse',",
						"     requestFormat: ['type' -> 'json'],",
						"     responseFormat: ['type' -> 'json', 'documentForm' -> 'documentPerLine']) ~> retrieveQuoteInfoAPI",
						"policyTarget call(mapColumn(",
						"          policy_policy_number,",
						"          tracker_policy_number,",
						"          ref_pol",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     output(",
						"          retrievePolicyInfoResponse as (policy as (referenceNumber as string))",
						"     ),",
						"     allowSchemaDrift: true,",
						"     format: 'rest',",
						"     store: 'restservice',",
						"     timeout: 30,",
						"     requestInterval: 0,",
						"     httpMethod: 'GET',",
						"     rowRelativeUrl: 'ref_pol',",
						"     entity: ('/policyadmin-api/retrievePolicyInformation/v1/policy/'),",
						"     bodyColumnName: 'retrievePolicyInfoResponse',",
						"     requestFormat: ['type' -> 'json'],",
						"     responseFormat: ['type' -> 'json', 'documentForm' -> 'documentPerLine']) ~> retrievePolicyInfoAPI",
						"derivedColumn7 call(mapColumn(",
						"          searchParams",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     output(",
						"          searchQuoteResponse as (quote as (quoteNumber as string)[])",
						"     ),",
						"     allowSchemaDrift: true,",
						"     format: 'rest',",
						"     store: 'restservice',",
						"     timeout: 30,",
						"     requestInterval: 0,",
						"     httpMethod: 'POST',",
						"     entity: (\"/policyadmin-api/searchQuote/v1/quote\"),",
						"     bodyColumnName: 'searchQuoteResponse',",
						"     requestFormat: ['type' -> 'json'],",
						"     responseFormat: ['type' -> 'json', 'documentForm' -> 'documentPerLine']) ~> searchQuoteAPI",
						"select6 derive(messageInformation = @(sender='viswa',",
						"          userInfo=@(userName='viswa'),",
						"          businessPurposeTypeCode='NBS',",
						"          trackingNumber=uuid(),",
						"          formKey='Policy Detail')) ~> derivedColumn1",
						"retrieveQuoteInfoAPI select(mapColumn(",
						"          policy_policy_number,",
						"          policy_reference,",
						"          quote_number,",
						"          retrieveQuoteResponse",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select6",
						"select7 foldDown(unroll(sections.amountItem),",
						"     mapColumn(",
						"          amountItem = sections.amountItem,",
						"          policy = policy_policy_number",
						"     ),",
						"     skipDuplicateMapInputs: false,",
						"     skipDuplicateMapOutputs: false) ~> flatten1",
						"calculatePremiumAPI select(mapColumn(",
						"          policy_policy_number,",
						"          policy_reference,",
						"          quote_number,",
						"          sections = raterResponse.riskDetail.section",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select7",
						"retrievePolicyInfoAPI derive(policy_reference = retrievePolicyInfoResponse.policy.referenceNumber,",
						"          searchParams = 'referenceNumber:*' + retrievePolicyInfoResponse.policy.referenceNumber +'*') ~> derivedColumn7",
						"searchQuoteAPI derive(quote_number = searchQuoteResponse.quote[1].quoteNumber,",
						"          queryParams = searchQuoteResponse.quote[1].quoteNumber+'?identifierType=number') ~> derivedColumn8",
						"flatten1 output() ~> output1"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/RestService2')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/fl_source_addDefaultColumnFlowlet')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Source Stage Data Flows/flowlet"
				},
				"type": "Flowlet",
				"typeProperties": {
					"sources": [],
					"sinks": [],
					"transformations": [
						{
							"name": "derivedColumn1"
						},
						{
							"name": "input1"
						},
						{
							"name": "output1"
						}
					],
					"scriptLines": [
						"parameters{",
						"     FL_batch as integer (1)",
						"}",
						"input(order: 0,",
						"     allowSchemaDrift: true) ~> input1",
						"input1 derive(IS_VALID_YN = \"Y\",",
						"          VALID_START_DATE = currentTimestamp(),",
						"          VALID_END_DATE = toTimestamp(\"9999-01-01 00:00:00\"),",
						"          BATCH_ID = $FL_batch,",
						"          UNIQUE_IDENTIFIER = uuid(),",
						"          DELETED_YN = \"N\",",
						"          BPAM_LAST_CREATED_DATE = currentTimestamp(),",
						"          BPAM_LAST_MODIFIED_DATE = currentTimestamp()) ~> derivedColumn1",
						"derivedColumn1 output() ~> output1"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/sub_lob_df')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Source Stage Data Flows"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_policyCoverage",
								"type": "DatasetReference"
							},
							"name": "source1"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_sub_LOB",
								"type": "DatasetReference"
							},
							"name": "source2"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_sub_LOB",
								"type": "DatasetReference"
							},
							"name": "sink1"
						},
						{
							"name": "sink2"
						}
					],
					"transformations": [
						{
							"name": "flowlet1",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "derivedColumn2"
						},
						{
							"name": "surrogateKey1"
						},
						{
							"name": "select1"
						}
					],
					"scriptLines": [
						"parameters{",
						"     policyPrefix as string ('EMP')",
						"}",
						"source(output(",
						"          Policy as string,",
						"          Policy_Sequence as string,",
						"          ARICLOB as string,",
						"          ARICGroupCode as string,",
						"          Description as string,",
						"          Product as string,",
						"          ARICCoverageCode as string,",
						"          ARICCoverageDescription as string,",
						"          EndorsementNumber as integer,",
						"          LocationNumber as string,",
						"          LocationUnitNumber as string,",
						"          BuildingNumber as string,",
						"          LocationName as string,",
						"          LocationAddress1 as string,",
						"          LocationAddress2 as string,",
						"          LocationAddress3 as string,",
						"          Occupancy as string,",
						"          LocationCity as string,",
						"          LocationZipCode as string,",
						"          LocationCounty as string,",
						"          Territory as string,",
						"          ConstructionCode as string,",
						"          ConstructionYear as integer,",
						"          NumberOfFloors as integer,",
						"          ProtectionClass as string,",
						"          GEOLatitude as decimal(11,8),",
						"          GEOLongitude as decimal(11,8),",
						"          CauseOfLoss as string,",
						"          BCEGClassCode as string,",
						"          CoverageForm as string,",
						"          DesignatedPremisis as string,",
						"          WindIndicatorFlag as string,",
						"          PurchaseCost as decimal(8,2),",
						"          dbo as string,",
						"          CoInsuranceBuilding as integer,",
						"          CoInsurancePersonalProperty as integer,",
						"          CoInsuranceBodilyInjury as integer,",
						"          CountryCode as string,",
						"          MunicipalityCode as string,",
						"          ParkName as string,",
						"          CountyCode as integer,",
						"          NumberParkSpaces as integer,",
						"          NumberOfAcres as integer,",
						"          OwnOrRent as string,",
						"          ResidenceTypeCode as string,",
						"          LocationZone as string,",
						"          ARICCoverageSequence as integer,",
						"          CoveragePart as string,",
						"          CoverageAddDate as timestamp,",
						"          CoverageDescription as string,",
						"          CoverageInternalCode as string,",
						"          CoverageAbbreviation as string,",
						"          CoveragePartSequence as integer,",
						"          CoverageISOLine as integer,",
						"          CoverageCATCode as string,",
						"          CoverageLine4 as integer,",
						"          CoverageAddUser as string,",
						"          CoverageUpdateDate as timestamp,",
						"          CoverageUpdateUser as string,",
						"          CoverageLineFlag as string,",
						"          LocationState as string,",
						"          ISOClassCode as string,",
						"          RetroEndorsementNumber as integer,",
						"          PolicyPrefix as string,",
						"          EffectiveDate as timestamp,",
						"          Policy_Accounting_date as timestamp,",
						"          ExpirationDate as timestamp,",
						"          CancelDate as timestamp,",
						"          CancelReason as string,",
						"          CancelReasonDescription as string,",
						"          PolicyTermMonths as integer,",
						"          InsuredName as string,",
						"          InsuredAddress1 as string,",
						"          InsuredAddress2 as string,",
						"          InsuredCity as string,",
						"          InsuredState as string,",
						"          InsuredZipCode as string,",
						"          CompanyCode as string,",
						"          CompanyName as string,",
						"          GroupName as string,",
						"          GBLICompanyCode as string,",
						"          AgentCode as string,",
						"          AgentName as string,",
						"          AgentOffice as string,",
						"          GroupCode as string,",
						"          AgentCity as string,",
						"          EMail as string,",
						"          AgentPhone as string,",
						"          AgentCounty as string,",
						"          AgentZipCode as string,",
						"          AgentAddress1 as string,",
						"          AgentAddress2 as string,",
						"          AgentState as string,",
						"          SubProducerNumber as string,",
						"          SubProducerCode as string,",
						"          SubProducerName as string,",
						"          SubproducerState as string,",
						"          SubProducerType as string,",
						"          ProductCode as string,",
						"          ProductCodeDescription as string,",
						"          PreviousPolicy as string,",
						"          OriginalPolicyYear as integer,",
						"          NonRenewalReason as string,",
						"          NonRenewalNoticeDate as timestamp,",
						"          DatabaseCode as string,",
						"          Policy_ID as integer,",
						"          MinimumPremium as decimal(13,0),",
						"          POlicy_Receive_date as timestamp,",
						"          MasterPolicy as string,",
						"          BillingType as string,",
						"          RowStatus as string,",
						"          OriginalInceptionDate as timestamp,",
						"          MultiplePolicyFlag as string,",
						"          ARICBusinessUnit as string,",
						"          HonorCurrentRateFlag as string,",
						"          FarmType as string,",
						"          PrimaryPremiumStateCode as string,",
						"          StateName as string,",
						"          Policy_Insert_Date as date,",
						"          BillingSystem as string,",
						"          Cov_effective_Date as timestamp,",
						"          Cov_Expiry_Date as timestamp,",
						"          ReceivedDate as date,",
						"          CoverageArrayNumber as integer,",
						"          LiabilityFlag as string,",
						"          ExperienceModFactor as decimal(7,4),",
						"          Exposure as decimal(8,0),",
						"          TaxFeeSurchargeFlag as string,",
						"          CancelReinstateFlag as string,",
						"          ReleasedFlag as string,",
						"          ReleaseDate as date,",
						"          Rate as decimal(12,6),",
						"          PremiumStateCode as string,",
						"          Coverage_ID as integer,",
						"          Coverage_accounting_date as timestamp,",
						"          Coverage_Insert_Date as date",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select DISTINCT ARICCoverageCode,ARICCoverageDescription from  Policy_Coverage where PolicyPrefix='{$policyPrefix}'\" ),",
						"     format: 'query') ~> source1",
						"source(output(",
						"          sublob_id as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select MAX(SUB_LOB_ID)  as sublob_id from dbo.POL_SUB_LOB',",
						"     format: 'query') ~> source2",
						"derivedColumn1 compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet1@(output1)",
						"select1 derive(SUB_LOB_ID = sink2#outputs()[1].sublob_id +pkey,",
						"          SUB_LOB_CODE = ARICCoverageCode,",
						"          SUB_LOB_NAME = ARICCoverageDescription,",
						"          SUB_LOB_DESCRIPTION = ARICCoverageDescription) ~> derivedColumn1",
						"source2 derive(sublob_id = iifNull(sublob_id, 0, sublob_id)) ~> derivedColumn2",
						"source1 keyGenerate(output(pkey as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> surrogateKey1",
						"surrogateKey1 select(mapColumn(",
						"          ARICCoverageCode,",
						"          ARICCoverageDescription,",
						"          pkey",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"flowlet1@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          SUB_LOB_ID as long,",
						"          SUB_LOB_CODE as string,",
						"          SUB_LOB_NAME as string,",
						"          SUB_LOB_DESCRIPTION as string,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink1",
						"derivedColumn2 sink(validateSchema: false,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     store: 'cache',",
						"     format: 'inline',",
						"     output: false,",
						"     saveOrder: 1) ~> sink2"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/fl_source_addDefaultColumnFlowlet')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_policyCoverage')]",
				"[concat(variables('factoryId'), '/datasets/ds_source_stage_sub_LOB')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/default')]",
			"type": "Microsoft.DataFactory/factories/managedVirtualNetworks",
			"apiVersion": "2018-06-01",
			"properties": {},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/default/AzureBlobStorageECM')]",
			"type": "Microsoft.DataFactory/factories/managedVirtualNetworks/managedPrivateEndpoints",
			"apiVersion": "2018-06-01",
			"properties": {
				"privateLinkResourceId": "[parameters('AzureBlobStorageECM_properties_privateLinkResourceId')]",
				"groupId": "[parameters('AzureBlobStorageECM_properties_groupId')]"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/managedVirtualNetworks/default')]"
			]
		}
	]
}