{
	"$schema": "http://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
	"contentVersion": "1.0.0.0",
	"parameters": {
		"factoryName": {
			"type": "string",
			"metadata": "Data Factory name",
			"defaultValue": "adf-eus-idp-d-01"
		}
	},
	"variables": {
		"factoryId": "[concat('Microsoft.DataFactory/factories/', parameters('factoryName'))]"
	},
	"resources": [
		{
			"name": "[concat(parameters('factoryName'), '/df_source_coverageCode')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Source Stage Data Flows/txnDataFlow"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_policyCoverage",
								"type": "DatasetReference"
							},
							"name": "policyCoverageSource"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_coverageCode",
								"type": "DatasetReference"
							},
							"name": "pkey"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_coverageCode",
								"type": "DatasetReference"
							},
							"name": "coverageCodeStaging"
						},
						{
							"name": "ssCoverCodPkeyCache"
						}
					],
					"transformations": [
						{
							"name": "flowlet1",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "select1"
						},
						{
							"name": "surrogateKey1"
						},
						{
							"name": "derivedColumn1"
						}
					],
					"scriptLines": [
						"parameters{",
						"     policyPrefix as string ('CFA')",
						"}",
						"source(output(",
						"          Policy as string,",
						"          Policy_Sequence as string,",
						"          ARICLOB as string,",
						"          ARICGroupCode as string,",
						"          Description as string,",
						"          Product as string,",
						"          ARICCoverageCode as string,",
						"          ARICCoverageDescription as string,",
						"          EndorsementNumber as integer,",
						"          LocationNumber as string,",
						"          LocationUnitNumber as string,",
						"          BuildingNumber as string,",
						"          LocationName as string,",
						"          LocationAddress1 as string,",
						"          LocationAddress2 as string,",
						"          LocationAddress3 as string,",
						"          Occupancy as string,",
						"          LocationCity as string,",
						"          LocationZipCode as string,",
						"          LocationCounty as string,",
						"          Territory as string,",
						"          ConstructionCode as string,",
						"          ConstructionYear as integer,",
						"          NumberOfFloors as integer,",
						"          ProtectionClass as string,",
						"          GEOLatitude as decimal(11,8),",
						"          GEOLongitude as decimal(11,8),",
						"          CauseOfLoss as string,",
						"          BCEGClassCode as string,",
						"          CoverageForm as string,",
						"          DesignatedPremisis as string,",
						"          WindIndicatorFlag as string,",
						"          PurchaseCost as decimal(8,2),",
						"          dbo as string,",
						"          CoInsuranceBuilding as integer,",
						"          CoInsurancePersonalProperty as integer,",
						"          CoInsuranceBodilyInjury as integer,",
						"          CountryCode as string,",
						"          MunicipalityCode as string,",
						"          ParkName as string,",
						"          CountyCode as integer,",
						"          NumberParkSpaces as integer,",
						"          NumberOfAcres as integer,",
						"          OwnOrRent as string,",
						"          ResidenceTypeCode as string,",
						"          LocationZone as string,",
						"          ARICCoverageSequence as integer,",
						"          CoveragePart as string,",
						"          CoverageAddDate as timestamp,",
						"          CoverageDescription as string,",
						"          ISOClassCode as string,",
						"          RetroEndorsementNumber as integer,",
						"          PolicyPrefix as string,",
						"          EffectiveDate as timestamp,",
						"          Policy_Accounting_date as timestamp,",
						"          ExpirationDate as timestamp,",
						"          CancelDate as timestamp,",
						"          CancelReason as string,",
						"          CancelReasonDescription as string,",
						"          PolicyTermMonths as integer,",
						"          InsuredName as string,",
						"          InsuredAddress1 as string,",
						"          InsuredAddress2 as string,",
						"          InsuredCity as string,",
						"          InsuredState as string,",
						"          InsuredZipCode as string,",
						"          CompanyCode as string,",
						"          CompanyName as string,",
						"          GroupName as string,",
						"          GBLICompanyCode as string,",
						"          AgentCode as string,",
						"          AgentName as string,",
						"          AgentOffice as string,",
						"          GroupCode as string,",
						"          AgentCity as string,",
						"          EMail as string,",
						"          AgentPhone as string,",
						"          AgentCounty as string,",
						"          AgentZipCode as string,",
						"          AgentAddress1 as string,",
						"          AgentAddress2 as string,",
						"          AgentState as string,",
						"          SubProducerNumber as string,",
						"          SubProducerCode as string,",
						"          SubProducerName as string,",
						"          SubproducerState as string,",
						"          SubProducerType as string,",
						"          ProductCode as string,",
						"          ProductCodeDescription as string,",
						"          PreviousPolicy as string,",
						"          OriginalPolicyYear as integer,",
						"          NonRenewalReason as string,",
						"          NonRenewalNoticeDate as timestamp,",
						"          DatabaseCode as string,",
						"          Policy_ID as integer,",
						"          MinimumPremium as decimal(13,0),",
						"          POlicy_Receive_date as timestamp,",
						"          MasterPolicy as string,",
						"          BillingType as string,",
						"          RowStatus as string,",
						"          OriginalInceptionDate as timestamp,",
						"          MultiplePolicyFlag as string,",
						"          ARICBusinessUnit as string,",
						"          HonorCurrentRateFlag as string,",
						"          FarmType as string,",
						"          PrimaryPremiumStateCode as string,",
						"          StateName as string,",
						"          Policy_Insert_Date as date,",
						"          BillingSystem as string,",
						"          Cov_effective_Date as timestamp,",
						"          Cov_Expiry_Date as timestamp,",
						"          ReceivedDate as date,",
						"          CoverageArrayNumber as integer,",
						"          LiabilityFlag as string,",
						"          ExperienceModFactor as decimal(7,4),",
						"          Exposure as decimal(8,0),",
						"          TaxFeeSurchargeFlag as string,",
						"          CancelReinstateFlag as string,",
						"          ReleasedFlag as string,",
						"          ReleaseDate as date,",
						"          Rate as decimal(12,6),",
						"          PremiumStateCode as string,",
						"          Coverage_ID as integer,",
						"          Coverage_accounting_date as timestamp,",
						"          Coverage_Insert_Date as date",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"SELECT distinct ARICCoverageCode,ARICCoverageDescription FROM [DataStoreARICECM].[dbo].[Policy_Coverage] where PolicyPrefix ='{$policyPrefix}'\"),",
						"     format: 'query') ~> policyCoverageSource",
						"source(output(",
						"          cid as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select MAX(COVERAGE_CODE_ID) as cid from POL_COVERAGE_CODE',",
						"     format: 'query') ~> pkey",
						"derivedColumn1 compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet1@(output1)",
						"policyCoverageSource select(mapColumn(",
						"          COVERAGE_CODE = ARICCoverageCode,",
						"          COVERAGE_DESCRIPTION = ARICCoverageDescription",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"select1 keyGenerate(output(skey as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> surrogateKey1",
						"surrogateKey1 derive(COVERAGE_CODE_ID = skey + ssCoverCodPkeyCache#outputs()[1].cid) ~> derivedColumn1",
						"flowlet1@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          COVERAGE_CODE_ID as long,",
						"          COVERAGE_CODE as string,",
						"          COVERAGE_DESCRIPTION as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> coverageCodeStaging",
						"pkey sink(validateSchema: false,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     store: 'cache',",
						"     format: 'inline',",
						"     output: false,",
						"     saveOrder: 1) ~> ssCoverCodPkeyCache"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_source_coverageExt')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Source Stage Data Flows/txnDataFlow"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_coverage",
								"type": "DatasetReference"
							},
							"name": "coverageStaging"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policy",
								"type": "DatasetReference"
							},
							"name": "policyStaging"
						},
						{
							"dataset": {
								"referenceName": "ds_source_policyCoverage",
								"type": "DatasetReference"
							},
							"name": "policySource"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_coverageExt",
								"type": "DatasetReference"
							},
							"name": "coverageExtStaging"
						}
					],
					"transformations": [
						{
							"name": "select1"
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "sourcePolicyCoveragelookup"
						},
						{
							"name": "policyStagingSelect"
						},
						{
							"name": "policyCoverageMapping"
						},
						{
							"name": "policySourceSelect"
						},
						{
							"name": "stagingCoveragePolicyJoin"
						}
					],
					"scriptLines": [
						"parameters{",
						"     policyPrefix as string ('CFA'),",
						"     policies as string[]",
						"}",
						"source(output(",
						"          COVERAGE_ID as long,",
						"          COVERAGE_VID as long,",
						"          COVERAGE_CODE_ID as long,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          COV_STATE_ID as long,",
						"          COVERAGE_EFFECTIVE_DATE as timestamp,",
						"          COVERAGE_EXPIRATION_DATE as timestamp,",
						"          ASL_CODE as string,",
						"          ASSL_CODE as string,",
						"          ASL_CODE_GBL as string,",
						"          ASSL_CODE_GBL as string,",
						"          CLASSIFICATION_CODE_ID as long,",
						"          CLASSIFICATION_CODE_OVID as long,",
						"          COVERAGE_CODE as string,",
						"          RETROACTIVE_DATE as timestamp,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select * from [DM_Source_Stage].[dbo].[POL_COVERAGE] ',",
						"     format: 'query') ~> coverageStaging",
						"source(output(",
						"          POLICY_ID as long,",
						"          POLICY_VID as long,",
						"          REINSURANCE_DAC as string,",
						"          PREVIOUS_INSURANCE_NO_REMARKS as string,",
						"          AGENCY_ID as long,",
						"          AGENCY_OVID as long,",
						"          PRODUCER_ID as long,",
						"          PRODUCER_OVID as long,",
						"          PRODUCER_CONTACT_ID as long,",
						"          PRODUCER_CONTACT_OVID as long,",
						"          POLICY_NUMBER as string,",
						"          ENTITY_TYPE as string,",
						"          ENTITY_STATUS as string,",
						"          IS_RENEWAL_YN as string,",
						"          REVISION_NUMBER as integer,",
						"          PRODUCT_ID as long,",
						"          PRODUCT_OVID as long,",
						"          POLICY_EFFECTIVE_DATE as timestamp,",
						"          POLICY_EXPIRATION_DATE as timestamp,",
						"          NON_RENEWAL_CODE as string,",
						"          POLICY_RENEWED_YN as string,",
						"          CANCELLATION_DATE as timestamp,",
						"          IS_RENEWABLE_YN as string,",
						"          PREVIOUS_INSURANCE_NO_REASON as string,",
						"          POLICY_STATUS as string,",
						"          CANCEL_REASON_CODE as string,",
						"          CANCEL_REASON_DESCRIPTION as string,",
						"          CANCEL_METHOD as string,",
						"          CANCEL_METHOD_DESC as string,",
						"          LOSE_REASON_CODE as string,",
						"          LOSE_REASON_DESC as string,",
						"          DECLINATION_REASON_CODE as string,",
						"          DECLINATION_REASON_DESC as string,",
						"          NOT_WRITTEN_REASON_CODE as string,",
						"          NOT_WRITTEN_REASON_DESC as string,",
						"          POLICY_STATE_CODE as string,",
						"          PROGRAM_ID as long,",
						"          PROGRAM_OVID as long,",
						"          BILLING_TYPE_CODE as string,",
						"          UNDERWRITING_COMPANY_ID as long,",
						"          UNDERWRITING_COMPANY_OVID as long,",
						"          SUBMISSION_ID as long,",
						"          PREVIOUS_INSURANCE_YN as string,",
						"          LEGACY_POLICY_NUMBER as string,",
						"          STATE as string,",
						"          POLICY_POLICY as integer,",
						"          PAYMENT_PLAN as string,",
						"          APPLICATION_RECEIVED_DATE as timestamp,",
						"          INCEPTION_DATE as timestamp,",
						"          BILL_TYPE as string,",
						"          FORMS_LANGUAGE as string,",
						"          BASE_CURRENCY as string,",
						"          INVOICE_CURRENCY as string,",
						"          PREVIOUS_POLICY_ID as long,",
						"          PREVIOUS_POLICY_OVID as long,",
						"          REVISED_FROM_POLICY_ID as long,",
						"          REVISED_FROM_POLICY_OVID as long,",
						"          OPERATING_COMPANY_ID as long,",
						"          OPERATING_COMPANY_OVID as long,",
						"          CONVERTED_FROM_ID as long,",
						"          CONVERTED_FROM_OVID as long,",
						"          INSTALLMENT_RENEWAL as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from [dbo].[POL_POLICY] where ENTITY_TYPE ='{$policyPrefix}' \"+iif(size($policies) >0&& size($policies) ==1&&$policies[1] =='','','and policy_number in ('+dropLeft(toString(reduce($policies, \"'\", #acc + \",'\" + #item +\"'\", #result)), 2)+')')),",
						"     format: 'query') ~> policyStaging",
						"source(output(",
						"          Policy as string,",
						"          Policy_Sequence as string,",
						"          ARICLOB as string,",
						"          ARICGroupCode as string,",
						"          Description as string,",
						"          Product as string,",
						"          ARICCoverageCode as string,",
						"          ARICCoverageDescription as string,",
						"          EndorsementNumber as short,",
						"          LocationNumber as string,",
						"          LocationUnitNumber as string,",
						"          BuildingNumber as string,",
						"          LocationName as string,",
						"          LocationAddress1 as string,",
						"          LocationAddress2 as string,",
						"          LocationAddress3 as string,",
						"          Occupancy as string,",
						"          LocationCity as string,",
						"          LocationZipCode as string,",
						"          LocationCounty as string,",
						"          Territory as string,",
						"          ConstructionCode as string,",
						"          ConstructionYear as integer,",
						"          NumberOfFloors as integer,",
						"          ProtectionClass as string,",
						"          GEOLatitude as decimal(11,8),",
						"          GEOLongitude as decimal(11,8),",
						"          CauseOfLoss as string,",
						"          BCEGClassCode as string,",
						"          CoverageForm as string,",
						"          DesignatedPremisis as string,",
						"          WindIndicatorFlag as string,",
						"          PurchaseCost as decimal(8,2),",
						"          dbo as string,",
						"          CoInsuranceBuilding as integer,",
						"          CoInsurancePersonalProperty as integer,",
						"          CoInsuranceBodilyInjury as integer,",
						"          CountryCode as string,",
						"          MunicipalityCode as string,",
						"          ParkName as string,",
						"          CountyCode as short,",
						"          NumberParkSpaces as integer,",
						"          NumberOfAcres as integer,",
						"          OwnOrRent as string,",
						"          ResidenceTypeCode as string,",
						"          LocationZone as string,",
						"          ARICCoverageSequence as integer,",
						"          CoveragePart as string,",
						"          CoverageAddDate as timestamp,",
						"          CoverageDescription as string,",
						"          CoverageInternalCode as string,",
						"          CoverageAbbreviation as string,",
						"          CoveragePartSequence as integer,",
						"          CoverageISOLine as integer,",
						"          CoverageCATCode as string,",
						"          CoverageLine4 as integer,",
						"          CoverageAddUser as string,",
						"          CoverageUpdateDate as timestamp,",
						"          CoverageUpdateUser as string,",
						"          CoverageLineFlag as string,",
						"          LocationState as string,",
						"          ISOClassCode as string,",
						"          RetroEndorsementNumber as integer,",
						"          PolicyPrefix as string,",
						"          EffectiveDate as timestamp,",
						"          Policy_Accounting_date as timestamp,",
						"          ExpirationDate as timestamp,",
						"          CancelDate as timestamp,",
						"          CancelReason as string,",
						"          CancelReasonDescription as string,",
						"          PolicyTermMonths as integer,",
						"          InsuredName as string,",
						"          InsuredAddress1 as string,",
						"          InsuredAddress2 as string,",
						"          InsuredCity as string,",
						"          InsuredState as string,",
						"          InsuredZipCode as string,",
						"          CompanyCode as string,",
						"          CompanyName as string,",
						"          GroupName as string,",
						"          GBLICompanyCode as string,",
						"          AgentCode as string,",
						"          AgentName as string,",
						"          AgentOffice as string,",
						"          GroupCode as string,",
						"          AgentCity as string,",
						"          EMail as string,",
						"          AgentPhone as string,",
						"          AgentCounty as string,",
						"          AgentZipCode as string,",
						"          AgentAddress1 as string,",
						"          AgentAddress2 as string,",
						"          AgentState as string,",
						"          SubProducerNumber as string,",
						"          SubProducerCode as string,",
						"          SubProducerName as string,",
						"          SubproducerState as string,",
						"          SubProducerType as string,",
						"          ProductCode as string,",
						"          ProductCodeDescription as string,",
						"          PreviousPolicy as string,",
						"          OriginalPolicyYear as integer,",
						"          NonRenewalReason as string,",
						"          NonRenewalNoticeDate as timestamp,",
						"          DatabaseCode as string,",
						"          Policy_ID as integer,",
						"          MinimumPremium as decimal(13,0),",
						"          POlicy_Receive_date as timestamp,",
						"          MasterPolicy as string,",
						"          BillingType as string,",
						"          RowStatus as string,",
						"          OriginalInceptionDate as timestamp,",
						"          MultiplePolicyFlag as string,",
						"          ARICBusinessUnit as string,",
						"          HonorCurrentRateFlag as string,",
						"          FarmType as string,",
						"          PrimaryPremiumStateCode as string,",
						"          StateName as string,",
						"          Policy_Insert_Date as date,",
						"          BillingSystem as string,",
						"          Cov_effective_Date as timestamp,",
						"          Cov_Expiry_Date as timestamp,",
						"          ReceivedDate as date,",
						"          CoverageArrayNumber as short,",
						"          LiabilityFlag as string,",
						"          ExperienceModFactor as decimal(7,4),",
						"          Exposure as decimal(8,0),",
						"          TaxFeeSurchargeFlag as string,",
						"          CancelReinstateFlag as string,",
						"          ReleasedFlag as string,",
						"          ReleaseDate as date,",
						"          Rate as decimal(12,6),",
						"          PremiumStateCode as string,",
						"          Coverage_ID as integer,",
						"          Coverage_accounting_date as timestamp,",
						"          Coverage_Insert_Date as date",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from [dbo].[Policy_Coverage] where PolicyPrefix = '{$policyPrefix}'\"+iif(size($policies) >0&& size($policies) ==1&&$policies[1] =='','','and policy in ('+dropLeft(toString(reduce($policies, \"'\", #acc + \",'\" + #item +\"'\", #result)), 2)+')')),",
						"     format: 'query') ~> policySource",
						"coverageStaging select(mapColumn(",
						"          COVERAGE_ID,",
						"          COVERAGE_CODE_ID,",
						"          POLICY_ID,",
						"          COVERAGE_EFFECTIVE_DATE,",
						"          COVERAGE_EXPIRATION_DATE,",
						"          COVERAGE_CODE,",
						"          COVERAGE_VID",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"stagingCoveragePolicyJoin derive(aricGrpCode = split(COVERAGE_CODE,'-')[1],",
						"          pimarypremiumstate = split(COVERAGE_CODE,'-')[2],",
						"          aricLob = split(COVERAGE_CODE,'-')[3],",
						"          aricCoverageCode = split(COVERAGE_CODE,'-')[4],",
						"          Ariccoveragecodesequnce = toString(split(COVERAGE_CODE,'-')[5]),",
						"          POLICY_NUMBER = POLICY_NUMBER) ~> derivedColumn1",
						"derivedColumn1, policySourceSelect lookup(POLICY_NUMBER == Policy",
						"     && aricGrpCode == ARICGroupCode",
						"     && pimarypremiumstate == PrimaryPremiumStateCode",
						"     && derivedColumn1@aricCoverageCode == policySourceSelect@ARICCoverageCode",
						"     && Ariccoveragecodesequnce == toString(ARICCoverageSequence),",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> sourcePolicyCoveragelookup",
						"policyStaging select(mapColumn(",
						"          POLICY_ID,",
						"          POLICY_VID,",
						"          POLICY_NUMBER",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> policyStagingSelect",
						"sourcePolicyCoveragelookup derive(COVERAGE_ID = select1@COVERAGE_ID,",
						"          COVERAGE_VID = COVERAGE_VID,",
						"          AricCoverageSequence = Ariccoveragecodesequnce,",
						"          AricGroupCode = ARICGroupCode,",
						"          CoverageDescription = CoverageDescription,",
						"          ARICLOB = policySourceSelect@ARICLOB,",
						"          CoverageInternalCode = CoverageInternalCode,",
						"          CoverageAbbreviation = CoverageAbbreviation,",
						"          CoverageArrayNumber = CoverageArrayNumber,",
						"          CoveragePart = CoveragePart,",
						"          CoverageISOLine = CoverageISOLine,",
						"          CoverageCATCode = CoverageCATCode) ~> policyCoverageMapping",
						"policySource select(skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> policySourceSelect",
						"select1, policyStagingSelect join(select1@POLICY_ID == policyStagingSelect@POLICY_ID,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> stagingCoveragePolicyJoin",
						"policyCoverageMapping sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          COVERAGE_ID as long,",
						"          COVERAGE_VID as long,",
						"          ARICCoverageSequence as integer,",
						"          ARICTaxFeeSurchargeFlag as string,",
						"          PropertyOrCasualty as string,",
						"          ARICGroupCode as string,",
						"          LocationState as string,",
						"          ARICLOB as string,",
						"          CoverageInternalCode as string,",
						"          CoverageAbbreviation as string,",
						"          CoverageDescription as string,",
						"          CoverageArrayNumber as integer,",
						"          CoveragePartSequence as integer,",
						"          CoveragePart as string,",
						"          CoverageISOLine as integer,",
						"          CoverageCATCode as string,",
						"          CoverageFullyEarned as string,",
						"          LiabilityFlag as string,",
						"          CoverageLine4 as integer,",
						"          CoverageEffectiveDate as timestamp,",
						"          CoverageExpirationDate as timestamp,",
						"          CoverageAddDate as timestamp,",
						"          CoverageAddUser as string,",
						"          CoverageUpdateDate as timestamp,",
						"          CoverageUpdateUser as string,",
						"          CoverageLineFlag as string,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> coverageExtStaging"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_source_empInsObj')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Source Stage Data Flows/txnDataFlow"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRisk",
								"type": "DatasetReference"
							},
							"name": "StagingPolicyRisk"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policy",
								"type": "DatasetReference"
							},
							"name": "StagingPolicy"
						},
						{
							"dataset": {
								"referenceName": "ds_source_propertyUnits",
								"type": "DatasetReference"
							},
							"name": "EcmPropertyUnits"
						},
						{
							"dataset": {
								"referenceName": "ds_source_propertyUnits",
								"type": "DatasetReference"
							},
							"name": "ecmWithLimits"
						},
						{
							"dataset": {
								"referenceName": "joinTableStageSQL",
								"type": "DatasetReference"
							},
							"name": "sourceRefLookUp"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "StagingPolicyRiskTypeBreed"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "StagingPolicyRiskTypeName"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "StagingPolicyRiskTypeSex"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "StagingPolicyRiskTypePurchaseDate"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "StagingPolicyRiskTypeMortality"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "StagingPolicyRiskTypeUse"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "StagingPolicyRiskTypePrice"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "StagingPolicyRiskTypeYearBorn"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "StagingPolicyRiskTypeRequestedLimit"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRiskDetails",
								"type": "DatasetReference"
							},
							"name": "StagingPolicyRiskTypeAge"
						}
					],
					"transformations": [
						{
							"name": "flowlet1",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet2",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet3",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet4",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet5",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet6",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet7",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet8",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet9",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet10",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "filter1"
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "horseBreed"
						},
						{
							"name": "horseSex"
						},
						{
							"name": "lookup1"
						},
						{
							"name": "use"
						},
						{
							"name": "mortality"
						},
						{
							"name": "purchaseDate"
						},
						{
							"name": "purchasePrcie"
						},
						{
							"name": "yearBorn"
						},
						{
							"name": "requestedLimit"
						},
						{
							"name": "ageInYears"
						},
						{
							"name": "lookup2"
						},
						{
							"name": "derivedColumn2"
						},
						{
							"name": "lookup3"
						},
						{
							"name": "derivedColumn3"
						},
						{
							"name": "select1"
						},
						{
							"name": "join1"
						}
					],
					"scriptLines": [
						"parameters{",
						"     policyPrefix as string (\"\"),",
						"     policies as string[] ([''])",
						"}",
						"source(output(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_NUMBER as string,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          RISK_IS_ACTIVE_YN as string,",
						"          RISK_EFF_DATE as timestamp,",
						"          RISK_EXP_DATE as timestamp,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> StagingPolicyRisk",
						"source(output(",
						"          POLICY_ID as long,",
						"          POLICY_VID as long,",
						"          REINSURANCE_DAC as string,",
						"          PREVIOUS_INSURANCE_NO_REMARKS as string,",
						"          AGENCY_ID as long,",
						"          AGENCY_OVID as long,",
						"          PRODUCER_ID as long,",
						"          PRODUCER_OVID as long,",
						"          PRODUCER_CONTACT_ID as long,",
						"          PRODUCER_CONTACT_OVID as long,",
						"          POLICY_NUMBER as string,",
						"          ENTITY_TYPE as string,",
						"          ENTITY_STATUS as string,",
						"          IS_RENEWAL_YN as string,",
						"          REVISION_NUMBER as integer,",
						"          PRODUCT_ID as long,",
						"          PRODUCT_OVID as long,",
						"          POLICY_EFFECTIVE_DATE as timestamp,",
						"          POLICY_EXPIRATION_DATE as timestamp,",
						"          NON_RENEWAL_CODE as string,",
						"          POLICY_RENEWED_YN as string,",
						"          CANCELLATION_DATE as timestamp,",
						"          IS_RENEWABLE_YN as string,",
						"          PREVIOUS_INSURANCE_NO_REASON as string,",
						"          POLICY_STATUS as string,",
						"          CANCEL_REASON_CODE as string,",
						"          CANCEL_REASON_DESCRIPTION as string,",
						"          CANCEL_METHOD as string,",
						"          CANCEL_METHOD_DESC as string,",
						"          LOSE_REASON_CODE as string,",
						"          LOSE_REASON_DESC as string,",
						"          DECLINATION_REASON_CODE as string,",
						"          DECLINATION_REASON_DESC as string,",
						"          NOT_WRITTEN_REASON_CODE as string,",
						"          NOT_WRITTEN_REASON_DESC as string,",
						"          POLICY_STATE_CODE as string,",
						"          PROGRAM_ID as long,",
						"          PROGRAM_OVID as long,",
						"          BILLING_TYPE_CODE as string,",
						"          UNDERWRITING_COMPANY_ID as long,",
						"          UNDERWRITING_COMPANY_OVID as long,",
						"          SUBMISSION_ID as long,",
						"          PREVIOUS_INSURANCE_YN as string,",
						"          LEGACY_POLICY_NUMBER as string,",
						"          STATE as string,",
						"          POLICY_POLICY as integer,",
						"          PAYMENT_PLAN as string,",
						"          APPLICATION_RECEIVED_DATE as timestamp,",
						"          INCEPTION_DATE as timestamp,",
						"          BILL_TYPE as string,",
						"          FORMS_LANGUAGE as string,",
						"          BASE_CURRENCY as string,",
						"          INVOICE_CURRENCY as string,",
						"          PREVIOUS_POLICY_ID as long,",
						"          PREVIOUS_POLICY_OVID as long,",
						"          REVISED_FROM_POLICY_ID as long,",
						"          REVISED_FROM_POLICY_OVID as long,",
						"          OPERATING_COMPANY_ID as long,",
						"          OPERATING_COMPANY_OVID as long,",
						"          CONVERTED_FROM_ID as long,",
						"          CONVERTED_FROM_OVID as long,",
						"          INSTALLMENT_RENEWAL as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from POL_POLICY where policy_number like '{$policyPrefix}%'\"+iif(size($policies) >0&& size($policies) ==1&&$policies[1] =='','','and policy_number in ('+dropLeft(toString(reduce($policies, \"'\", #acc + \",'\" + #item +\"'\", #result)), 2)+')')),",
						"     format: 'query') ~> StagingPolicy",
						"source(output(",
						"          PolicyPrefix as string,",
						"          Policy as string,",
						"          Policy_Sequence as string,",
						"          RowStatus as string,",
						"          EffectiveDate as timestamp,",
						"          ExpirationDate as timestamp,",
						"          LocationNumber as string,",
						"          LocationUnitNumber as string,",
						"          {UnitType/ModificationType} as string,",
						"          YearBuild as integer,",
						"          UnitValue as decimal(13,0),",
						"          SquareFootage as integer,",
						"          RiskUseCode as string,",
						"          Occupancy as string,",
						"          RoofTypeCode as string,",
						"          RoofYear as integer,",
						"          Make as string,",
						"          Model as string,",
						"          SerialNumber as string,",
						"          UnitWidth as integer,",
						"          RiskType as string,",
						"          UnitLength as integer,",
						"          PurchasePrice as decimal(9,0),",
						"          PurchaseDate as timestamp,",
						"          NewUsed as string,",
						"          ProtectionClass as string,",
						"          NumberOfSections as decimal(1,0),",
						"          AppraisalYear as integer,",
						"          AppraisedValue as decimal(9,0),",
						"          ConstructionTypeCode as string,",
						"          ParkCode as string,",
						"          OrdinanceLawPercent as decimal(5,2),",
						"          PropertyLossScore as string,",
						"          ProtectedRiskFlag as string,",
						"          PreferredRiskFlag as string,",
						"          ReplaceOrFullRepair as string,",
						"          MineSubsidenceFlag as string,",
						"          NumberOfStories as decimal(3,0),",
						"          InZoneFlag as string,",
						"          BasicFlag as string,",
						"          DwellingUnits as string,",
						"          ElectricSystemTypeCode as string,",
						"          PlumbingSystemTypeCode as string,",
						"          ExtentOfRoofUpdateCode as string,",
						"          ElectricSystemYear as integer,",
						"          ExtentOfElectricSystemUpdate as string,",
						"          PlumbingSystemYear as integer,",
						"          ExtentOfPlumbingSystemUpdate as string,",
						"          HeatingSystemYear as integer,",
						"          ExtentOfHeatingSystemUpdate as string,",
						"          MilesToFireDepartmentCode as string,",
						"          FeetToHydrantCode as string,",
						"          UnitDescription as string,",
						"          InflationGuardPercent as decimal(6,3),",
						"          NumberOfHouseholds as integer,",
						"          AnimalUseCode as string,",
						"          AnimalOtherUse as string,",
						"          LeaseFlag as string,",
						"          ID as integer,",
						"          DataSource as string,",
						"          FirelineScore as string,",
						"          FirelineStatus as string,",
						"          FirelineDate as timestamp,",
						"          AnimalDOB as timestamp,",
						"          AnimalName as string,",
						"          AnimalBreed as string,",
						"          AnimalBreedOtherDescription as string,",
						"          AnimalSireName as string,",
						"          AnimalDamName as string,",
						"          AnimalSex as string,",
						"          DW_InsertDate as date,",
						"          CoveragePart as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from [dbo].[PolicyPropertyUnit_P]  where TRIM(AnimalUseCode) != '?' and TRIM(RowStatus) != 'D' and (TRIM(AnimalBreed) != '' or TRIM(AnimalUseCode) != '') and PolicyPrefix='{$policyPrefix}'\"+iif(size($policies) >0&& size($policies) ==1&&$policies[1] =='','','and policy in ('+dropLeft(toString(reduce($policies, \"'\", #acc + \",'\" + #item +\"'\", #result)), 2)+')')),",
						"     format: 'query') ~> EcmPropertyUnits",
						"source(output(",
						"          Policy as string,",
						"          PolicyPrefix as string,",
						"          LocationNumber as string,",
						"          LocationUnitNumber as string,",
						"          ARICCoverageSequence as integer,",
						"          CoverageDescription as string,",
						"          Limit1 as decimal(38,0)",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: ' select eq.Policy,eq.PolicyPrefix,\\n      eq.LocationNumber,eq.LocationUnitNumber,fcp.ARICCoverageSequence,fcp.CoverageDescription,fcp.Limit1 from PolicyPropertyUnit_P eq \\n      join  Fact_Coverage_Premium  \\n      fcp \\n      on eq.Policy = fcp.Policy \\n      and eq.LocationNumber=fcp.LocationNumber and eq.LocationUnitNumber=fcp.LocationUnitNumber\\n      where eq.PolicyPrefix = \\'EMP\\' and ( ARICCoverageSequence=1 or ARICCoverageSequence=2) ',",
						"     format: 'query') ~> ecmWithLimits",
						"source(output(",
						"          LOOKUP_CODE as string,",
						"          LOOKUP_DESCRIPTION as string,",
						"          LOOKUP_TYPE_ID as long,",
						"          LOOKUP_TYPE_DOMAIN as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select rl.LOOKUP_CODE, rl.LOOKUP_DESCRIPTION, rlt.LOOKUP_TYPE_ID, rlt.LOOKUP_TYPE_DOMAIN from REF_LOOKUP rl join REF_LOOKUP_TYPE rlt on rl.LOOKUP_TYPE_ID = rlt.LOOKUP_TYPE_ID where rlt.LOOKUP_TYPE_ID = 1',",
						"     format: 'query') ~> sourceRefLookUp",
						"derivedColumn1 compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet1@(output1)",
						"horseBreed compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet2@(output1)",
						"horseSex compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet3@(output1)",
						"use compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet4@(output1)",
						"purchaseDate compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet5@(output1)",
						"derivedColumn2 compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet6@(output1)",
						"derivedColumn3 compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet7@(output1)",
						"yearBorn compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet8@(output1)",
						"purchasePrcie compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet9@(output1)",
						"ageInYears compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet10@(output1)",
						"lookup1 filter(not(isNull(POLICY_NUMBER))) ~> filter1",
						"filter1 derive(RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = RISK_CODE,",
						"          ATTRIBUTE_NAME = \"horseName\",",
						"          ATTRIBUTE_VALUE = AnimalName) ~> derivedColumn1",
						"filter1 derive(RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = AnimalUseCode,",
						"          ATTRIBUTE_NAME = 'horseBreed',",
						"          ATTRIBUTE_VALUE = AnimalBreed) ~> horseBreed",
						"filter1 derive(RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISKCODE = RiskUseCode,",
						"          ATTRIBUTE_NAME = \"horseSex\",",
						"          ATTRIBUTE_VALUE = AnimalSex) ~> horseSex",
						"join1, EcmPropertyUnits lookup(POLICY_NUMBER == Policy",
						"     && split(RISK_NUMBER,'-')[1] == LocationNumber",
						"     && split(RISK_NUMBER,'-')[2] == LocationUnitNumber,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lookup1",
						"filter1 derive(RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = '',",
						"          ATTRIBUTE_NAME = 'use',",
						"          ATTRIBUTE_VALUE = AnimalUseCode) ~> use",
						"filter1 derive(RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = '',",
						"          ATTRIBUTE_NAME = 'mortality') ~> mortality",
						"filter1 derive(RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = '',",
						"          ATTRIBUTE_NAME = 'purchaseDate',",
						"          ATTRIBUTE_VALUE = iif(isNull(PurchaseDate), '', toString(year(PurchaseDate)))) ~> purchaseDate",
						"filter1 derive(RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = '',",
						"          ATTRIBUTE_NAME = 'purchasePrice',",
						"          ATTRIBUTE_VALUE = toString(PurchasePrice)) ~> purchasePrcie",
						"filter1 derive(RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = '',",
						"          ATTRIBUTE_NAME = 'yearBorn',",
						"          ATTRIBUTE_VALUE = iif(isNull(AnimalDOB), '', toString(year(AnimalDOB)))) ~> yearBorn",
						"filter1 derive(RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = '',",
						"          ATTRIBUTE_NAME = 'requestedLimit') ~> requestedLimit",
						"filter1 derive(RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_CODE = \"\",",
						"          ATTRIBUTE_NAME = \"ageInYears\",",
						"          ATTRIBUTE_VALUE = iif(isNull(AnimalDOB), '', toString(year(currentDate()) - year(AnimalDOB)))) ~> ageInYears",
						"mortality, ecmWithLimits lookup(EcmPropertyUnits@Policy == ecmWithLimits@Policy",
						"     && EcmPropertyUnits@LocationNumber == ecmWithLimits@LocationNumber",
						"     && EcmPropertyUnits@LocationUnitNumber == ecmWithLimits@LocationUnitNumber,",
						"     multiple: false,",
						"     pickup: 'first',",
						"     asc(ecmWithLimits@Policy, true),",
						"     broadcast: 'auto')~> lookup2",
						"lookup2 derive(ATTRIBUTE_VALUE = iif(ARICCoverageSequence==1, 'MO01', 'MO02')) ~> derivedColumn2",
						"select1, ecmWithLimits lookup(POLICY_NUMBER == Policy",
						"     && split(RISK_NUMBER,'-')[1] == LocationNumber",
						"     && split(RISK_NUMBER,'-')[2] == LocationUnitNumber,",
						"     multiple: false,",
						"     pickup: 'first',",
						"     asc(ecmWithLimits@Policy, true),",
						"     broadcast: 'auto')~> lookup3",
						"lookup3 derive(ATTRIBUTE_VALUE = Limit1) ~> derivedColumn3",
						"requestedLimit select(mapColumn(",
						"          RISK_ID,",
						"          RISK_VID,",
						"          RISK_TYPE_CD,",
						"          POLICY_NUMBER,",
						"          RISK_NUMBER,",
						"          RISK_CODE,",
						"          ATTRIBUTE_NAME",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"StagingPolicyRisk, StagingPolicy join(StagingPolicyRisk@POLICY_ID == StagingPolicy@POLICY_ID,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"flowlet1@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> StagingPolicyRiskTypeBreed",
						"flowlet2@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> StagingPolicyRiskTypeName",
						"flowlet3@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> StagingPolicyRiskTypeSex",
						"flowlet5@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> StagingPolicyRiskTypePurchaseDate",
						"flowlet6@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> StagingPolicyRiskTypeMortality",
						"flowlet4@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> StagingPolicyRiskTypeUse",
						"flowlet9@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> StagingPolicyRiskTypePrice",
						"flowlet8@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> StagingPolicyRiskTypeYearBorn",
						"flowlet7@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> StagingPolicyRiskTypeRequestedLimit",
						"flowlet10@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          ATTRIBUTE_NAME as string,",
						"          ATTRIBUTE_VALUE as string,",
						"          SORT_ORDER as integer,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> StagingPolicyRiskTypeAge"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_source_emp_lookupType')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Source Stage Data Flows/lookupDataFlow"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_stage__emp_riskType_excel",
								"type": "DatasetReference"
							},
							"name": "empRiskTypeCodes"
						},
						{
							"dataset": {
								"referenceName": "StgLookUpType",
								"type": "DatasetReference"
							},
							"name": "lookupTypeSource"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "StgLookUpType",
								"type": "DatasetReference"
							},
							"name": "LookUpTypeSink"
						},
						{
							"name": "lookupTypeCache"
						}
					],
					"transformations": [
						{
							"name": "flowlet1",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "derivedColumn2"
						},
						{
							"name": "surrogateKey1"
						},
						{
							"name": "aggregate1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          UNIT_TYPE as string,",
						"          RSKTYPE as string,",
						"          RISK_TYPE_CODE as string,",
						"          DIMENSION_NAME as string,",
						"          RISK_TYPE_CODE_DESC as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> empRiskTypeCodes",
						"source(output(",
						"          id as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select MAX(LOOKUP_TYPE_ID)  as id from dbo.REF_LOOKUP_TYPE',",
						"     format: 'query') ~> lookupTypeSource",
						"derivedColumn1 compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet1@(output1)",
						"surrogateKey1 derive(LOOKUP_TYPE_ID = pkey + lookupTypeCache#outputs()[1].id,",
						"          LOOKUP_TYPE_DOMAIN = DIMENSION_NAME) ~> derivedColumn1",
						"lookupTypeSource derive(id = iifNull(id, 0, id)) ~> derivedColumn2",
						"aggregate1 keyGenerate(output(pkey as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> surrogateKey1",
						"empRiskTypeCodes aggregate(groupBy(DIMENSION_NAME),",
						"     count = count(DIMENSION_NAME)) ~> aggregate1",
						"flowlet1@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          LOOKUP_TYPE_ID as long,",
						"          LOOKUP_TYPE_DOMAIN as string,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          DATA_HASH as binary,",
						"          SOURCE_KEY as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> LookUpTypeSink",
						"derivedColumn2 sink(validateSchema: false,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     store: 'cache',",
						"     format: 'inline',",
						"     output: false,",
						"     saveOrder: 1) ~> lookupTypeCache"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_source_emp_lookupTypeDetails')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Source Stage Data Flows/lookupDataFlow"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_stage__emp_riskType_excel",
								"type": "DatasetReference"
							},
							"name": "empRiskTypeCodes"
						},
						{
							"dataset": {
								"referenceName": "StgRefLookUp",
								"type": "DatasetReference"
							},
							"name": "lookupTypeSource"
						},
						{
							"dataset": {
								"referenceName": "StgLookUpType",
								"type": "DatasetReference"
							},
							"name": "lookupType"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "StgRefLookUp",
								"type": "DatasetReference"
							},
							"name": "LookUpDetailsSink"
						},
						{
							"name": "lookupTypeCache"
						}
					],
					"transformations": [
						{
							"name": "flowlet1",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "derivedColumn2"
						},
						{
							"name": "lookupByLookupType"
						},
						{
							"name": "lookupTypeSelect"
						},
						{
							"name": "select1"
						},
						{
							"name": "surrogateKey1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          UNIT_TYPE as string,",
						"          RSKTYPE as string,",
						"          RISK_TYPE_CODE as string,",
						"          DIMENSION_NAME as string,",
						"          RISK_TYPE_CODE_DESC as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> empRiskTypeCodes",
						"source(output(",
						"          LOOKUP_ID as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select MAX(LOOKUP_ID)  as LOOKUP_ID from dbo.REF_LOOKUP',",
						"     format: 'query') ~> lookupTypeSource",
						"source(output(",
						"          LOOKUP_TYPE_ID as long,",
						"          LOOKUP_TYPE_DOMAIN as string,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          DATA_HASH as binary,",
						"          SOURCE_KEY as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> lookupType",
						"select1 compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet1@(output1)",
						"surrogateKey1 derive(LOOKUP_ID = pkey + lookupTypeCache#outputs()[1].LOOKUP_ID,",
						"          LOOKUP_TYPE_ID = LOOKUP_TYPE_ID,",
						"          LOOKUP_CODE = RISK_TYPE_CODE,",
						"          LOOKUP_SHORT_DESCRIPTION = RISK_TYPE_CODE_DESC,",
						"          LOOKUP_DESCRIPTION = RISK_TYPE_CODE_DESC) ~> derivedColumn1",
						"lookupTypeSource derive(LOOKUP_ID = iifNull(LOOKUP_ID, 0, LOOKUP_ID)) ~> derivedColumn2",
						"empRiskTypeCodes, lookupType lookup(DIMENSION_NAME == LOOKUP_TYPE_DOMAIN,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lookupByLookupType",
						"lookupType select(mapColumn(",
						"          LOOKUP_TYPE_ID,",
						"          LOOKUP_TYPE_DOMAIN",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> lookupTypeSelect",
						"derivedColumn1 select(mapColumn(",
						"          LOOKUP_TYPE_ID,",
						"          LOOKUP_ID,",
						"          LOOKUP_CODE,",
						"          LOOKUP_SHORT_DESCRIPTION,",
						"          LOOKUP_DESCRIPTION",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"lookupByLookupType keyGenerate(output(pkey as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> surrogateKey1",
						"flowlet1@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          LOOKUP_ID as long,",
						"          LOOKUP_TYPE_ID as long,",
						"          LOOKUP_CODE as string,",
						"          LOOKUP_SHORT_DESCRIPTION as string,",
						"          LOOKUP_DESCRIPTION as string,",
						"          BATCH_ID as long,",
						"          DELETED_YN as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          DATA_HASH as binary,",
						"          SOURCE_KEY as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> LookUpDetailsSink",
						"derivedColumn2 sink(validateSchema: false,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     store: 'cache',",
						"     format: 'inline',",
						"     output: false,",
						"     saveOrder: 1) ~> lookupTypeCache"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_source_insuredAddressToLocation')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Source Stage Data Flows/txnDataFlow"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_insuredAddress",
								"type": "DatasetReference"
							},
							"name": "insuredAddressSource"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policy",
								"type": "DatasetReference"
							},
							"name": "policyStaging"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_genAddress",
								"type": "DatasetReference"
							},
							"name": "genAddressStaging"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_insured_location",
								"type": "DatasetReference"
							},
							"name": "insuredLocationStagingMaxId"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_insured_location",
								"type": "DatasetReference"
							},
							"name": "insuredLocationStaging"
						},
						{
							"name": "maxIdCache"
						}
					],
					"transformations": [
						{
							"name": "flowlet1",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "join1"
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "join2"
						},
						{
							"name": "derivedColumn2"
						},
						{
							"name": "select1"
						},
						{
							"name": "select2"
						},
						{
							"name": "select3"
						},
						{
							"name": "surrogateKey1"
						},
						{
							"name": "select4"
						}
					],
					"scriptLines": [
						"parameters{",
						"     policyPrefix as string,",
						"     policies as string[]",
						"}",
						"source(output(",
						"          Policy as string,",
						"          Policy_Sequence as string,",
						"          PolicyPrefix as string,",
						"          ProductCode as string,",
						"          EffectiveDate as timestamp,",
						"          ExpirationDate as timestamp,",
						"          InsuredName as string,",
						"          InsuredAddress1 as string,",
						"          InsuredAddress2 as string,",
						"          InsuredAddress3 as string,",
						"          InsuredCity as string,",
						"          InsuredState as string,",
						"          InsuredZipCode as string,",
						"          InsuredTelephone as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from [dbo].[Insured_Address] where PolicyPrefix = '{$policyPrefix}'\" +iif(size($policies) >0&& size($policies) ==1&&$policies[1] =='','','and policy in ('+dropLeft(toString(reduce($policies, \"'\", #acc + \",'\" + #item +\"'\", #result)), 2)+')')),",
						"     format: 'query') ~> insuredAddressSource",
						"source(output(",
						"          POLICY_ID as long,",
						"          POLICY_VID as long,",
						"          REINSURANCE_DAC as string,",
						"          PREVIOUS_INSURANCE_NO_REMARKS as string,",
						"          AGENCY_ID as long,",
						"          AGENCY_OVID as long,",
						"          PRODUCER_ID as long,",
						"          PRODUCER_OVID as long,",
						"          PRODUCER_CONTACT_ID as long,",
						"          PRODUCER_CONTACT_OVID as long,",
						"          POLICY_NUMBER as string,",
						"          ENTITY_TYPE as string,",
						"          ENTITY_STATUS as string,",
						"          IS_RENEWAL_YN as string,",
						"          REVISION_NUMBER as integer,",
						"          PRODUCT_ID as long,",
						"          PRODUCT_OVID as long,",
						"          POLICY_EFFECTIVE_DATE as timestamp,",
						"          POLICY_EXPIRATION_DATE as timestamp,",
						"          NON_RENEWAL_CODE as string,",
						"          POLICY_RENEWED_YN as string,",
						"          CANCELLATION_DATE as timestamp,",
						"          IS_RENEWABLE_YN as string,",
						"          PREVIOUS_INSURANCE_NO_REASON as string,",
						"          POLICY_STATUS as string,",
						"          CANCEL_REASON_CODE as string,",
						"          CANCEL_REASON_DESCRIPTION as string,",
						"          CANCEL_METHOD as string,",
						"          CANCEL_METHOD_DESC as string,",
						"          LOSE_REASON_CODE as string,",
						"          LOSE_REASON_DESC as string,",
						"          DECLINATION_REASON_CODE as string,",
						"          DECLINATION_REASON_DESC as string,",
						"          NOT_WRITTEN_REASON_CODE as string,",
						"          NOT_WRITTEN_REASON_DESC as string,",
						"          POLICY_STATE_CODE as string,",
						"          PROGRAM_ID as long,",
						"          PROGRAM_OVID as long,",
						"          BILLING_TYPE_CODE as string,",
						"          UNDERWRITING_COMPANY_ID as long,",
						"          UNDERWRITING_COMPANY_OVID as long,",
						"          SUBMISSION_ID as long,",
						"          PREVIOUS_INSURANCE_YN as string,",
						"          LEGACY_POLICY_NUMBER as string,",
						"          STATE as string,",
						"          POLICY_POLICY as integer,",
						"          PAYMENT_PLAN as string,",
						"          APPLICATION_RECEIVED_DATE as timestamp,",
						"          INCEPTION_DATE as timestamp,",
						"          BILL_TYPE as string,",
						"          FORMS_LANGUAGE as string,",
						"          BASE_CURRENCY as string,",
						"          INVOICE_CURRENCY as string,",
						"          PREVIOUS_POLICY_ID as long,",
						"          PREVIOUS_POLICY_OVID as long,",
						"          REVISED_FROM_POLICY_ID as long,",
						"          REVISED_FROM_POLICY_OVID as long,",
						"          OPERATING_COMPANY_ID as long,",
						"          OPERATING_COMPANY_OVID as long,",
						"          CONVERTED_FROM_ID as long,",
						"          CONVERTED_FROM_OVID as long,",
						"          INSTALLMENT_RENEWAL as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from [dbo].[POL_POLICY] where ENTITY_TYPE ='{$policyPrefix}'\" +iif(size($policies) >0&& size($policies) ==1&&$policies[1] =='','','and policy_number in ('+dropLeft(toString(reduce($policies, \"'\", #acc + \",'\" + #item +\"'\", #result)), 2)+')')),",
						"     format: 'query') ~> policyStaging",
						"source(output(",
						"          GEN_ADDRESS_UNIQ_ID as long,",
						"          ADDRESS_STREET1 as string,",
						"          ADDRESS_STREET2 as string,",
						"          COUNTY_CODE as string,",
						"          COUNTY as string,",
						"          ADDRESS_CITY as string,",
						"          ADD_DESCRIPTION as string,",
						"          STATE_PROVINCE_CODE as string,",
						"          POSTAL_CODE as string,",
						"          POSTAL_CODE_EXT as string,",
						"          COUNTRY_CODE as string,",
						"          SOURCE_INSERTED_ON as timestamp,",
						"          SOURCE_UPDATED_ON as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary,",
						"          TERRITORY as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> genAddressStaging",
						"source(output(",
						"          maxId as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT isnull(MAX(LOCATION_ID), 0) as maxId\\nFROM dbo.POL_INSURED_LOCATION',",
						"     format: 'query') ~> insuredLocationStagingMaxId",
						"derivedColumn2 compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet1@(output1)",
						"select1, select2 join(Policy == POLICY_NUMBER,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"join1 derive(source_key_exp = concatWS('', iif(isNull(ADDRESS_STREET1), '', replace(ADDRESS_STREET1, ' ', '')), iif(isNull(ADDRESS_STREET2), '', replace(ADDRESS_STREET2, ' ', '')), iif(isNull(ADDRESS_CITY), '', replace(ADDRESS_CITY, ' ', '')) , iif(isNull(POSTAL_CODE), '', replace(POSTAL_CODE, ' ', '')))) ~> derivedColumn1",
						"derivedColumn1, select3 join(source_key_exp == SOURCE_KEY,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join2",
						"surrogateKey1 derive(LOCATION_ID = skey + maxIdCache#outputs()[1].maxId,",
						"          LOCATION_VID = 1,",
						"          LOCATION_IS_ACTIVE_YN = \"Y\",",
						"          LOCATION_EFF_DATE = currentTimestamp(),",
						"          LOCATION_EXP_DATE = toTimestamp(\"9999-01-01 00:00:00\")) ~> derivedColumn2",
						"insuredAddressSource select(mapColumn(",
						"          Policy,",
						"          ADDRESS_STREET1 = InsuredAddress1,",
						"          ADDRESS_STREET2 = InsuredAddress2,",
						"          ADDRESS_CITY = InsuredCity,",
						"          POSTAL_CODE = InsuredZipCode",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"policyStaging select(mapColumn(",
						"          POLICY_ID,",
						"          POLICY_NUMBER",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select2",
						"genAddressStaging select(mapColumn(",
						"          GEN_ADDRESS_UNIQ_ID,",
						"          SOURCE_KEY",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select3",
						"select4 keyGenerate(output(skey as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> surrogateKey1",
						"join2 select(mapColumn(",
						"          POLICY_ID,",
						"          GEN_ADDRESS_UNIQ_ID",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select4",
						"flowlet1@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          LOCATION_ID as long,",
						"          LOCATION_VID as long,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          LOCATION_IS_ACTIVE_YN as string,",
						"          LOCATION_EFF_DATE as timestamp,",
						"          LOCATION_EXP_DATE as timestamp,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          IS_PRIMARY_LOCATION_YN as string,",
						"          IS_FALSE_ADDRESS as string,",
						"          PROTECTION_CLASS as string,",
						"          FIRE_DISTRICT_NAME as string,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          GEN_ADDRESS_UNIQ_ID as long,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> insuredLocationStaging",
						"insuredLocationStagingMaxId sink(validateSchema: false,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     store: 'cache',",
						"     format: 'inline',",
						"     output: false,",
						"     saveOrder: 1) ~> maxIdCache"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_source_insuredgenaddress')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Source Stage Data Flows/referenceDataFlow"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_insuredAddress",
								"type": "DatasetReference"
							},
							"name": "insuredAddressSource"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_genAddress",
								"type": "DatasetReference"
							},
							"name": "genAddressStagingLookup"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_genAddress",
								"type": "DatasetReference"
							},
							"name": "genAddressStaging"
						}
					],
					"transformations": [
						{
							"name": "selectRequiredAddressColumns"
						},
						{
							"name": "addressSurrogateKey"
						},
						{
							"name": "deriveSourceKey"
						},
						{
							"name": "alreadyExistsCheck"
						},
						{
							"name": "groupBySourceKey"
						}
					],
					"scriptLines": [
						"parameters{",
						"     DF_max_id as integer (1),",
						"     policyPrefix as string ('')",
						"}",
						"source(output(",
						"          Policy as string,",
						"          Policy_Sequence as string,",
						"          PolicyPrefix as string,",
						"          ProductCode as string,",
						"          EffectiveDate as timestamp,",
						"          ExpirationDate as timestamp,",
						"          InsuredName as string,",
						"          InsuredAddress1 as string,",
						"          InsuredAddress2 as string,",
						"          InsuredAddress3 as string,",
						"          InsuredCity as string,",
						"          InsuredState as string,",
						"          InsuredZipCode as string,",
						"          InsuredTelephone as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from [dbo].[Insured_Address] where PolicyPrefix = '{$policyPrefix}'\" ),",
						"     format: 'query') ~> insuredAddressSource",
						"source(output(",
						"          GEN_ADDRESS_UNIQ_ID as long,",
						"          ADDRESS_STREET1 as string,",
						"          ADDRESS_STREET2 as string,",
						"          COUNTY_CODE as string,",
						"          COUNTY as string,",
						"          ADDRESS_CITY as string,",
						"          ADD_DESCRIPTION as string,",
						"          STATE_PROVINCE_CODE as string,",
						"          POSTAL_CODE as string,",
						"          POSTAL_CODE_EXT as string,",
						"          COUNTRY_CODE as string,",
						"          SOURCE_INSERTED_ON as timestamp,",
						"          SOURCE_UPDATED_ON as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> genAddressStagingLookup",
						"insuredAddressSource select(mapColumn(",
						"          ADDRESS_STREET1 = InsuredAddress1,",
						"          ADDRESS_STREET2 = InsuredAddress2,",
						"          ADDRESS_CITY = InsuredCity,",
						"          STATE_PROVINCE_CODE = InsuredState,",
						"          POSTAL_CODE = InsuredZipCode",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectRequiredAddressColumns",
						"selectRequiredAddressColumns keyGenerate(output(skey as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> addressSurrogateKey",
						"addressSurrogateKey derive(GEN_ADDRESS_UNIQ_ID = skey + $DF_max_id,",
						"          SOURCE_KEY = concatWS('', iif(isNull(ADDRESS_STREET1), '', replace(ADDRESS_STREET1, ' ', '')), iif(isNull(ADDRESS_STREET2), '', replace(ADDRESS_STREET2, ' ', '')), iif(isNull(ADDRESS_CITY), '', replace(ADDRESS_CITY, ' ', '')) , iif(isNull(POSTAL_CODE), '', replace(POSTAL_CODE, ' ', '')))) ~> deriveSourceKey",
						"groupBySourceKey, genAddressStagingLookup exists(groupBySourceKey@SOURCE_KEY == genAddressStagingLookup@SOURCE_KEY,",
						"     negate:true,",
						"     broadcast: 'auto')~> alreadyExistsCheck",
						"deriveSourceKey aggregate(groupBy(SOURCE_KEY),",
						"     each(match(name!='SOURCE_KEY'), $$ = first($$))) ~> groupBySourceKey",
						"alreadyExistsCheck sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          GEN_ADDRESS_UNIQ_ID as long,",
						"          ADDRESS_STREET1 as string,",
						"          ADDRESS_STREET2 as string,",
						"          COUNTY_CODE as string,",
						"          COUNTY as string,",
						"          ADDRESS_CITY as string,",
						"          ADD_DESCRIPTION as string,",
						"          STATE_PROVINCE_CODE as string,",
						"          POSTAL_CODE as string,",
						"          POSTAL_CODE_EXT as string,",
						"          COUNTRY_CODE as string,",
						"          SOURCE_INSERTED_ON as timestamp,",
						"          SOURCE_UPDATED_ON as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary,",
						"          TERRITORY as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> genAddressStaging"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_source_lobcompany')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Source Stage Data Flows/referenceDataFlow"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_company",
								"type": "DatasetReference"
							},
							"name": "companySource"
						},
						{
							"dataset": {
								"referenceName": "ds_source_lob",
								"type": "DatasetReference"
							},
							"name": "lobSource"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_company",
								"type": "DatasetReference"
							},
							"name": "compnayStatgingLookup"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_lob",
								"type": "DatasetReference"
							},
							"name": "lobStagingLookup"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_company",
								"type": "DatasetReference"
							},
							"name": "companyStaging"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_lob",
								"type": "DatasetReference"
							},
							"name": "lobStaging"
						}
					],
					"transformations": [
						{
							"name": "flowlet3",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "flowlet4",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "select3"
						},
						{
							"name": "surrogateKey1"
						},
						{
							"name": "derivedColumn2"
						},
						{
							"name": "select4"
						},
						{
							"name": "surrogateKey2"
						},
						{
							"name": "derivedColumn3"
						},
						{
							"name": "select5"
						},
						{
							"name": "exists1"
						},
						{
							"name": "select6"
						},
						{
							"name": "exists2"
						}
					],
					"scriptLines": [
						"parameters{",
						"     DF_batch as integer (1),",
						"     DF_lob_max_id as integer (1),",
						"     DF_company_max_id as integer (1)",
						"}",
						"source(output(",
						"          ID as integer,",
						"          WINSCompanyID as string,",
						"          Name as string,",
						"          NAICNumber as string,",
						"          NAICGroupCode as string,",
						"          NCCICode as string,",
						"          ISOCode as string,",
						"          FEIN as string,",
						"          AddressLine1 as string,",
						"          AddressLine2 as string,",
						"          City as string,",
						"          AlphaStateCode as string,",
						"          ZipCode as string,",
						"          CreateTime as timestamp,",
						"          CreatedBy as string,",
						"          UpdateTime as timestamp,",
						"          UpdatedBy as string,",
						"          AgentUploadFlag as string,",
						"          ARICGroupCode as string,",
						"          CompanyGroup as string,",
						"          ARICDirectAssumed as string,",
						"          CompanyAbbreviation as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> companySource",
						"source(output(",
						"          ARICGroupCode as string,",
						"          ARICLineOfBusinessID as string,",
						"          ARICGroupLineDescription as string,",
						"          ARICMajorProductCode as string,",
						"          ProductCode as string,",
						"          INFCATPProduct as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> lobSource",
						"source(output(",
						"          COMPANY_ID as long,",
						"          COMPANY_VID as long,",
						"          COMPANY_CODE as string,",
						"          COMPANY_NAME as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          CORPORATE_NAME as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> compnayStatgingLookup",
						"source(output(",
						"          LOB_ID as long,",
						"          LOB_CODE as string,",
						"          LOB_NAME as string,",
						"          LOB_DESCRIPTION as string,",
						"          LOB_IS_VALID_YN as string,",
						"          LOB_VALID_START_DATE as timestamp,",
						"          LOB_VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> lobStagingLookup",
						"derivedColumn2 compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet3@(output1)",
						"derivedColumn3 compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet4@(output1)",
						"companySource select(mapColumn(",
						"          COMPANY_CODE = WINSCompanyID,",
						"          COMPANY_NAME = Name",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select3",
						"exists1 keyGenerate(output(skey as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> surrogateKey1",
						"surrogateKey1 derive(COMPANY_ID = skey + $DF_company_max_id,",
						"          COMPANY_VID = 1) ~> derivedColumn2",
						"lobSource select(mapColumn(",
						"          LOB_CODE = ARICLineOfBusinessID,",
						"          LOB_DESCRIPTION = ARICGroupLineDescription",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select4",
						"exists2 keyGenerate(output(skey as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> surrogateKey2",
						"surrogateKey2 derive(LOB_ID = skey + $DF_lob_max_id) ~> derivedColumn3",
						"compnayStatgingLookup select(mapColumn(",
						"          COMPANY_CODE",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select5",
						"select3, select5 exists(select3@COMPANY_CODE == select5@COMPANY_CODE,",
						"     negate:true,",
						"     broadcast: 'auto')~> exists1",
						"lobStagingLookup select(mapColumn(",
						"          LOB_CODE",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select6",
						"select4, select6 exists(select4@LOB_CODE == select6@LOB_CODE,",
						"     negate:true,",
						"     broadcast: 'auto')~> exists2",
						"flowlet3@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          COMPANY_ID as long,",
						"          COMPANY_VID as long,",
						"          COMPANY_CODE as string,",
						"          COMPANY_NAME as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          CORPORATE_NAME as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     saveOrder: 1) ~> companyStaging",
						"flowlet4@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          LOB_ID as long,",
						"          LOB_CODE as string,",
						"          LOB_NAME as string,",
						"          LOB_DESCRIPTION as string,",
						"          LOB_IS_VALID_YN as string,",
						"          LOB_VALID_START_DATE as timestamp,",
						"          LOB_VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     saveOrder: 2) ~> lobStaging"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_source_locationAddressToLocation')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Source Stage Data Flows/txnDataFlow"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_locationAddress",
								"type": "DatasetReference"
							},
							"name": "locationAddressSource"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policy",
								"type": "DatasetReference"
							},
							"name": "policyStaging"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_genAddress",
								"type": "DatasetReference"
							},
							"name": "genAddressStaging"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_location",
								"type": "DatasetReference"
							},
							"name": "locationStagingMaxId"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_location",
								"type": "DatasetReference"
							},
							"name": "locationStaging"
						},
						{
							"name": "maxIdCache"
						}
					],
					"transformations": [
						{
							"name": "flowlet1",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "join1"
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "join2"
						},
						{
							"name": "derivedColumn2"
						},
						{
							"name": "select1"
						},
						{
							"name": "select2"
						},
						{
							"name": "select3"
						},
						{
							"name": "surrogateKey1"
						},
						{
							"name": "select4"
						}
					],
					"scriptLines": [
						"parameters{",
						"     policyPrefix as string,",
						"     policies as string[]",
						"}",
						"source(output(",
						"          Policy as string,",
						"          Policy_Sequence as string,",
						"          PolicyPrefix as string,",
						"          ProductCode as string,",
						"          LocationNumber as string,",
						"          BuildingNumber as string,",
						"          LocationName as string,",
						"          LocationAddress1 as string,",
						"          LocationAddress2 as string,",
						"          LocationAddress3 as string,",
						"          LocationCity as string,",
						"          LocationZipCode as string,",
						"          LocationCounty as string,",
						"          Territory as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from [dbo].[Location_Address] where  PolicyPrefix = '{$policyPrefix}' and LocationNumber != '000'\"+iif(size($policies) >0&& size($policies) ==1&&$policies[1] =='','','and policy in ('+dropLeft(toString(reduce($policies, \"'\", #acc + \",'\" + #item +\"'\", #result)), 2)+')')),",
						"     format: 'query') ~> locationAddressSource",
						"source(output(",
						"          POLICY_ID as long,",
						"          POLICY_VID as long,",
						"          REINSURANCE_DAC as string,",
						"          PREVIOUS_INSURANCE_NO_REMARKS as string,",
						"          AGENCY_ID as long,",
						"          AGENCY_OVID as long,",
						"          PRODUCER_ID as long,",
						"          PRODUCER_OVID as long,",
						"          PRODUCER_CONTACT_ID as long,",
						"          PRODUCER_CONTACT_OVID as long,",
						"          POLICY_NUMBER as string,",
						"          ENTITY_TYPE as string,",
						"          ENTITY_STATUS as string,",
						"          IS_RENEWAL_YN as string,",
						"          REVISION_NUMBER as integer,",
						"          PRODUCT_ID as long,",
						"          PRODUCT_OVID as long,",
						"          POLICY_EFFECTIVE_DATE as timestamp,",
						"          POLICY_EXPIRATION_DATE as timestamp,",
						"          NON_RENEWAL_CODE as string,",
						"          POLICY_RENEWED_YN as string,",
						"          CANCELLATION_DATE as timestamp,",
						"          IS_RENEWABLE_YN as string,",
						"          PREVIOUS_INSURANCE_NO_REASON as string,",
						"          POLICY_STATUS as string,",
						"          CANCEL_REASON_CODE as string,",
						"          CANCEL_REASON_DESCRIPTION as string,",
						"          CANCEL_METHOD as string,",
						"          CANCEL_METHOD_DESC as string,",
						"          LOSE_REASON_CODE as string,",
						"          LOSE_REASON_DESC as string,",
						"          DECLINATION_REASON_CODE as string,",
						"          DECLINATION_REASON_DESC as string,",
						"          NOT_WRITTEN_REASON_CODE as string,",
						"          NOT_WRITTEN_REASON_DESC as string,",
						"          POLICY_STATE_CODE as string,",
						"          PROGRAM_ID as long,",
						"          PROGRAM_OVID as long,",
						"          BILLING_TYPE_CODE as string,",
						"          UNDERWRITING_COMPANY_ID as long,",
						"          UNDERWRITING_COMPANY_OVID as long,",
						"          SUBMISSION_ID as long,",
						"          PREVIOUS_INSURANCE_YN as string,",
						"          LEGACY_POLICY_NUMBER as string,",
						"          STATE as string,",
						"          POLICY_POLICY as integer,",
						"          PAYMENT_PLAN as string,",
						"          APPLICATION_RECEIVED_DATE as timestamp,",
						"          INCEPTION_DATE as timestamp,",
						"          BILL_TYPE as string,",
						"          FORMS_LANGUAGE as string,",
						"          BASE_CURRENCY as string,",
						"          INVOICE_CURRENCY as string,",
						"          PREVIOUS_POLICY_ID as long,",
						"          PREVIOUS_POLICY_OVID as long,",
						"          REVISED_FROM_POLICY_ID as long,",
						"          REVISED_FROM_POLICY_OVID as long,",
						"          OPERATING_COMPANY_ID as long,",
						"          OPERATING_COMPANY_OVID as long,",
						"          CONVERTED_FROM_ID as long,",
						"          CONVERTED_FROM_OVID as long,",
						"          INSTALLMENT_RENEWAL as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from [dbo].[POL_POLICY] where ENTITY_TYPE ='{$policyPrefix}' \"+iif(size($policies) >0&& size($policies) ==1&&$policies[1] =='','','and policy_number in ('+dropLeft(toString(reduce($policies, \"'\", #acc + \",'\" + #item +\"'\", #result)), 2)+')')),",
						"     format: 'query') ~> policyStaging",
						"source(output(",
						"          GEN_ADDRESS_UNIQ_ID as long,",
						"          ADDRESS_STREET1 as string,",
						"          ADDRESS_STREET2 as string,",
						"          COUNTY_CODE as string,",
						"          COUNTY as string,",
						"          ADDRESS_CITY as string,",
						"          ADD_DESCRIPTION as string,",
						"          STATE_PROVINCE_CODE as string,",
						"          POSTAL_CODE as string,",
						"          POSTAL_CODE_EXT as string,",
						"          COUNTRY_CODE as string,",
						"          SOURCE_INSERTED_ON as timestamp,",
						"          SOURCE_UPDATED_ON as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary,",
						"          TERRITORY as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> genAddressStaging",
						"source(output(",
						"          maxId as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT isnull(MAX(LOCATION_ID), 0) as maxId\\nFROM dbo.POL_LOCATION',",
						"     format: 'query') ~> locationStagingMaxId",
						"derivedColumn2 compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet1@(output1)",
						"select1, select2 join(Policy == POLICY_NUMBER,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"join1 derive(source_key_exp = concatWS('', iif(isNull(ADDRESS_STREET1), '', replace(ADDRESS_STREET1, ' ', '')), iif(isNull(ADDRESS_STREET2), '', replace(ADDRESS_STREET2, ' ', '')), iif(isNull(ADDRESS_CITY), '', replace(ADDRESS_CITY, ' ', '')) , iif(isNull(POSTAL_CODE), '', replace(POSTAL_CODE, ' ', '')), iif(isNull(TERRITORY), '', replace(TERRITORY, ' ', '')))) ~> derivedColumn1",
						"derivedColumn1, select3 join(source_key_exp == SOURCE_KEY,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join2",
						"surrogateKey1 derive(LOCATION_ID = skey + maxIdCache#outputs()[1].maxId,",
						"          LOCATION_VID = 1,",
						"          LOCATION_IS_ACTIVE_YN = \"Y\",",
						"          LOCATION_EFF_DATE = currentTimestamp(),",
						"          LOCATION_EXP_DATE = toTimestamp(\"9999-01-01 00:00:00\")) ~> derivedColumn2",
						"locationAddressSource select(mapColumn(",
						"          Policy,",
						"          LOCATION_NO = LocationNumber,",
						"          LOCATION_NAME = LocationName,",
						"          ADDRESS_STREET1 = LocationAddress1,",
						"          ADDRESS_STREET2 = LocationAddress2,",
						"          ADDRESS_CITY = LocationCity,",
						"          POSTAL_CODE = LocationZipCode,",
						"          TERRITORY = Territory",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"policyStaging select(mapColumn(",
						"          POLICY_ID,",
						"          POLICY_NUMBER",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select2",
						"genAddressStaging select(mapColumn(",
						"          GEN_ADDRESS_UNIQ_ID,",
						"          SOURCE_KEY",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select3",
						"select4 keyGenerate(output(skey as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> surrogateKey1",
						"join2 select(mapColumn(",
						"          LOCATION_NO,",
						"          LOCATION_NAME,",
						"          POLICY_ID,",
						"          GEN_ADDRESS_UNIQ_ID",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select4",
						"flowlet1@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          LOCATION_ID as long,",
						"          LOCATION_VID as long,",
						"          LOCATION_NAME as string,",
						"          LOCATION_NO as long,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          LOCATION_IS_ACTIVE_YN as string,",
						"          LOCATION_EFF_DATE as timestamp,",
						"          LOCATION_EXP_DATE as timestamp,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          IS_PRIMARY_LOCATION_YN as string,",
						"          IS_FALSE_ADDRESS as string,",
						"          PROTECTION_CLASS as string,",
						"          FIRE_DISTRICT_NAME as string,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          GEN_ADDRESS_UNIQ_ID as long,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> locationStaging",
						"locationStagingMaxId sink(validateSchema: false,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     store: 'cache',",
						"     format: 'inline',",
						"     output: false,",
						"     saveOrder: 1) ~> maxIdCache"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_source_location_risk_bridege')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Source Stage Data Flows/txnDataFlow/bridge"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_location",
								"type": "DatasetReference"
							},
							"name": "location"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policy",
								"type": "DatasetReference"
							},
							"name": "policy"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRisk",
								"type": "DatasetReference"
							},
							"name": "risk"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_locationRiskBridge",
								"type": "DatasetReference"
							},
							"name": "sink1",
							"rejectedDataLinkedService": {
								"referenceName": "AzureBlobStorage1",
								"type": "LinkedServiceReference"
							}
						},
						{
							"dataset": {
								"referenceName": "ds_error_location_risk_bridge",
								"type": "DatasetReference"
							},
							"name": "sink2"
						}
					],
					"transformations": [
						{
							"name": "flowlet1",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "polSelect"
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "locationlookup"
						},
						{
							"name": "locationSelect"
						},
						{
							"name": "derivedColumn2"
						},
						{
							"name": "select1"
						},
						{
							"name": "split1"
						},
						{
							"name": "join1"
						}
					],
					"scriptLines": [
						"parameters{",
						"     policies as string[],",
						"     policyPrefix as string",
						"}",
						"source(output(",
						"          LOCATION_ID as long,",
						"          LOCATION_VID as long,",
						"          LOCATION_NAME as string,",
						"          LOCATION_NO as long,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          LOCATION_IS_ACTIVE_YN as string,",
						"          LOCATION_EFF_DATE as timestamp,",
						"          LOCATION_EXP_DATE as timestamp,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          IS_PRIMARY_LOCATION_YN as string,",
						"          IS_FALSE_ADDRESS as string,",
						"          PROTECTION_CLASS as string,",
						"          FIRE_DISTRICT_NAME as string,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          GEN_ADDRESS_UNIQ_ID as long,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select * from [dbo].[POL_LOCATION] where LOCATION_NO is not null\\n',",
						"     format: 'query') ~> location",
						"source(output(",
						"          POLICY_ID as long,",
						"          POLICY_VID as long,",
						"          REINSURANCE_DAC as string,",
						"          PREVIOUS_INSURANCE_NO_REMARKS as string,",
						"          AGENCY_ID as long,",
						"          AGENCY_OVID as long,",
						"          PRODUCER_ID as long,",
						"          PRODUCER_OVID as long,",
						"          PRODUCER_CONTACT_ID as long,",
						"          PRODUCER_CONTACT_OVID as long,",
						"          POLICY_NUMBER as string,",
						"          ENTITY_TYPE as string,",
						"          ENTITY_STATUS as string,",
						"          IS_RENEWAL_YN as string,",
						"          REVISION_NUMBER as integer,",
						"          PRODUCT_ID as long,",
						"          PRODUCT_OVID as long,",
						"          POLICY_EFFECTIVE_DATE as timestamp,",
						"          POLICY_EXPIRATION_DATE as timestamp,",
						"          NON_RENEWAL_CODE as string,",
						"          POLICY_RENEWED_YN as string,",
						"          CANCELLATION_DATE as timestamp,",
						"          IS_RENEWABLE_YN as string,",
						"          PREVIOUS_INSURANCE_NO_REASON as string,",
						"          POLICY_STATUS as string,",
						"          CANCEL_REASON_CODE as string,",
						"          CANCEL_REASON_DESCRIPTION as string,",
						"          CANCEL_METHOD as string,",
						"          CANCEL_METHOD_DESC as string,",
						"          LOSE_REASON_CODE as string,",
						"          LOSE_REASON_DESC as string,",
						"          DECLINATION_REASON_CODE as string,",
						"          DECLINATION_REASON_DESC as string,",
						"          NOT_WRITTEN_REASON_CODE as string,",
						"          NOT_WRITTEN_REASON_DESC as string,",
						"          POLICY_STATE_CODE as string,",
						"          PROGRAM_ID as long,",
						"          PROGRAM_OVID as long,",
						"          BILLING_TYPE_CODE as string,",
						"          UNDERWRITING_COMPANY_ID as long,",
						"          UNDERWRITING_COMPANY_OVID as long,",
						"          SUBMISSION_ID as long,",
						"          PREVIOUS_INSURANCE_YN as string,",
						"          LEGACY_POLICY_NUMBER as string,",
						"          STATE as string,",
						"          POLICY_POLICY as integer,",
						"          PAYMENT_PLAN as string,",
						"          APPLICATION_RECEIVED_DATE as timestamp,",
						"          INCEPTION_DATE as timestamp,",
						"          BILL_TYPE as string,",
						"          FORMS_LANGUAGE as string,",
						"          BASE_CURRENCY as string,",
						"          INVOICE_CURRENCY as string,",
						"          PREVIOUS_POLICY_ID as long,",
						"          PREVIOUS_POLICY_OVID as long,",
						"          REVISED_FROM_POLICY_ID as long,",
						"          REVISED_FROM_POLICY_OVID as long,",
						"          OPERATING_COMPANY_ID as long,",
						"          OPERATING_COMPANY_OVID as long,",
						"          CONVERTED_FROM_ID as long,",
						"          CONVERTED_FROM_OVID as long,",
						"          INSTALLMENT_RENEWAL as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from [dbo].[POL_POLICY] where ENTITY_TYPE ='{$policyPrefix}' \"+iif(size($policies) >0&& size($policies) ==1&&$policies[1] =='','','and policy_number in ('+dropLeft(toString(reduce($policies, \"'\", #acc + \",'\" + #item +\"'\", #result)), 2)+')')),",
						"     format: 'query') ~> policy",
						"source(output(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_NUMBER as string,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          RISK_IS_ACTIVE_YN as string,",
						"          RISK_EFF_DATE as timestamp,",
						"          RISK_EXP_DATE as timestamp,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select * from POL_RISK ',",
						"     format: 'query') ~> risk",
						"split1@goodRows compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet1@(output1)",
						"policy select(mapColumn(",
						"          POLICY_ID,",
						"          POLICY_VID,",
						"          POLICY_NUMBER,",
						"          ENTITY_TYPE",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> polSelect",
						"join1 derive(POLICY_ID = polSelect@POLICY_ID,",
						"          POLICY_NUMBER = POLICY_NUMBER,",
						"          RISK_ID = RISK_ID,",
						"          LOCATIONNUMBER = split(RISK_NUMBER, '-')[1],",
						"          LOCATIONUNITNUMBER = split(RISK_NUMBER, '-')[2]) ~> derivedColumn1",
						"derivedColumn1, locationSelect lookup(derivedColumn1@POLICY_ID == locationSelect@POLICY_ID",
						"     && LOCATIONNUMBER == concat('00',toString(LOCATION_NO)),",
						"     multiple: false,",
						"     pickup: 'first',",
						"     asc(LOCATION_ID, true),",
						"     broadcast: 'auto')~> locationlookup",
						"location select(mapColumn(",
						"          LOCATION_ID,",
						"          LOCATION_VID,",
						"          LOCATION_NO,",
						"          POLICY_ID",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> locationSelect",
						"locationlookup derive(LOCATION_ID = LOCATION_ID,",
						"          RISK_ID = RISK_ID,",
						"          RISK_VID = RISK_VID,",
						"          LOCATION_OVID = LOCATION_VID) ~> derivedColumn2",
						"derivedColumn2 select(mapColumn(",
						"          RISK_ID,",
						"          RISK_VID,",
						"          LOCATION_ID,",
						"          LOCATION_OVID",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"select1 split(!isNull(RISK_ID)&&!isNull(RISK_VID)&&!isNull(LOCATION_ID)&&!isNull(LOCATION_OVID),",
						"     disjoint: false) ~> split1@(goodRows, badRows)",
						"risk, polSelect join(risk@POLICY_ID == polSelect@POLICY_ID,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"flowlet1@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          LOCATION_ID as long,",
						"          LOCATION_OVID as long,",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          DATA_HASH as binary,",
						"          SOURCE_KEY as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     outputAssertFailedRows: true,",
						"     assertFailure_container: 'bpadocuments') ~> sink1",
						"split1@badRows sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink2"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_source_locationgenaddress')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Source Stage Data Flows/referenceDataFlow"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_locationAddress",
								"type": "DatasetReference"
							},
							"name": "locationAddressSource"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_genAddress",
								"type": "DatasetReference"
							},
							"name": "genAddressStagingLookup"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_genAddress",
								"type": "DatasetReference"
							},
							"name": "genAddressStaging"
						}
					],
					"transformations": [
						{
							"name": "selectRequiredAddressColumns"
						},
						{
							"name": "addressSurrogateKey"
						},
						{
							"name": "deriveSourceKey"
						},
						{
							"name": "alreadyExistsCheck"
						},
						{
							"name": "groupBySourceKey"
						}
					],
					"scriptLines": [
						"parameters{",
						"     DF_max_id as integer (1),",
						"     policyPrefix as string ('CFA')",
						"}",
						"source(output(",
						"          Policy as string,",
						"          Policy_Sequence as string,",
						"          PolicyPrefix as string,",
						"          ProductCode as string,",
						"          LocationNumber as string,",
						"          BuildingNumber as string,",
						"          LocationName as string,",
						"          LocationAddress1 as string,",
						"          LocationAddress2 as string,",
						"          LocationAddress3 as string,",
						"          LocationCity as string,",
						"          LocationZipCode as string,",
						"          LocationCounty as string,",
						"          Territory as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from [dbo].[Location_Address] where  PolicyPrefix = '{$policyPrefix}' and LocationNumber != '000'\"),",
						"     format: 'query') ~> locationAddressSource",
						"source(output(",
						"          GEN_ADDRESS_UNIQ_ID as long,",
						"          ADDRESS_STREET1 as string,",
						"          ADDRESS_STREET2 as string,",
						"          COUNTY_CODE as string,",
						"          COUNTY as string,",
						"          ADDRESS_CITY as string,",
						"          ADD_DESCRIPTION as string,",
						"          STATE_PROVINCE_CODE as string,",
						"          POSTAL_CODE as string,",
						"          POSTAL_CODE_EXT as string,",
						"          COUNTRY_CODE as string,",
						"          SOURCE_INSERTED_ON as timestamp,",
						"          SOURCE_UPDATED_ON as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary,",
						"          TERRITORY as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> genAddressStagingLookup",
						"locationAddressSource select(mapColumn(",
						"          ADDRESS_STREET1 = LocationAddress1,",
						"          ADDRESS_STREET2 = LocationAddress2,",
						"          ADDRESS_CITY = LocationCity,",
						"          POSTAL_CODE = LocationZipCode,",
						"          COUNTY = LocationCounty,",
						"          TERRITORY = Territory",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectRequiredAddressColumns",
						"selectRequiredAddressColumns keyGenerate(output(skey as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> addressSurrogateKey",
						"addressSurrogateKey derive(GEN_ADDRESS_UNIQ_ID = skey + $DF_max_id,",
						"          SOURCE_INSERTED_ON = currentTimestamp(),",
						"          SOURCE_UPDATED_ON = currentTimestamp(),",
						"          SOURCE_KEY = concatWS('', iif(isNull(ADDRESS_STREET1), '', replace(ADDRESS_STREET1, ' ', '')), iif(isNull(ADDRESS_STREET2), '', replace(ADDRESS_STREET2, ' ', '')), iif(isNull(ADDRESS_CITY), '', replace(ADDRESS_CITY, ' ', '')) , iif(isNull(POSTAL_CODE), '', replace(POSTAL_CODE, ' ', '')), iif(isNull(TERRITORY), '', replace(TERRITORY, ' ', '')))) ~> deriveSourceKey",
						"groupBySourceKey, genAddressStagingLookup exists(groupBySourceKey@SOURCE_KEY == genAddressStagingLookup@SOURCE_KEY,",
						"     negate:true,",
						"     broadcast: 'auto')~> alreadyExistsCheck",
						"deriveSourceKey aggregate(groupBy(SOURCE_KEY),",
						"     each(match(name!='SOURCE_KEY'), $$ = first($$))) ~> groupBySourceKey",
						"alreadyExistsCheck sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          GEN_ADDRESS_UNIQ_ID as long,",
						"          ADDRESS_STREET1 as string,",
						"          ADDRESS_STREET2 as string,",
						"          COUNTY_CODE as string,",
						"          COUNTY as string,",
						"          ADDRESS_CITY as string,",
						"          ADD_DESCRIPTION as string,",
						"          STATE_PROVINCE_CODE as string,",
						"          POSTAL_CODE as string,",
						"          POSTAL_CODE_EXT as string,",
						"          COUNTRY_CODE as string,",
						"          SOURCE_INSERTED_ON as timestamp,",
						"          SOURCE_UPDATED_ON as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary,",
						"          TERRITORY as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> genAddressStaging"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_source_party')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Source Stage Data Flows/referenceDataFlow"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_party",
								"type": "DatasetReference"
							},
							"name": "partySource"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_party",
								"type": "DatasetReference"
							},
							"name": "partyStagingLookup"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_party",
								"type": "DatasetReference"
							},
							"name": "partyStaging"
						}
					],
					"transformations": [
						{
							"name": "metadataflowlet",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "$DF_batch"
								}
							}
						},
						{
							"name": "selectRequiredPartyColumns"
						},
						{
							"name": "partySurrogateKey"
						},
						{
							"name": "deriveOtherRequiredColumns"
						},
						{
							"name": "selectRequiredStagingPartyColumns"
						},
						{
							"name": "derivedFullName"
						},
						{
							"name": "groupByFullName"
						}
					],
					"scriptLines": [
						"parameters{",
						"     DF_batch as integer (1),",
						"     DF_max_id as integer (1)",
						"}",
						"source(output(",
						"          Policy as string,",
						"          Policy_Sequence as string,",
						"          EffectiveDate as timestamp,",
						"          ExpirationDate as timestamp,",
						"          LocationNumber as string,",
						"          LocationUnitNumber as string,",
						"          InsuredNumber as integer,",
						"          InsuredType as string,",
						"          InsuredSubType as string,",
						"          FirstName as string,",
						"          MiddleName as string,",
						"          LastName as string,",
						"          NameSuffix as string,",
						"          CorporateName as string,",
						"          AlternateName as string,",
						"          MailingAddress1 as string,",
						"          MailingAddress2 as string,",
						"          MailingCity as string,",
						"          MailingZipCode as string,",
						"          DOB as date,",
						"          Relationship as string,",
						"          ExcludedDate as date,",
						"          DW_InsertDate as date",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> partySource",
						"source(output(",
						"          PARTY_ID as long,",
						"          PARTY_VID as long,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          NAME_PREFIX as string,",
						"          FIRST_NAME as string,",
						"          MIDDLE_NAME as string,",
						"          LAST_NAME as string,",
						"          FULL_NAME as string,",
						"          DATE_OF_BIRTH as timestamp,",
						"          GENDER as string,",
						"          SSN as string,",
						"          HIRE_DATE as timestamp,",
						"          POLICYINATION_DATE as timestamp,",
						"          EMAIL as string,",
						"          PARTY_IS_ACTIVE_YN as string,",
						"          PARTY_EFF_DATE as timestamp,",
						"          PARTY_EXP_DATE as timestamp,",
						"          PARTY_TYPE as string,",
						"          PHYSICAL_GEN_ADDRESS_ID as long,",
						"          HOME_PHONE_NUMBER as string,",
						"          FAX_NUMBER as string,",
						"          YEARS_WITH_EMPLOYER as integer,",
						"          NAME_SUFFIX as string,",
						"          MARITAL_STATUS as string,",
						"          OCCUPATION as string,",
						"          DOING_BUSINESS_AS as string,",
						"          DECEASED_DATE as timestamp,",
						"          IS_DECEASED_YN as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> partyStagingLookup",
						"deriveOtherRequiredColumns compose(mapParameter(",
						"          FL_batch = $DF_batch",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> metadataflowlet@(output1)",
						"partySource select(mapColumn(",
						"          FIRST_NAME = FirstName,",
						"          MIDDLE_NAME = MiddleName,",
						"          LAST_NAME = LastName,",
						"          GIVEN_FULL_NAME = CorporateName,",
						"          DATE_OF_BIRTH = DOB",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectRequiredPartyColumns",
						"groupByFullName keyGenerate(output(skey as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> partySurrogateKey",
						"partySurrogateKey derive(PARTY_ID = skey + $DF_max_id,",
						"          PARTY_VID = 1,",
						"          PARTY_TYPE = \"INSURED\") ~> deriveOtherRequiredColumns",
						"partyStagingLookup select(mapColumn(",
						"          FIRST_NAME,",
						"          LAST_NAME,",
						"          MIDDLE_NAME,",
						"          FULL_NAME",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectRequiredStagingPartyColumns",
						"selectRequiredPartyColumns derive(FULL_NAME = iif(isNull(GIVEN_FULL_NAME)|| trim(GIVEN_FULL_NAME)=='', concatWS(\" \", trim(FIRST_NAME), trim(MIDDLE_NAME), trim(LAST_NAME)), trim(GIVEN_FULL_NAME))) ~> derivedFullName",
						"derivedFullName aggregate(groupBy(FULL_NAME),",
						"     each(match(name!='FULL_NAME'), $$ = first($$))) ~> groupByFullName",
						"metadataflowlet@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          PARTY_ID as long,",
						"          PARTY_VID as long,",
						"          NAME_PREFIX as string,",
						"          FIRST_NAME as string,",
						"          MIDDLE_NAME as string,",
						"          LAST_NAME as string,",
						"          FULL_NAME as string,",
						"          DATE_OF_BIRTH as timestamp,",
						"          GENDER as string,",
						"          SSN as string,",
						"          HIRE_DATE as timestamp,",
						"          POLICYINATION_DATE as timestamp,",
						"          EMAIL as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          PARTY_TYPE as string,",
						"          PHYSICAL_GEN_ADDRESS_ID as long,",
						"          HOME_PHONE_NUMBER as string,",
						"          FAX_NUMBER as string,",
						"          YEARS_WITH_EMPLOYER as integer,",
						"          NAME_SUFFIX as string,",
						"          MARITAL_STATUS as string,",
						"          OCCUPATION as string,",
						"          DOING_BUSINESS_AS as string,",
						"          DECEASED_DATE as timestamp,",
						"          IS_DECEASED_YN as string,",
						"          GEN_ADDRESS_UNIQ_ID as long,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> partyStaging"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_source_policy')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Source Stage Data Flows/txnDataFlow"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_policyCoverage",
								"type": "DatasetReference"
							},
							"name": "ecmPolicyCoverage"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_agency",
								"type": "DatasetReference"
							},
							"name": "polAgencyStg"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_agency",
								"type": "DatasetReference"
							},
							"name": "producerStg"
						},
						{
							"dataset": {
								"referenceName": "ds_ecm_state_code",
								"type": "DatasetReference"
							},
							"name": "stateCode"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policy",
								"type": "DatasetReference"
							},
							"name": "stgPolicyNextPkey"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_policy",
								"type": "DatasetReference"
							},
							"name": "stgPolicy"
						},
						{
							"name": "stateCodeSink"
						},
						{
							"name": "policyPkeyCache"
						}
					],
					"transformations": [
						{
							"name": "flowlet1",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "surrogateKey1"
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "select1"
						},
						{
							"name": "polAgencySrc"
						},
						{
							"name": "producerLookup"
						},
						{
							"name": "insuredLookUp"
						},
						{
							"name": "producerSelect"
						},
						{
							"name": "producerDerviedCol"
						},
						{
							"name": "derivedColumn2"
						}
					],
					"scriptLines": [
						"parameters{",
						"     policyPrefix as string (\"\"),",
						"     policies as string[] ([\"\"])",
						"}",
						"source(output(",
						"          Policy as string,",
						"          ARICLOB as string,",
						"          ARICGroupCode as string,",
						"          Description as string,",
						"          Product as string,",
						"          Occupancy as string,",
						"          ConstructionCode as string,",
						"          ConstructionYear as integer,",
						"          NumberOfFloors as integer,",
						"          ProtectionClass as string,",
						"          GEOLatitude as decimal(11,8),",
						"          GEOLongitude as decimal(11,8),",
						"          CauseOfLoss as string,",
						"          BCEGClassCode as string,",
						"          CoverageForm as string,",
						"          DesignatedPremisis as string,",
						"          WindIndicatorFlag as string,",
						"          PurchaseCost as decimal(8,2),",
						"          CoInsuranceBuilding as integer,",
						"          CoInsurancePersonalProperty as integer,",
						"          CoInsuranceBodilyInjury as integer,",
						"          ISOClassCode as string,",
						"          PolicyPrefix as string,",
						"          CancelDate as timestamp,",
						"          CancelReason as string,",
						"          CancelReasonDescription as string,",
						"          PolicyTermMonths as integer,",
						"          InsuredName as string,",
						"          InsuredAddress1 as string,",
						"          InsuredAddress2 as string,",
						"          InsuredCity as string,",
						"          InsuredState as string,",
						"          InsuredZipCode as string,",
						"          CompanyCode as string,",
						"          CompanyName as string,",
						"          GroupName as string,",
						"          GBLICompanyCode as string,",
						"          AgentCode as string,",
						"          AgentName as string,",
						"          AgentOffice as string,",
						"          GroupCode as string,",
						"          AgentCity as string,",
						"          EMail as string,",
						"          AgentPhone as string,",
						"          AgentCounty as string,",
						"          AgentZipCode as string,",
						"          AgentAddress1 as string,",
						"          AgentAddress2 as string,",
						"          AgentState as string,",
						"          SubProducerNumber as string,",
						"          SubProducerCode as string,",
						"          SubProducerName as string,",
						"          SubproducerState as string,",
						"          SubProducerType as string,",
						"          ProductCode as string,",
						"          ProductCodeDescription as string,",
						"          PreviousPolicy as string,",
						"          OriginalPolicyYear as integer,",
						"          NonRenewalReason as string,",
						"          NonRenewalNoticeDate as timestamp,",
						"          DatabaseCode as string,",
						"          MasterPolicy as string,",
						"          BillingType as string,",
						"          RowStatus as string,",
						"          OriginalInceptionDate as timestamp,",
						"          MultiplePolicyFlag as string,",
						"          ARICBusinessUnit as string,",
						"          HonorCurrentRateFlag as string,",
						"          FarmType as string,",
						"          PrimaryPremiumStateCode as string,",
						"          StateName as string,",
						"          BillingSystem as string,",
						"          ExperienceModFactor as decimal(7,4),",
						"          Exposure as decimal(8,0),",
						"          TaxFeeSurchargeFlag as string,",
						"          Rate as decimal(12,6)",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"SELECT distinct [Policy]  ,[ARICLOB] ,[ARICGroupCode] ,[Description] ,[Product] ,[Occupancy] ,[ConstructionCode] ,[ConstructionYear] ,[NumberOfFloors] ,[ProtectionClass] ,[GEOLatitude] ,[GEOLongitude] ,[CauseOfLoss] ,[BCEGClassCode] ,[CoverageForm] ,[DesignatedPremisis] ,[WindIndicatorFlag] ,[PurchaseCost] ,[CoInsuranceBuilding] ,[CoInsurancePersonalProperty] ,[CoInsuranceBodilyInjury], [ISOClassCode] ,[PolicyPrefix]  ,[CancelDate] ,[CancelReason] ,[CancelReasonDescription] ,[PolicyTermMonths] ,[InsuredName] ,[InsuredAddress1] ,[InsuredAddress2] ,[InsuredCity] ,[InsuredState] ,[InsuredZipCode] ,[CompanyCode] ,[CompanyName] ,[GroupName] ,[GBLICompanyCode] ,[AgentCode] ,[AgentName] ,[AgentOffice] ,[GroupCode] ,[AgentCity] ,[EMail] ,[AgentPhone] ,[AgentCounty] ,[AgentZipCode] ,[AgentAddress1] ,[AgentAddress2] ,[AgentState] ,[SubProducerNumber] ,[SubProducerCode] ,[SubProducerName] ,[SubproducerState] ,[SubProducerType] ,[ProductCode] ,[ProductCodeDescription] ,[PreviousPolicy] ,[OriginalPolicyYear] ,[NonRenewalReason] ,[NonRenewalNoticeDate] ,[DatabaseCode],[MasterPolicy] ,[BillingType] ,[RowStatus] ,[OriginalInceptionDate] ,[MultiplePolicyFlag] ,[ARICBusinessUnit] ,[HonorCurrentRateFlag] ,[FarmType] ,[PrimaryPremiumStateCode] ,[StateName] ,[BillingSystem] ,[ExperienceModFactor] ,[Exposure] ,[TaxFeeSurchargeFlag] , [Rate] FROM [DataStoreARICECM].[dbo].[Policy_Coverage]  where PolicyPrefix='{$policyPrefix}'\"+iif(size($policies) >0&& size($policies) ==1&&$policies[1] =='','','and policy in ('+dropLeft(toString(reduce($policies, \"'\", #acc + \",'\" + #item +\"'\", #result)), 2)+')')),",
						"     format: 'query') ~> ecmPolicyCoverage",
						"source(output(",
						"          AGENCY_ID as long,",
						"          AGENCY_VID as long,",
						"          AGENCY_GEN_ADDRESS_ID as long,",
						"          AGENCY_CODE as string,",
						"          AGENCY_NAME as string,",
						"          AGENCY_STATUS as string,",
						"          AGENCY_CATEGORY as string,",
						"          DIRECT_BILL_FLAG_YN as string,",
						"          TELEPHONE as string,",
						"          FAX as string,",
						"          EMAIL_ID as string,",
						"          WEBSITE as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          ENTITY_TYPE as string,",
						"          ENTITY_PARENT_ID as long,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select * from [dbo].[POL_AGENCY] where  ENTITY_TYPE=\\'AGENCY\\'',",
						"     format: 'query') ~> polAgencyStg",
						"source(output(",
						"          AGENCY_ID as long,",
						"          AGENCY_VID as long,",
						"          AGENCY_GEN_ADDRESS_ID as long,",
						"          AGENCY_CODE as string,",
						"          AGENCY_NAME as string,",
						"          AGENCY_STATUS as string,",
						"          AGENCY_CATEGORY as string,",
						"          DIRECT_BILL_FLAG_YN as string,",
						"          TELEPHONE as string,",
						"          FAX as string,",
						"          EMAIL_ID as string,",
						"          WEBSITE as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          ENTITY_TYPE as string,",
						"          ENTITY_PARENT_ID as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select * from [dbo].[POL_AGENCY]  pa where pa.ENTITY_TYPE=\\'PRODUCER\\'',",
						"     format: 'query') ~> producerStg",
						"source(output(",
						"          StateCode as string,",
						"          StateAbbreviation as string,",
						"          StateName as string,",
						"          WCTypeOfLossGroupCode as string,",
						"          QuickRaterStateID as integer,",
						"          AutoDoNotRenewDays as integer,",
						"          AutoConditionalRenewalNoticeDays as integer,",
						"          AutoUMLimitFlag as string,",
						"          AutoStateBand as string,",
						"          AutoRegionID as integer,",
						"          StateTypeCode as string,",
						"          FIPSStateCode as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> stateCode",
						"source(output(",
						"          POLICY_ID as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select MAX(POLICY_ID) as POLICY_ID from POL_POLICY',",
						"     format: 'query') ~> stgPolicyNextPkey",
						"derivedColumn1 compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet1@(output1)",
						"ecmPolicyCoverage keyGenerate(output(pid as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> surrogateKey1",
						"insuredLookUp derive(POLICY_ID = policyPkeyCache#outputs()[1].POLICY_ID + pid,",
						"          POLICY_VID = 1,",
						"          POLICY_NUMBER = Policy,",
						"          ENTITY_TYPE = PolicyPrefix,",
						"          PAYMENT_PLAN = toString(PolicyTermMonths),",
						"          AGENCY_ID = agencyPKey,",
						"          AGENCY_VID = agencyPvKey,",
						"          PRODUCER_ID = producerDerviedCol@AGENCY_ID,",
						"          PRODUCER_VID = producerDerviedCol@AGENCY_VID,",
						"          LEGACY_POLICY_NUMBER = PreviousPolicy,",
						"          INCEPTION_DATE = OriginalInceptionDate,",
						"          POLICY_STATE_CODE = stateCodeSink#lookup(PrimaryPremiumStateCode).StateAbbreviation) ~> derivedColumn1",
						"polAgencyStg select(mapColumn(",
						"          AGENCY_ID,",
						"          AGENCY_VID,",
						"          AGENCY_CODE,",
						"          AGENCY_NAME,",
						"          ENTITY_TYPE",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"select1 derive(agencyPKey = AGENCY_ID,",
						"          agencyPvKey = AGENCY_VID,",
						"          AGENCY_CODE = AGENCY_CODE) ~> polAgencySrc",
						"surrogateKey1, polAgencySrc lookup(AgentCode == AGENCY_CODE,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> producerLookup",
						"producerLookup, producerDerviedCol lookup(SubProducerCode == producerDerviedCol@AGENCY_CODE,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> insuredLookUp",
						"producerStg select(mapColumn(",
						"          AGENCY_ID,",
						"          AGENCY_VID,",
						"          AGENCY_CODE,",
						"          AGENCY_NAME",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> producerSelect",
						"producerSelect derive(AGENCY_ID = AGENCY_ID,",
						"          AGENCY_VID = AGENCY_VID,",
						"          AGENCY_CODE = AGENCY_CODE) ~> producerDerviedCol",
						"stgPolicyNextPkey derive(POLICY_ID = iifNull(POLICY_ID, 0, POLICY_ID)) ~> derivedColumn2",
						"flowlet1@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          POLICY_ID as long,",
						"          POLICY_VID as long,",
						"          REINSURANCE_DAC as string,",
						"          PREVIOUS_INSURANCE_NO_REMARKS as string,",
						"          AGENCY_ID as long,",
						"          AGENCY_OVID as long,",
						"          PRODUCER_ID as long,",
						"          PRODUCER_OVID as long,",
						"          PRODUCER_CONTACT_ID as long,",
						"          PRODUCER_CONTACT_OVID as long,",
						"          POLICY_NUMBER as string,",
						"          ENTITY_TYPE as string,",
						"          ENTITY_STATUS as string,",
						"          IS_RENEWAL_YN as string,",
						"          REVISION_NUMBER as integer,",
						"          PRODUCT_ID as long,",
						"          PRODUCT_OVID as long,",
						"          POLICY_EFFECTIVE_DATE as timestamp,",
						"          POLICY_EXPIRATION_DATE as timestamp,",
						"          NON_RENEWAL_CODE as string,",
						"          POLICY_RENEWED_YN as string,",
						"          CANCELLATION_DATE as timestamp,",
						"          IS_RENEWABLE_YN as string,",
						"          PREVIOUS_INSURANCE_NO_REASON as string,",
						"          POLICY_STATUS as string,",
						"          CANCEL_REASON_CODE as string,",
						"          CANCEL_REASON_DESCRIPTION as string,",
						"          CANCEL_METHOD as string,",
						"          CANCEL_METHOD_DESC as string,",
						"          LOSE_REASON_CODE as string,",
						"          LOSE_REASON_DESC as string,",
						"          DECLINATION_REASON_CODE as string,",
						"          DECLINATION_REASON_DESC as string,",
						"          NOT_WRITTEN_REASON_CODE as string,",
						"          NOT_WRITTEN_REASON_DESC as string,",
						"          POLICY_STATE_CODE as string,",
						"          PROGRAM_ID as long,",
						"          PROGRAM_OVID as long,",
						"          BILLING_TYPE_CODE as string,",
						"          UNDERWRITING_COMPANY_ID as long,",
						"          UNDERWRITING_COMPANY_OVID as long,",
						"          SUBMISSION_ID as long,",
						"          PREVIOUS_INSURANCE_YN as string,",
						"          LEGACY_POLICY_NUMBER as string,",
						"          STATE as string,",
						"          POLICY_POLICY as integer,",
						"          PAYMENT_PLAN as string,",
						"          APPLICATION_RECEIVED_DATE as timestamp,",
						"          INCEPTION_DATE as timestamp,",
						"          BILL_TYPE as string,",
						"          FORMS_LANGUAGE as string,",
						"          BASE_CURRENCY as string,",
						"          INVOICE_CURRENCY as string,",
						"          PREVIOUS_POLICY_ID as long,",
						"          PREVIOUS_POLICY_OVID as long,",
						"          REVISED_FROM_POLICY_ID as long,",
						"          REVISED_FROM_POLICY_OVID as long,",
						"          OPERATING_COMPANY_ID as long,",
						"          OPERATING_COMPANY_OVID as long,",
						"          CONVERTED_FROM_ID as long,",
						"          CONVERTED_FROM_OVID as long,",
						"          INSTALLMENT_RENEWAL as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> stgPolicy",
						"stateCode sink(validateSchema: false,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     keys:['StateCode'],",
						"     store: 'cache',",
						"     format: 'inline',",
						"     output: false,",
						"     saveOrder: 1) ~> stateCodeSink",
						"derivedColumn2 sink(validateSchema: false,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     store: 'cache',",
						"     format: 'inline',",
						"     output: false,",
						"     saveOrder: 1) ~> policyPkeyCache"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_source_policy_partyrole_bridge')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Source Stage Data Flows/txnDataFlow/bridge"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_party",
								"type": "DatasetReference"
							},
							"name": "EcmParty"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_party",
								"type": "DatasetReference"
							},
							"name": "StagingParty"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policy",
								"type": "DatasetReference"
							},
							"name": "StagingPolicy"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_partyrole",
								"type": "DatasetReference"
							},
							"name": "StagingPartyRole"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policy_partyrole_bridge",
								"type": "DatasetReference"
							},
							"name": "bridgeMaxId"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_policy_partyrole_bridge",
								"type": "DatasetReference"
							},
							"name": "StagingPolicyPartyRoleBridge"
						},
						{
							"name": "maxIdCache"
						}
					],
					"transformations": [
						{
							"name": "flowlet1",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "select1"
						},
						{
							"name": "select2"
						},
						{
							"name": "select3"
						},
						{
							"name": "join1"
						},
						{
							"name": "derivedColumn2"
						},
						{
							"name": "flatten1"
						},
						{
							"name": "derivedColumn4"
						},
						{
							"name": "derivedColumn5"
						},
						{
							"name": "select4"
						},
						{
							"name": "join2"
						},
						{
							"name": "sourceStagePartyLookup"
						},
						{
							"name": "surrogateKey2"
						},
						{
							"name": "derivedColumn6"
						},
						{
							"name": "filter1"
						},
						{
							"name": "filter2"
						},
						{
							"name": "filter3"
						},
						{
							"name": "lookup1"
						},
						{
							"name": "select5"
						}
					],
					"scriptLines": [
						"parameters{",
						"     policies as string[] (['']),",
						"     policyPrefix as string ('')",
						"}",
						"source(output(",
						"          Policy as string,",
						"          Policy_Sequence as string,",
						"          EffectiveDate as timestamp,",
						"          ExpirationDate as timestamp,",
						"          LocationNumber as string,",
						"          LocationUnitNumber as string,",
						"          InsuredNumber as short,",
						"          InsuredType as string,",
						"          InsuredSubType as string,",
						"          FirstName as string,",
						"          MiddleName as string,",
						"          LastName as string,",
						"          NameSuffix as string,",
						"          CorporateName as string,",
						"          AlternateName as string,",
						"          MailingAddress1 as string,",
						"          MailingAddress2 as string,",
						"          MailingCity as string,",
						"          MailingZipCode as string,",
						"          DOB as date,",
						"          Relationship as string,",
						"          ExcludedDate as date,",
						"          DW_InsertDate as date",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from Additional_Insured \"+iif(size($policies) >0&& size($policies) ==1&&$policies[1] =='','','where policy in ('+dropLeft(toString(reduce($policies, \"'\", #acc + \",'\" + #item +\"'\", #result)), 2)+')')),",
						"     format: 'query') ~> EcmParty",
						"source(output(",
						"          PARTY_ID as long,",
						"          PARTY_VID as long,",
						"          NAME_PREFIX as string,",
						"          FIRST_NAME as string,",
						"          MIDDLE_NAME as string,",
						"          LAST_NAME as string,",
						"          FULL_NAME as string,",
						"          DATE_OF_BIRTH as timestamp,",
						"          GENDER as string,",
						"          SSN as string,",
						"          HIRE_DATE as timestamp,",
						"          POLICYINATION_DATE as timestamp,",
						"          EMAIL as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          PARTY_TYPE as string,",
						"          PHYSICAL_GEN_ADDRESS_ID as long,",
						"          HOME_PHONE_NUMBER as string,",
						"          FAX_NUMBER as string,",
						"          YEARS_WITH_EMPLOYER as integer,",
						"          NAME_SUFFIX as string,",
						"          MARITAL_STATUS as string,",
						"          OCCUPATION as string,",
						"          DOING_BUSINESS_AS as string,",
						"          DECEASED_DATE as timestamp,",
						"          IS_DECEASED_YN as string,",
						"          GEN_ADDRESS_UNIQ_ID as long,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select * from POL_PARTY',",
						"     format: 'query') ~> StagingParty",
						"source(output(",
						"          POLICY_ID as long,",
						"          POLICY_VID as long,",
						"          REINSURANCE_DAC as string,",
						"          PREVIOUS_INSURANCE_NO_REMARKS as string,",
						"          AGENCY_ID as long,",
						"          AGENCY_OVID as long,",
						"          PRODUCER_ID as long,",
						"          PRODUCER_OVID as long,",
						"          PRODUCER_CONTACT_ID as long,",
						"          PRODUCER_CONTACT_OVID as long,",
						"          POLICY_NUMBER as string,",
						"          ENTITY_TYPE as string,",
						"          ENTITY_STATUS as string,",
						"          IS_RENEWAL_YN as string,",
						"          REVISION_NUMBER as integer,",
						"          PRODUCT_ID as long,",
						"          PRODUCT_OVID as long,",
						"          POLICY_EFFECTIVE_DATE as timestamp,",
						"          POLICY_EXPIRATION_DATE as timestamp,",
						"          NON_RENEWAL_CODE as string,",
						"          POLICY_RENEWED_YN as string,",
						"          CANCELLATION_DATE as timestamp,",
						"          IS_RENEWABLE_YN as string,",
						"          PREVIOUS_INSURANCE_NO_REASON as string,",
						"          POLICY_STATUS as string,",
						"          CANCEL_REASON_CODE as string,",
						"          CANCEL_REASON_DESCRIPTION as string,",
						"          CANCEL_METHOD as string,",
						"          CANCEL_METHOD_DESC as string,",
						"          LOSE_REASON_CODE as string,",
						"          LOSE_REASON_DESC as string,",
						"          DECLINATION_REASON_CODE as string,",
						"          DECLINATION_REASON_DESC as string,",
						"          NOT_WRITTEN_REASON_CODE as string,",
						"          NOT_WRITTEN_REASON_DESC as string,",
						"          POLICY_STATE_CODE as string,",
						"          PROGRAM_ID as long,",
						"          PROGRAM_OVID as long,",
						"          BILLING_TYPE_CODE as string,",
						"          UNDERWRITING_COMPANY_ID as long,",
						"          UNDERWRITING_COMPANY_OVID as long,",
						"          SUBMISSION_ID as long,",
						"          PREVIOUS_INSURANCE_YN as string,",
						"          LEGACY_POLICY_NUMBER as string,",
						"          POLICY_POLICY as short,",
						"          PAYMENT_PLAN as string,",
						"          APPLICATION_RECEIVED_DATE as timestamp,",
						"          INCEPTION_DATE as timestamp,",
						"          BILL_TYPE as string,",
						"          FORMS_LANGUAGE as string,",
						"          BASE_CURRENCY as string,",
						"          INVOICE_CURRENCY as string,",
						"          PREVIOUS_POLICY_ID as long,",
						"          PREVIOUS_POLICY_OVID as long,",
						"          REVISED_FROM_POLICY_ID as long,",
						"          REVISED_FROM_POLICY_OVID as long,",
						"          OPERATING_COMPANY_ID as long,",
						"          OPERATING_COMPANY_OVID as long,",
						"          CONVERTED_FROM_ID as long,",
						"          CONVERTED_FROM_OVID as long,",
						"          INSTALLMENT_RENEWAL as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from POL_POLICY where policy_number like '{$policyPrefix}%'\"+iif(size($policies) >0&& size($policies) ==1&&$policies[1] =='','','and policy_number in ('+dropLeft(toString(reduce($policies, \"'\", #acc + \",'\" + #item +\"'\", #result)), 2)+')')),",
						"     format: 'query') ~> StagingPolicy",
						"source(output(",
						"          ROLE_ID as long,",
						"          ROLE_VID as long,",
						"          ROLE_CODE as string,",
						"          ROLE_DESCRIPTION as string,",
						"          IS_PRIMARY_INSURED_YN as string,",
						"          IS_DRIVER_YN as string,",
						"          IS_CUSTOMER_YN as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> StagingPartyRole",
						"source(output(",
						"          maxId as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT isnull(MAX(POLICY_PARTY_ROLE_BRIDGE_ID), 0) as maxId\\nFROM dbo.POL_POLICY_PARTY_ROLE_BRIDGE',",
						"     format: 'query') ~> bridgeMaxId",
						"derivedColumn6 compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet1@(output1)",
						"EcmParty derive(full_name = iif(isNull(CorporateName)|| trim(CorporateName)=='', concatWS(\" \", trim(FirstName), trim(MiddleName), trim(LastName)), trim(CorporateName))) ~> derivedColumn1",
						"StagingParty select(mapColumn(",
						"          PARTY_ID,",
						"          PARTY_OVID = PARTY_VID,",
						"          FULL_NAME",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"derivedColumn1 select(mapColumn(",
						"          full_name,",
						"          policy = Policy",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select2",
						"StagingPolicy select(mapColumn(",
						"          POLICY_ID,",
						"          POLICY_OVID = POLICY_VID,",
						"          AGENCY_ID,",
						"          AGENCY_OVID,",
						"          PRODUCER_ID,",
						"          PRODUCER_OVID,",
						"          POLICY_NUMBER",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select3",
						"select3, sourceStagePartyLookup join(POLICY_NUMBER == policy,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"filter3 derive(party_id_array = [PARTY_ID,AGENCY_ID,PRODUCER_ID],",
						"          party_ovid_array = [iif(isNull(PARTY_OVID), toLong(1), PARTY_OVID),iif(isNull(AGENCY_OVID), toLong(1), AGENCY_OVID),iif(isNull(PRODUCER_OVID), toLong(1), PRODUCER_OVID)],",
						"          role_array = ['INSURED', 'AGENCY', 'PRODUCER']) ~> derivedColumn2",
						"derivedColumn4 foldDown(unroll(final_array),",
						"     mapColumn(",
						"          POLICY_ID,",
						"          POLICY_OVID,",
						"          final_array",
						"     ),",
						"     skipDuplicateMapInputs: false,",
						"     skipDuplicateMapOutputs: false) ~> flatten1",
						"derivedColumn2 derive(final_array = mapIndex(party_id_array, toString(#item)+'_'+toString(party_ovid_array[#index])+'_'+role_array[#index])) ~> derivedColumn4",
						"flatten1 derive(PARTY_ID = toLong(split(toString(final_array), \"_\")[1]),",
						"          PARTY_OVID = toLong(split(toString(final_array), \"_\")[2]),",
						"          ROLE = split(toString(final_array), \"_\")[3],",
						"          SOURCE_SYSTEM = 'ECM') ~> derivedColumn5",
						"StagingPartyRole select(mapColumn(",
						"          ROLE_ID,",
						"          ROLE_OVID = ROLE_VID,",
						"          ROLE_CODE",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select4",
						"derivedColumn5, select4 join(ROLE == ROLE_CODE,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join2",
						"select2, select1 join(select2@full_name == select1@FULL_NAME,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> sourceStagePartyLookup",
						"filter1 keyGenerate(output(skey as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> surrogateKey2",
						"surrogateKey2 derive(POLICY_PARTY_ROLE_BRIDGE_ID = skey+maxIdCache#outputs()[1].maxId) ~> derivedColumn6",
						"select5 filter(!isNull(POLICY_ID) && !isNull(ROLE_ID) && !isNull(PARTY_ID) && !isNull(POLICY_OVID) && !isNull(ROLE_OVID) && !isNull(PARTY_OVID)) ~> filter1",
						"sourceStagePartyLookup filter(startsWith(policy, 'EMP')) ~> filter2",
						"join1 filter(!isNull(PARTY_ID)) ~> filter3",
						"join2, select1 lookup(derivedColumn5@PARTY_ID == select1@PARTY_ID,",
						"     multiple: false,",
						"     pickup: 'first',",
						"     asc(select1@PARTY_ID, true),",
						"     broadcast: 'auto')~> lookup1",
						"lookup1 select(mapColumn(",
						"          POLICY_ID,",
						"          POLICY_OVID,",
						"          final_array,",
						"          ROLE,",
						"          SOURCE_SYSTEM,",
						"          ROLE_ID,",
						"          ROLE_OVID,",
						"          ROLE_CODE,",
						"          PARTY_ID = select1@PARTY_ID,",
						"          PARTY_OVID = select1@PARTY_OVID,",
						"          FULL_NAME",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select5",
						"flowlet1@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          POLICY_PARTY_ROLE_BRIDGE_ID as long,",
						"          ROLE_ID as long,",
						"          ROLE_OVID as long,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          PARTY_ID as long,",
						"          PARTY_OVID as long,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          SOURCE_SYSTEM as string,",
						"          SOURCE_KEY as string,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DATA_HASH as binary,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> StagingPolicyPartyRoleBridge",
						"bridgeMaxId sink(validateSchema: false,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     store: 'cache',",
						"     format: 'inline',",
						"     output: false,",
						"     saveOrder: 1) ~> maxIdCache"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_source_policy_premium')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Source Stage Data Flows/txnDataFlow"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_txnBridge",
								"type": "DatasetReference"
							},
							"name": "StagingPolTxn"
						},
						{
							"dataset": {
								"referenceName": "ds_source_Fact_Coverage_Premium",
								"type": "DatasetReference"
							},
							"name": "FactCoveragePremium"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policy",
								"type": "DatasetReference"
							},
							"name": "StagingPolicy"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_polTxn",
								"type": "DatasetReference"
							},
							"name": "source1"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_polTxnPremium",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "flowlet1",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "select1"
						},
						{
							"name": "lookup2"
						},
						{
							"name": "select2"
						},
						{
							"name": "lookup3"
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "join1"
						}
					],
					"scriptLines": [
						"parameters{",
						"     policyPrefix as string,",
						"     policies as string[]",
						"}",
						"source(output(",
						"          TX_BRIDGE_ID as long,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          TX_ID as long,",
						"          SECTION_ID as long,",
						"          SECTION_VID as long,",
						"          RISK_ID as long,",
						"          RISK_OVID as long,",
						"          CLASSIFICATION_ID as long,",
						"          CLASSIFICATION_OVID as long,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          DATA_HASH as binary,",
						"          SOURCE_KEY as string,",
						"          COVERAGE_ID as long,",
						"          COVERAGE_VID as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> StagingPolTxn",
						"source(output(",
						"          Policy as string,",
						"          Policy_Sequence as string,",
						"          PolicyPrefix as string,",
						"          ARICLOB as string,",
						"          ARICGroupCode as string,",
						"          Description as string,",
						"          Product as string,",
						"          ARICCoverageCode as string,",
						"          ARICCoverageDescription as string,",
						"          PrimaryPremiumStateCode as string,",
						"          LocationNumber as string,",
						"          LocationUnitNumber as string,",
						"          ARICCoverageSequence as integer,",
						"          CoveragePart as string,",
						"          CoverageAddDate as timestamp,",
						"          CoverageDescription as string,",
						"          Limit1 as decimal(38,0),",
						"          Limit2 as decimal(38,0),",
						"          PremiumAmount as decimal(38,2)",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from Fact_Coverage_Premium where PolicyPrefix='{$policyPrefix}'\"+iif(size($policies) >0&& size($policies) ==1&&$policies[1] =='','','and policy in ('+dropLeft(toString(reduce($policies, \"'\", #acc + \",'\" + #item +\"'\", #result)), 2)+')')),",
						"     format: 'query') ~> FactCoveragePremium",
						"source(output(",
						"          POLICY_ID as long,",
						"          POLICY_VID as long,",
						"          REINSURANCE_DAC as string,",
						"          PREVIOUS_INSURANCE_NO_REMARKS as string,",
						"          AGENCY_ID as long,",
						"          AGENCY_OVID as long,",
						"          PRODUCER_ID as long,",
						"          PRODUCER_OVID as long,",
						"          PRODUCER_CONTACT_ID as long,",
						"          PRODUCER_CONTACT_OVID as long,",
						"          POLICY_NUMBER as string,",
						"          ENTITY_TYPE as string,",
						"          ENTITY_STATUS as string,",
						"          IS_RENEWAL_YN as string,",
						"          REVISION_NUMBER as integer,",
						"          PRODUCT_ID as long,",
						"          PRODUCT_OVID as long,",
						"          POLICY_EFFECTIVE_DATE as timestamp,",
						"          POLICY_EXPIRATION_DATE as timestamp,",
						"          NON_RENEWAL_CODE as string,",
						"          POLICY_RENEWED_YN as string,",
						"          CANCELLATION_DATE as timestamp,",
						"          IS_RENEWABLE_YN as string,",
						"          PREVIOUS_INSURANCE_NO_REASON as string,",
						"          POLICY_STATUS as string,",
						"          CANCEL_REASON_CODE as string,",
						"          CANCEL_REASON_DESCRIPTION as string,",
						"          CANCEL_METHOD as string,",
						"          CANCEL_METHOD_DESC as string,",
						"          LOSE_REASON_CODE as string,",
						"          LOSE_REASON_DESC as string,",
						"          DECLINATION_REASON_CODE as string,",
						"          DECLINATION_REASON_DESC as string,",
						"          NOT_WRITTEN_REASON_CODE as string,",
						"          NOT_WRITTEN_REASON_DESC as string,",
						"          POLICY_STATE_CODE as string,",
						"          PROGRAM_ID as long,",
						"          PROGRAM_OVID as long,",
						"          BILLING_TYPE_CODE as string,",
						"          UNDERWRITING_COMPANY_ID as long,",
						"          UNDERWRITING_COMPANY_OVID as long,",
						"          SUBMISSION_ID as long,",
						"          PREVIOUS_INSURANCE_YN as string,",
						"          LEGACY_POLICY_NUMBER as string,",
						"          STATE as string,",
						"          POLICY_POLICY as integer,",
						"          PAYMENT_PLAN as string,",
						"          APPLICATION_RECEIVED_DATE as timestamp,",
						"          INCEPTION_DATE as timestamp,",
						"          BILL_TYPE as string,",
						"          FORMS_LANGUAGE as string,",
						"          BASE_CURRENCY as string,",
						"          INVOICE_CURRENCY as string,",
						"          PREVIOUS_POLICY_ID as long,",
						"          PREVIOUS_POLICY_OVID as long,",
						"          REVISED_FROM_POLICY_ID as long,",
						"          REVISED_FROM_POLICY_OVID as long,",
						"          OPERATING_COMPANY_ID as long,",
						"          OPERATING_COMPANY_OVID as long,",
						"          CONVERTED_FROM_ID as long,",
						"          CONVERTED_FROM_OVID as long,",
						"          INSTALLMENT_RENEWAL as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from [dbo].[POL_POLICY] where ENTITY_TYPE ='{$policyPrefix}' \"+iif(size($policies) >0&& size($policies) ==1&&$policies[1] =='','','and policy_number in ('+dropLeft(toString(reduce($policies, \"'\", #acc + \",'\" + #item +\"'\", #result)), 2)+')')),",
						"     format: 'query') ~> StagingPolicy",
						"source(output(",
						"          TX_ID as long,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          TX_CODE as string,",
						"          SUB_ACTIVITY as string,",
						"          ENDORSEMENT_SEQ_NO as integer,",
						"          IS_SYSTEM_GENERATED_YN as string,",
						"          ENDORSEMENT_CHANGES as string,",
						"          TRANSACTION_EFFECTIVE_DATE as timestamp,",
						"          TRANSACTION_EXPIRY_DATE as timestamp,",
						"          TRANSACTION_BOOK_FLAG_DATE as timestamp,",
						"          PARENT_TRANSACTION_ID as integer,",
						"          TRANSACTION_TYPE_CODE as string,",
						"          TYPE_OF_CHANGE as string,",
						"          TRANSACTION_CREATED_DATE as timestamp,",
						"          TRANSACTION_MODIFIED_DATE as timestamp,",
						"          TRANSACTION_DISPLAY_NAME as string,",
						"          TRANSACTION_PERIOD_PRORATION as decimal(19,9),",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          DATA_HASH as binary,",
						"          SOURCE_KEY as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> source1",
						"derivedColumn1 compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet1@(output1)",
						"StagingPolicy select(mapColumn(",
						"          POLICY_ID,",
						"          POLICY_VID,",
						"          POLICY_NUMBER",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"lookup3, FactCoveragePremium lookup(POLICY_NUMBER == Policy",
						"     && TX_CODE == concat(Policy_Sequence,'-',LocationNumber,'-',LocationUnitNumber,'-',ARICGroupCode,'-',PrimaryPremiumStateCode,'-', ARICLOB,'-',ARICCoverageCode,'-',toString(ARICCoverageSequence)),",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lookup2",
						"source1 select(mapColumn(",
						"          TX_ID,",
						"          TX_CODE",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select2",
						"join1, select2 lookup(StagingPolTxn@TX_ID == select2@TX_ID,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lookup3",
						"lookup2 derive(TX_ID = StagingPolTxn@TX_ID,",
						"          TX_BRIDGE_ID = TX_BRIDGE_ID,",
						"          POLICY_ID = StagingPolTxn@POLICY_ID,",
						"          POLICY_OVID = POLICY_OVID,",
						"          FULL_POLICY_AMOUNT = PremiumAmount) ~> derivedColumn1",
						"StagingPolTxn, select1 join(StagingPolTxn@POLICY_ID == select1@POLICY_ID,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"flowlet1@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          AGENCY_ID as long,",
						"          AGENCY_VID as long,",
						"          AGENCY_GEN_ADDRESS_ID as long,",
						"          AGENCY_CODE as string,",
						"          AGENCY_NAME as string,",
						"          AGENCY_STATUS as string,",
						"          AGENCY_CATEGORY as string,",
						"          DIRECT_BILL_FLAG_YN as string,",
						"          TELEPHONE as string,",
						"          FAX as string,",
						"          EMAIL_ID as string,",
						"          WEBSITE as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          ENTITY_TYPE as string,",
						"          ENTITY_PARENT_ID as long",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink1"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_source_policy_risk_cfa')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Source Stage Data Flows/txnDataFlow"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_PolicyAutoUnit",
								"type": "DatasetReference"
							},
							"name": "autoUnitSource"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policy",
								"type": "DatasetReference"
							},
							"name": "stgPolicy"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRisk",
								"type": "DatasetReference"
							},
							"name": "riskStaging"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRisk",
								"type": "DatasetReference"
							},
							"name": "PolRisk"
						},
						{
							"name": "maxId"
						}
					],
					"transformations": [
						{
							"name": "flowlet1",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "derivedColumn6"
						},
						{
							"name": "surrogateKey1"
						},
						{
							"name": "join1"
						}
					],
					"scriptLines": [
						"parameters{",
						"     policyPrefix as string,",
						"     policies as string[]",
						"}",
						"source(output(",
						"          PolicyPrefix as string,",
						"          Policy as string,",
						"          Policy_Sequence as string,",
						"          RowStatus as string,",
						"          EffectiveDate as timestamp,",
						"          ExpirationDate as timestamp,",
						"          LocationNumber as string,",
						"          LocationUnitNumber as string,",
						"          {UnitType/ModificationType} as string,",
						"          YearBuild as short,",
						"          UnitValue as decimal(13,0),",
						"          RiskUseCode as string,",
						"          Make as string,",
						"          Model as string,",
						"          UnitWidth as short,",
						"          ISOClassCode as string,",
						"          RiskType as string,",
						"          UnitLength as short,",
						"          PurchaseDate as timestamp,",
						"          AppraisalYear as short,",
						"          UnitDescription as string,",
						"          AnimalUseCode as string,",
						"          LeaseFlag as string,",
						"          AppraisalFlag as string,",
						"          RegistrationState as string,",
						"          VehicleID as string,",
						"          EngineDisplacement as short,",
						"          FuelTypeCode as string,",
						"          Layup as string,",
						"          ID as integer,",
						"          DataSource as string,",
						"          DW_InsertDate as date",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from [dbo].[PolicyAutoUnit_P]  where PolicyPrefix='{$policyPrefix}'\"+iif(size($policies) >0&& size($policies) ==1&&$policies[1] =='','','and policy in ('+dropLeft(toString(reduce($policies, \"'\", #acc + \",'\" + #item +\"'\", #result)), 2)+')')),",
						"     format: 'query') ~> autoUnitSource",
						"source(output(",
						"          POLICY_ID as long,",
						"          POLICY_VID as long,",
						"          REINSURANCE_DAC as string,",
						"          PREVIOUS_INSURANCE_NO_REMARKS as string,",
						"          AGENCY_ID as long,",
						"          AGENCY_OVID as long,",
						"          PRODUCER_ID as long,",
						"          PRODUCER_OVID as long,",
						"          PRODUCER_CONTACT_ID as long,",
						"          PRODUCER_CONTACT_OVID as long,",
						"          POLICY_NUMBER as string,",
						"          ENTITY_TYPE as string,",
						"          ENTITY_STATUS as string,",
						"          IS_RENEWAL_YN as string,",
						"          REVISION_NUMBER as integer,",
						"          PRODUCT_ID as long,",
						"          PRODUCT_OVID as long,",
						"          POLICY_EFFECTIVE_DATE as timestamp,",
						"          POLICY_EXPIRATION_DATE as timestamp,",
						"          NON_RENEWAL_CODE as string,",
						"          POLICY_RENEWED_YN as string,",
						"          CANCELLATION_DATE as timestamp,",
						"          IS_RENEWABLE_YN as string,",
						"          PREVIOUS_INSURANCE_NO_REASON as string,",
						"          POLICY_STATUS as string,",
						"          CANCEL_REASON_CODE as string,",
						"          CANCEL_REASON_DESCRIPTION as string,",
						"          CANCEL_METHOD as string,",
						"          CANCEL_METHOD_DESC as string,",
						"          LOSE_REASON_CODE as string,",
						"          LOSE_REASON_DESC as string,",
						"          DECLINATION_REASON_CODE as string,",
						"          DECLINATION_REASON_DESC as string,",
						"          NOT_WRITTEN_REASON_CODE as string,",
						"          NOT_WRITTEN_REASON_DESC as string,",
						"          POLICY_STATE_CODE as string,",
						"          PROGRAM_ID as long,",
						"          PROGRAM_OVID as long,",
						"          BILLING_TYPE_CODE as string,",
						"          UNDERWRITING_COMPANY_ID as long,",
						"          UNDERWRITING_COMPANY_OVID as long,",
						"          SUBMISSION_ID as long,",
						"          PREVIOUS_INSURANCE_YN as string,",
						"          LEGACY_POLICY_NUMBER as string,",
						"          STATE as string,",
						"          POLICY_POLICY as integer,",
						"          PAYMENT_PLAN as string,",
						"          APPLICATION_RECEIVED_DATE as timestamp,",
						"          INCEPTION_DATE as timestamp,",
						"          BILL_TYPE as string,",
						"          FORMS_LANGUAGE as string,",
						"          BASE_CURRENCY as string,",
						"          INVOICE_CURRENCY as string,",
						"          PREVIOUS_POLICY_ID as long,",
						"          PREVIOUS_POLICY_OVID as long,",
						"          REVISED_FROM_POLICY_ID as long,",
						"          REVISED_FROM_POLICY_OVID as long,",
						"          OPERATING_COMPANY_ID as long,",
						"          OPERATING_COMPANY_OVID as long,",
						"          CONVERTED_FROM_ID as long,",
						"          CONVERTED_FROM_OVID as long,",
						"          INSTALLMENT_RENEWAL as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from POL_POLICY where policy_number like '{$policyPrefix}%'\"+iif(size($policies) >0&& size($policies) ==1&&$policies[1] =='','','and policy_number in ('+dropLeft(toString(reduce($policies, \"'\", #acc + \",'\" + #item +\"'\", #result)), 2)+')')),",
						"     format: 'query') ~> stgPolicy",
						"source(output(",
						"          riskid as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select isNull(MAX(RISK_ID),0) as riskid from POL_RISK',",
						"     format: 'query') ~> riskStaging",
						"derivedColumn6 compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet1@(output1)",
						"surrogateKey1 derive(RISK_ID = skey + maxId#outputs()[1].riskid,",
						"          RISK_VID = 1,",
						"          POLICY_ID = POLICY_ID,",
						"          RISK_IS_ACTIVE_YN = \"Y\",",
						"          RISK_EFF_DATE = EffectiveDate,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_EXP_DATE = ExpirationDate,",
						"          POLICY_OVID = POLICY_VID,",
						"          RISK_CODE = {UnitType/ModificationType},",
						"          RISK_NUMBER = concat(LocationNumber,'-',LocationUnitNumber)) ~> derivedColumn6",
						"join1 keyGenerate(output(skey as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> surrogateKey1",
						"autoUnitSource, stgPolicy join(Policy == POLICY_NUMBER,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"flowlet1@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_NUMBER as string,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          RISK_IS_ACTIVE_YN as string,",
						"          RISK_EFF_DATE as timestamp,",
						"          RISK_EXP_DATE as timestamp,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> PolRisk",
						"riskStaging sink(validateSchema: false,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     store: 'cache',",
						"     format: 'inline',",
						"     output: false,",
						"     saveOrder: 1) ~> maxId"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_source_policy_risk_emp')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Source Stage Data Flows/txnDataFlow"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_propertyUnits",
								"type": "DatasetReference"
							},
							"name": "PropertyUnits"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policy",
								"type": "DatasetReference"
							},
							"name": "stgPolicy"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRisk",
								"type": "DatasetReference"
							},
							"name": "riskStaging"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRisk",
								"type": "DatasetReference"
							},
							"name": "PolRisk"
						},
						{
							"name": "maxId"
						}
					],
					"transformations": [
						{
							"name": "flowlet1",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "stgPolicySelect"
						},
						{
							"name": "derivedColumn6"
						},
						{
							"name": "surrogateKey1"
						},
						{
							"name": "join1"
						}
					],
					"scriptLines": [
						"parameters{",
						"     policyPrefix as string,",
						"     policies as string[]",
						"}",
						"source(output(",
						"          PolicyPrefix as string,",
						"          Policy as string,",
						"          Policy_Sequence as string,",
						"          RowStatus as string,",
						"          EffectiveDate as timestamp,",
						"          ExpirationDate as timestamp,",
						"          LocationNumber as string,",
						"          LocationUnitNumber as string,",
						"          {UnitType/ModificationType} as string,",
						"          YearBuild as short,",
						"          UnitValue as decimal(13,0),",
						"          SquareFootage as integer,",
						"          RiskUseCode as string,",
						"          Occupancy as string,",
						"          RoofTypeCode as string,",
						"          RoofYear as short,",
						"          Make as string,",
						"          Model as string,",
						"          SerialNumber as string,",
						"          UnitWidth as short,",
						"          RiskType as string,",
						"          UnitLength as short,",
						"          PurchasePrice as decimal(9,0),",
						"          PurchaseDate as timestamp,",
						"          NewUsed as string,",
						"          ProtectionClass as string,",
						"          NumberOfSections as decimal(1,0),",
						"          AppraisalYear as short,",
						"          AppraisedValue as decimal(9,0),",
						"          ConstructionTypeCode as string,",
						"          ParkCode as string,",
						"          OrdinanceLawPercent as decimal(5,2),",
						"          PropertyLossScore as string,",
						"          ProtectedRiskFlag as string,",
						"          PreferredRiskFlag as string,",
						"          ReplaceOrFullRepair as string,",
						"          MineSubsidenceFlag as string,",
						"          NumberOfStories as decimal(3,0),",
						"          InZoneFlag as string,",
						"          BasicFlag as string,",
						"          DwellingUnits as string,",
						"          ElectricSystemTypeCode as string,",
						"          PlumbingSystemTypeCode as string,",
						"          ExtentOfRoofUpdateCode as string,",
						"          ElectricSystemYear as short,",
						"          ExtentOfElectricSystemUpdate as string,",
						"          PlumbingSystemYear as short,",
						"          ExtentOfPlumbingSystemUpdate as string,",
						"          HeatingSystemYear as short,",
						"          ExtentOfHeatingSystemUpdate as string,",
						"          MilesToFireDepartmentCode as string,",
						"          FeetToHydrantCode as string,",
						"          UnitDescription as string,",
						"          InflationGuardPercent as decimal(6,3),",
						"          NumberOfHouseholds as short,",
						"          AnimalUseCode as string,",
						"          AnimalOtherUse as string,",
						"          LeaseFlag as string,",
						"          ID as integer,",
						"          DataSource as string,",
						"          FirelineScore as string,",
						"          FirelineStatus as string,",
						"          FirelineDate as timestamp,",
						"          AnimalDOB as timestamp,",
						"          AnimalName as string,",
						"          AnimalBreed as string,",
						"          AnimalBreedOtherDescription as string,",
						"          AnimalSireName as string,",
						"          AnimalDamName as string,",
						"          AnimalSex as string,",
						"          DW_InsertDate as date,",
						"          CoveragePart as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from [dbo].[PolicyPropertyUnit_P]  where TRIM(AnimalUseCode) != '?' and TRIM(RowStatus) != 'D' and (TRIM(AnimalBreed) != '' or TRIM(AnimalUseCode) != '') and PolicyPrefix='{$policyPrefix}'\"+iif(size($policies) >0&& size($policies) ==1&&$policies[1] =='','','and policy in ('+dropLeft(toString(reduce($policies, \"'\", #acc + \",'\" + #item +\"'\", #result)), 2)+')')),",
						"     format: 'query') ~> PropertyUnits",
						"source(output(",
						"          POLICY_ID as long,",
						"          POLICY_VID as long,",
						"          REINSURANCE_DAC as string,",
						"          PREVIOUS_INSURANCE_NO_REMARKS as string,",
						"          AGENCY_ID as long,",
						"          AGENCY_OVID as long,",
						"          PRODUCER_ID as long,",
						"          PRODUCER_OVID as long,",
						"          PRODUCER_CONTACT_ID as long,",
						"          PRODUCER_CONTACT_OVID as long,",
						"          POLICY_NUMBER as string,",
						"          ENTITY_TYPE as string,",
						"          ENTITY_STATUS as string,",
						"          IS_RENEWAL_YN as string,",
						"          REVISION_NUMBER as integer,",
						"          PRODUCT_ID as long,",
						"          PRODUCT_OVID as long,",
						"          POLICY_EFFECTIVE_DATE as timestamp,",
						"          POLICY_EXPIRATION_DATE as timestamp,",
						"          NON_RENEWAL_CODE as string,",
						"          POLICY_RENEWED_YN as string,",
						"          CANCELLATION_DATE as timestamp,",
						"          IS_RENEWABLE_YN as string,",
						"          PREVIOUS_INSURANCE_NO_REASON as string,",
						"          POLICY_STATUS as string,",
						"          CANCEL_REASON_CODE as string,",
						"          CANCEL_REASON_DESCRIPTION as string,",
						"          CANCEL_METHOD as string,",
						"          CANCEL_METHOD_DESC as string,",
						"          LOSE_REASON_CODE as string,",
						"          LOSE_REASON_DESC as string,",
						"          DECLINATION_REASON_CODE as string,",
						"          DECLINATION_REASON_DESC as string,",
						"          NOT_WRITTEN_REASON_CODE as string,",
						"          NOT_WRITTEN_REASON_DESC as string,",
						"          POLICY_STATE_CODE as string,",
						"          PROGRAM_ID as long,",
						"          PROGRAM_OVID as long,",
						"          BILLING_TYPE_CODE as string,",
						"          UNDERWRITING_COMPANY_ID as long,",
						"          UNDERWRITING_COMPANY_OVID as long,",
						"          SUBMISSION_ID as long,",
						"          PREVIOUS_INSURANCE_YN as string,",
						"          LEGACY_POLICY_NUMBER as string,",
						"          STATE as string,",
						"          POLICY_POLICY as integer,",
						"          PAYMENT_PLAN as string,",
						"          APPLICATION_RECEIVED_DATE as timestamp,",
						"          INCEPTION_DATE as timestamp,",
						"          BILL_TYPE as string,",
						"          FORMS_LANGUAGE as string,",
						"          BASE_CURRENCY as string,",
						"          INVOICE_CURRENCY as string,",
						"          PREVIOUS_POLICY_ID as long,",
						"          PREVIOUS_POLICY_OVID as long,",
						"          REVISED_FROM_POLICY_ID as long,",
						"          REVISED_FROM_POLICY_OVID as long,",
						"          OPERATING_COMPANY_ID as long,",
						"          OPERATING_COMPANY_OVID as long,",
						"          CONVERTED_FROM_ID as long,",
						"          CONVERTED_FROM_OVID as long,",
						"          INSTALLMENT_RENEWAL as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> stgPolicy",
						"source(output(",
						"          riskid as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select isNull(MAX(RISK_ID),0) as riskid from POL_RISK',",
						"     format: 'query') ~> riskStaging",
						"derivedColumn6 compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet1@(output1)",
						"stgPolicy select(mapColumn(",
						"          POLICY_ID,",
						"          POLICY_VID",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> stgPolicySelect",
						"surrogateKey1 derive(RISK_ID = skey + maxId#outputs()[1].riskid,",
						"          RISK_VID = 1,",
						"          POLICY_ID = POLICY_ID,",
						"          RISK_IS_ACTIVE_YN = \"Y\",",
						"          RISK_EFF_DATE = EffectiveDate,",
						"          RISK_TYPE_CD = RiskType,",
						"          RISK_EXP_DATE = ExpirationDate,",
						"          POLICY_OVID = POLICY_VID,",
						"          RISK_CODE = RiskUseCode,",
						"          RISK_NUMBER = concat(LocationNumber,'-',LocationUnitNumber)) ~> derivedColumn6",
						"join1 keyGenerate(output(skey as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> surrogateKey1",
						"PropertyUnits, stgPolicy join(Policy == POLICY_NUMBER,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"flowlet1@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_NUMBER as string,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          RISK_IS_ACTIVE_YN as string,",
						"          RISK_EFF_DATE as timestamp,",
						"          RISK_EXP_DATE as timestamp,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> PolRisk",
						"riskStaging sink(validateSchema: false,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     store: 'cache',",
						"     format: 'inline',",
						"     output: false,",
						"     saveOrder: 1) ~> maxId"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_source_policy_section')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Source Stage Data Flows/txnDataFlow"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_policy",
								"type": "DatasetReference"
							},
							"name": "source1"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_polSection",
								"type": "DatasetReference"
							},
							"name": "source2"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_lob",
								"type": "DatasetReference"
							},
							"name": "lobStg"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_sub_LOB",
								"type": "DatasetReference"
							},
							"name": "subLobStg"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_polSection",
								"type": "DatasetReference"
							},
							"name": "sink1"
						},
						{
							"name": "sink2"
						}
					],
					"transformations": [
						{
							"name": "flowlet1",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "derivedColumn2"
						},
						{
							"name": "surrogateKey1"
						},
						{
							"name": "lobLookup"
						},
						{
							"name": "subLobCode"
						},
						{
							"name": "select1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          COVERAGE_ID as long,",
						"          COVERAGE_OVID as long,",
						"          LOCATION_ID as long,",
						"          LOCATION_OVID as long,",
						"          COVERAGE_CODE as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select pp.POLICY_ID,pp.POLICY_VID as POLICY_OVID,pc.COVERAGE_ID,pc.COVERAGE_VID as COVERAGE_OVID,pl.LOCATION_ID,pl.LOCATION_VID as LOCATION_OVID,pc.COVERAGE_CODE from POL_POLICY pp \\njoin POL_COVERAGE pc\\non pp.POLICY_ID = pc.POLICY_ID\\njoin POL_LOCATION pl\\non pl.POLICY_ID=pp.POLICY_ID',",
						"     format: 'query') ~> source1",
						"source(output(",
						"          SECTION_ID as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select MAX(SECTION_ID)  as SECTION_ID from dbo.POL_SECTION',",
						"     format: 'query') ~> source2",
						"source(output(",
						"          LOB_ID as long,",
						"          LOB_CODE as string,",
						"          LOB_NAME as string,",
						"          LOB_DESCRIPTION as string,",
						"          LOB_IS_VALID_YN as string,",
						"          LOB_VALID_START_DATE as timestamp,",
						"          LOB_VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> lobStg",
						"source(output(",
						"          SUB_LOB_ID as long,",
						"          SUB_LOB_CODE as string,",
						"          SUB_LOB_NAME as string,",
						"          SUB_LOB_DESCRIPTION as string,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> subLobStg",
						"select1 compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet1@(output1)",
						"surrogateKey1 derive(SECTION_ID = pkey + sink2#outputs()[1].SECTION_ID,",
						"          SECTION_VID = 1,",
						"          LOB_CODE = split(COVERAGE_CODE, '-')[3],",
						"          SUB_LOB_CODE = split(COVERAGE_CODE, '-')[4],",
						"          PRIMARY_POLICY_STATE = split(COVERAGE_CODE, '-')[2]) ~> derivedColumn1",
						"source2 derive(SECTION_ID = iifNull(SECTION_ID, 0, SECTION_ID)) ~> derivedColumn2",
						"source1 keyGenerate(output(pkey as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> surrogateKey1",
						"derivedColumn1, lobStg lookup(derivedColumn1@LOB_CODE == lobStg@LOB_CODE,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lobLookup",
						"lobLookup, subLobStg lookup(derivedColumn1@SUB_LOB_CODE == subLobStg@SUB_LOB_CODE,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> subLobCode",
						"subLobCode select(mapColumn(",
						"          POLICY_ID,",
						"          POLICY_OVID,",
						"          COVERAGE_ID,",
						"          COVERAGE_OVID,",
						"          LOCATION_ID,",
						"          LOCATION_OVID,",
						"          SECTION_ID,",
						"          SECTION_VID,",
						"          LOB_ID,",
						"          SUB_LOB_ID,",
						"          PRIMARY_POLICY_STATE",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"flowlet1@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          SECTION_ID as long,",
						"          SECTION_VID as long,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          COVERAGE_ID as long,",
						"          COVERAGE_OVID as long,",
						"          LOCATION_ID as long,",
						"          LOCATION_OVID as long,",
						"          LOB_ID as long,",
						"          SUB_LOB_ID as long,",
						"          RATE_SET_DATE as timestamp,",
						"          PRIMARY_POLICY_STATE as string,",
						"          BATCH_ID as long,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          DATA_HASH as binary,",
						"          SOURCE_KEY as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink1",
						"derivedColumn2 sink(validateSchema: false,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     store: 'cache',",
						"     format: 'inline',",
						"     output: false,",
						"     saveOrder: 1) ~> sink2"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_source_policy_tx_bridge')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Source Stage Data Flows/txnDataFlow/bridge"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_polTxn",
								"type": "DatasetReference"
							},
							"name": "polTxnStg"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_coverage",
								"type": "DatasetReference"
							},
							"name": "coverageStg"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policyRisk",
								"type": "DatasetReference"
							},
							"name": "source1"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_polSection",
								"type": "DatasetReference"
							},
							"name": "polSection"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_txnBridge",
								"type": "DatasetReference"
							},
							"name": "txnBridgeStagingMaxId"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policy",
								"type": "DatasetReference"
							},
							"name": "stagingPolicy"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_txnBridge",
								"type": "DatasetReference"
							},
							"name": "sink1"
						},
						{
							"name": "maxIdCache"
						}
					],
					"transformations": [
						{
							"name": "flowlet1",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "select1"
						},
						{
							"name": "lookup2"
						},
						{
							"name": "select2"
						},
						{
							"name": "surrogateKey1"
						},
						{
							"name": "select3"
						},
						{
							"name": "lookup3"
						},
						{
							"name": "derivedColumn2"
						},
						{
							"name": "join1"
						},
						{
							"name": "join2"
						},
						{
							"name": "select4"
						},
						{
							"name": "select6"
						}
					],
					"scriptLines": [
						"parameters{",
						"     policyPrefix as string ('EMP'),",
						"     policies as string[] ([\"EMP009688\"])",
						"}",
						"source(output(",
						"          TX_ID as long,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          TX_CODE as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT  distinct TX_ID,POLICY_ID,POLICY_OVID,TX_CODE FROM [DM_Source_Stage].[dbo].[POL_TX]  ',",
						"     format: 'query') ~> polTxnStg",
						"source(output(",
						"          COVERAGE_ID as long,",
						"          COVERAGE_VID as long,",
						"          COVERAGE_CODE_ID as long,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          COV_STATE_ID as long,",
						"          COVERAGE_EFFECTIVE_DATE as timestamp,",
						"          COVERAGE_EXPIRATION_DATE as timestamp,",
						"          ASL_CODE as string,",
						"          ASSL_CODE as string,",
						"          ASL_CODE_GBL as string,",
						"          ASSL_CODE_GBL as string,",
						"          CLASSIFICATION_CODE_ID as long,",
						"          CLASSIFICATION_CODE_OVID as long,",
						"          COVERAGE_CODE as string,",
						"          RETROACTIVE_DATE as timestamp,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select * from [dbo].[POL_COVERAGE] ',",
						"     format: 'query') ~> coverageStg",
						"source(output(",
						"          RISK_ID as long,",
						"          RISK_VID as long,",
						"          RISK_NUMBER as string,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          RISK_IS_ACTIVE_YN as string,",
						"          RISK_EFF_DATE as timestamp,",
						"          RISK_EXP_DATE as timestamp,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          RISK_TYPE_CD as string,",
						"          RISK_CODE as string,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'select * FROM [DM_Source_Stage].[dbo].[POL_RISK] ',",
						"     format: 'query') ~> source1",
						"source(output(",
						"          SECTION_ID as long,",
						"          SECTION_VID as long,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          COVERAGE_ID as long,",
						"          COVERAGE_OVID as long,",
						"          LOCATION_ID as long,",
						"          LOCATION_OVID as long,",
						"          LOB_ID as long,",
						"          SUB_LOB_ID as long,",
						"          RATE_SET_DATE as timestamp,",
						"          PRIMARY_POLICY_STATE as string,",
						"          BATCH_ID as long,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          DATA_HASH as binary,",
						"          SOURCE_KEY as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     format: 'table') ~> polSection",
						"source(output(",
						"          maxId as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT isnull(MAX(TX_BRIDGE_ID), 0) as maxId\\nFROM dbo.POL_TX_BRIDGE',",
						"     format: 'query') ~> txnBridgeStagingMaxId",
						"source(output(",
						"          POLICY_ID as long,",
						"          POLICY_VID as long,",
						"          REINSURANCE_DAC as string,",
						"          PREVIOUS_INSURANCE_NO_REMARKS as string,",
						"          AGENCY_ID as long,",
						"          AGENCY_OVID as long,",
						"          PRODUCER_ID as long,",
						"          PRODUCER_OVID as long,",
						"          PRODUCER_CONTACT_ID as long,",
						"          PRODUCER_CONTACT_OVID as long,",
						"          POLICY_NUMBER as string,",
						"          ENTITY_TYPE as string,",
						"          ENTITY_STATUS as string,",
						"          IS_RENEWAL_YN as string,",
						"          REVISION_NUMBER as integer,",
						"          PRODUCT_ID as long,",
						"          PRODUCT_OVID as long,",
						"          POLICY_EFFECTIVE_DATE as timestamp,",
						"          POLICY_EXPIRATION_DATE as timestamp,",
						"          NON_RENEWAL_CODE as string,",
						"          POLICY_RENEWED_YN as string,",
						"          CANCELLATION_DATE as timestamp,",
						"          IS_RENEWABLE_YN as string,",
						"          PREVIOUS_INSURANCE_NO_REASON as string,",
						"          POLICY_STATUS as string,",
						"          CANCEL_REASON_CODE as string,",
						"          CANCEL_REASON_DESCRIPTION as string,",
						"          CANCEL_METHOD as string,",
						"          CANCEL_METHOD_DESC as string,",
						"          LOSE_REASON_CODE as string,",
						"          LOSE_REASON_DESC as string,",
						"          DECLINATION_REASON_CODE as string,",
						"          DECLINATION_REASON_DESC as string,",
						"          NOT_WRITTEN_REASON_CODE as string,",
						"          NOT_WRITTEN_REASON_DESC as string,",
						"          POLICY_STATE_CODE as string,",
						"          PROGRAM_ID as long,",
						"          PROGRAM_OVID as long,",
						"          BILLING_TYPE_CODE as string,",
						"          UNDERWRITING_COMPANY_ID as long,",
						"          UNDERWRITING_COMPANY_OVID as long,",
						"          SUBMISSION_ID as long,",
						"          PREVIOUS_INSURANCE_YN as string,",
						"          LEGACY_POLICY_NUMBER as string,",
						"          STATE as string,",
						"          POLICY_POLICY as integer,",
						"          PAYMENT_PLAN as string,",
						"          APPLICATION_RECEIVED_DATE as timestamp,",
						"          INCEPTION_DATE as timestamp,",
						"          BILL_TYPE as string,",
						"          FORMS_LANGUAGE as string,",
						"          BASE_CURRENCY as string,",
						"          INVOICE_CURRENCY as string,",
						"          PREVIOUS_POLICY_ID as long,",
						"          PREVIOUS_POLICY_OVID as long,",
						"          REVISED_FROM_POLICY_ID as long,",
						"          REVISED_FROM_POLICY_OVID as long,",
						"          OPERATING_COMPANY_ID as long,",
						"          OPERATING_COMPANY_OVID as long,",
						"          CONVERTED_FROM_ID as long,",
						"          CONVERTED_FROM_OVID as long,",
						"          INSTALLMENT_RENEWAL as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from [dbo].[POL_POLICY] where ENTITY_TYPE ='{$policyPrefix}' \"+iif(size($policies) >0&& size($policies) ==1&&$policies[1] =='','','and policy_number in ('+dropLeft(toString(reduce($policies, \"'\", #acc + \",'\" + #item +\"'\", #result)), 2)+')')),",
						"     format: 'query') ~> stagingPolicy",
						"derivedColumn2 compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet1@(output1)",
						"join2 derive(POLICY_ID = select4@POLICY_ID,",
						"          POLICY_OVID = select4@POLICY_OVID,",
						"          COVERAGE_ID = COVERAGE_ID,",
						"          COVERAGE_VID = COVERAGE_VID) ~> derivedColumn1",
						"derivedColumn1 select(mapColumn(",
						"          TX_ID,",
						"          POLICY_ID,",
						"          POLICY_OVID,",
						"          TX_CODE,",
						"          COVERAGE_VID,",
						"          COVERAGE_CODE,",
						"          COVERAGE_ID",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"select1, select2 lookup(select1@POLICY_ID == select2@POLICY_ID",
						"     && concat(split(TX_CODE,'-')[2],'-',split(TX_CODE,'-')[3]) == RISK_NUMBER,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lookup2",
						"source1 select(mapColumn(",
						"          RISK_ID,",
						"          RISK_VID,",
						"          RISK_NUMBER,",
						"          POLICY_ID,",
						"          POLICY_OVID",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select2",
						"select3 keyGenerate(output(skey as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> surrogateKey1",
						"lookup3 select(mapColumn(",
						"          TX_ID,",
						"          POLICY_ID = select1@POLICY_ID,",
						"          POLICY_OVID = select1@POLICY_OVID,",
						"          TX_CODE,",
						"          COVERAGE_VID,",
						"          COVERAGE_CODE,",
						"          COVERAGE_ID = select1@COVERAGE_ID,",
						"          RISK_ID,",
						"          RISK_OVID = RISK_VID,",
						"          RISK_NUMBER,",
						"          SECTION_ID,",
						"          SECTION_VID",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select3",
						"lookup2, polSection lookup(select1@POLICY_ID == polSection@POLICY_ID",
						"     && select1@COVERAGE_ID == polSection@COVERAGE_ID,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> lookup3",
						"surrogateKey1 derive(TX_BRIDGE_ID = skey + maxIdCache#outputs()[1].maxId) ~> derivedColumn2",
						"select4, select6 join(select4@POLICY_ID == select6@POLICY_ID,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"polTxnStg, join1 join(polTxnStg@POLICY_ID == select4@POLICY_ID",
						"     && concat(split(TX_CODE,'-')[4],'-',split(TX_CODE,'-')[5],'-',split(TX_CODE,'-')[6],'-',split(TX_CODE,'-')[7],'-',split(TX_CODE,'-')[8]) == COVERAGE_CODE,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join2",
						"coverageStg select(mapColumn(",
						"          COVERAGE_ID,",
						"          COVERAGE_VID,",
						"          COVERAGE_CODE_ID,",
						"          POLICY_ID,",
						"          POLICY_OVID,",
						"          COV_STATE_ID,",
						"          COVERAGE_CODE",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select4",
						"stagingPolicy select(mapColumn(",
						"          POLICY_ID,",
						"          POLICY_VID,",
						"          POLICY_NUMBER,",
						"          ENTITY_TYPE,",
						"          ENTITY_STATUS,",
						"          REVISION_NUMBER,",
						"          POLICY_STATUS",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select6",
						"flowlet1@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          TX_BRIDGE_ID as long,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          TX_ID as long,",
						"          SECTION_ID as long,",
						"          SECTION_VID as long,",
						"          RISK_ID as long,",
						"          RISK_OVID as long,",
						"          CLASSIFICATION_ID as long,",
						"          CLASSIFICATION_OVID as long,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          DATA_HASH as binary,",
						"          SOURCE_KEY as string,",
						"          COVERAGE_ID as long,",
						"          COVERAGE_VID as long",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink1",
						"txnBridgeStagingMaxId sink(validateSchema: false,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     store: 'cache',",
						"     format: 'inline',",
						"     output: false,",
						"     saveOrder: 1) ~> maxIdCache"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_source_policy_txn')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "Source Stage Data Flows/txnDataFlow"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_source_Fact_Coverage_Premium",
								"type": "DatasetReference"
							},
							"name": "coverages"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_policy",
								"type": "DatasetReference"
							},
							"name": "polPolicy"
						},
						{
							"dataset": {
								"referenceName": "ds_source_stage_polTxn",
								"type": "DatasetReference"
							},
							"name": "txnStagingMaxId"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_source_stage_polTxn",
								"type": "DatasetReference"
							},
							"name": "polTxn"
						},
						{
							"name": "maxIdCache"
						}
					],
					"transformations": [
						{
							"name": "flowlet1",
							"flowlet": {
								"referenceName": "fl_source_addDefaultColumnFlowlet",
								"type": "DataFlowReference",
								"parameters": {
									"FL_batch": "1"
								}
							}
						},
						{
							"name": "polSelect"
						},
						{
							"name": "derivedColumn1"
						},
						{
							"name": "surrogateKey1"
						},
						{
							"name": "join1"
						}
					],
					"scriptLines": [
						"parameters{",
						"     policyPrefix as string,",
						"     policies as string[]",
						"}",
						"source(output(",
						"          Policy as string,",
						"          Policy_Sequence as string,",
						"          ARICLOB as string,",
						"          ARICGroupCode as string,",
						"          Description as string,",
						"          Product as string,",
						"          ARICCoverageCode as string,",
						"          ARICCoverageDescription as string,",
						"          EndorsementNumber as integer,",
						"          LocationNumber as string,",
						"          LocationUnitNumber as string,",
						"          BuildingNumber as string,",
						"          LocationName as string,",
						"          LocationAddress1 as string,",
						"          LocationAddress2 as string,",
						"          LocationAddress3 as string,",
						"          Occupancy as string,",
						"          LocationCity as string,",
						"          LocationZipCode as string,",
						"          LocationCounty as string,",
						"          Territory as string,",
						"          ConstructionCode as string,",
						"          ConstructionYear as integer,",
						"          NumberOfFloors as integer,",
						"          ProtectionClass as string,",
						"          GEOLatitude as decimal(11,8),",
						"          GEOLongitude as decimal(11,8),",
						"          CauseOfLoss as string,",
						"          BCEGClassCode as string,",
						"          CoverageForm as string,",
						"          DesignatedPremisis as string,",
						"          WindIndicatorFlag as string,",
						"          PurchaseCost as decimal(8,2),",
						"          dbo as string,",
						"          CoInsuranceBuilding as integer,",
						"          CoInsurancePersonalProperty as integer,",
						"          CoInsuranceBodilyInjury as integer,",
						"          CountryCode as string,",
						"          MunicipalityCode as string,",
						"          ParkName as string,",
						"          CountyCode as integer,",
						"          NumberParkSpaces as integer,",
						"          NumberOfAcres as integer,",
						"          OwnOrRent as string,",
						"          ResidenceTypeCode as string,",
						"          LocationZone as string,",
						"          ARICCoverageSequence as integer,",
						"          CoveragePart as string,",
						"          CoverageAddDate as timestamp,",
						"          CoverageDescription as string,",
						"          CoverageInternalCode as string,",
						"          CoverageAbbreviation as string,",
						"          CoveragePartSequence as integer,",
						"          CoverageISOLine as integer,",
						"          CoverageCATCode as string,",
						"          CoverageLine4 as integer,",
						"          CoverageAddUser as string,",
						"          CoverageUpdateDate as timestamp,",
						"          CoverageUpdateUser as string,",
						"          CoverageLineFlag as string,",
						"          LocationState as string,",
						"          ISOClassCode as string,",
						"          RetroEndorsementNumber as integer,",
						"          PolicyPrefix as string,",
						"          EffectiveDate as timestamp,",
						"          Policy_Accounting_date as timestamp,",
						"          ExpirationDate as timestamp,",
						"          CancelDate as timestamp,",
						"          CancelReason as string,",
						"          CancelReasonDescription as string,",
						"          PolicyTermMonths as integer,",
						"          InsuredName as string,",
						"          InsuredAddress1 as string,",
						"          InsuredAddress2 as string,",
						"          InsuredCity as string,",
						"          InsuredState as string,",
						"          InsuredZipCode as string,",
						"          CompanyCode as string,",
						"          CompanyName as string,",
						"          GroupName as string,",
						"          GBLICompanyCode as string,",
						"          AgentCode as string,",
						"          AgentName as string,",
						"          AgentOffice as string,",
						"          GroupCode as string,",
						"          AgentCity as string,",
						"          EMail as string,",
						"          AgentPhone as string,",
						"          AgentCounty as string,",
						"          AgentZipCode as string,",
						"          AgentAddress1 as string,",
						"          AgentAddress2 as string,",
						"          AgentState as string,",
						"          SubProducerNumber as string,",
						"          SubProducerCode as string,",
						"          SubProducerName as string,",
						"          SubproducerState as string,",
						"          SubProducerType as string,",
						"          ProductCode as string,",
						"          ProductCodeDescription as string,",
						"          PreviousPolicy as string,",
						"          OriginalPolicyYear as integer,",
						"          NonRenewalReason as string,",
						"          NonRenewalNoticeDate as timestamp,",
						"          DatabaseCode as string,",
						"          Policy_ID as integer,",
						"          MinimumPremium as decimal(13,0),",
						"          POlicy_Receive_date as timestamp,",
						"          MasterPolicy as string,",
						"          BillingType as string,",
						"          RowStatus as string,",
						"          OriginalInceptionDate as timestamp,",
						"          MultiplePolicyFlag as string,",
						"          ARICBusinessUnit as string,",
						"          HonorCurrentRateFlag as string,",
						"          FarmType as string,",
						"          PrimaryPremiumStateCode as string,",
						"          StateName as string,",
						"          Policy_Insert_Date as date,",
						"          BillingSystem as string,",
						"          Cov_effective_Date as timestamp,",
						"          Cov_Expiry_Date as timestamp,",
						"          ReceivedDate as date,",
						"          CoverageArrayNumber as integer,",
						"          LiabilityFlag as string,",
						"          ExperienceModFactor as decimal(7,4),",
						"          Exposure as decimal(8,0),",
						"          TaxFeeSurchargeFlag as string,",
						"          CancelReinstateFlag as string,",
						"          ReleasedFlag as string,",
						"          ReleaseDate as date,",
						"          Rate as decimal(12,6),",
						"          PremiumStateCode as string,",
						"          Coverage_ID as integer,",
						"          Coverage_accounting_date as timestamp,",
						"          Coverage_Insert_Date as date",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select  * from [dbo].[Fact_Coverage_Premium]  where PolicyPrefix='{$policyPrefix}'\"+iif(size($policies) >0&& size($policies) ==1&&$policies[1] =='','','and policy in ('+dropLeft(toString(reduce($policies, \"'\", #acc + \",'\" + #item +\"'\", #result)), 2)+')')),",
						"     format: 'query') ~> coverages",
						"source(output(",
						"          POLICY_ID as long,",
						"          POLICY_VID as long,",
						"          REINSURANCE_DAC as string,",
						"          PREVIOUS_INSURANCE_NO_REMARKS as string,",
						"          AGENCY_ID as long,",
						"          AGENCY_OVID as long,",
						"          PRODUCER_ID as long,",
						"          PRODUCER_OVID as long,",
						"          PRODUCER_CONTACT_ID as long,",
						"          PRODUCER_CONTACT_OVID as long,",
						"          POLICY_NUMBER as string,",
						"          ENTITY_TYPE as string,",
						"          ENTITY_STATUS as string,",
						"          IS_RENEWAL_YN as string,",
						"          REVISION_NUMBER as integer,",
						"          PRODUCT_ID as long,",
						"          PRODUCT_OVID as long,",
						"          POLICY_EFFECTIVE_DATE as timestamp,",
						"          POLICY_EXPIRATION_DATE as timestamp,",
						"          NON_RENEWAL_CODE as string,",
						"          POLICY_RENEWED_YN as string,",
						"          CANCELLATION_DATE as timestamp,",
						"          IS_RENEWABLE_YN as string,",
						"          PREVIOUS_INSURANCE_NO_REASON as string,",
						"          POLICY_STATUS as string,",
						"          CANCEL_REASON_CODE as string,",
						"          CANCEL_REASON_DESCRIPTION as string,",
						"          CANCEL_METHOD as string,",
						"          CANCEL_METHOD_DESC as string,",
						"          LOSE_REASON_CODE as string,",
						"          LOSE_REASON_DESC as string,",
						"          DECLINATION_REASON_CODE as string,",
						"          DECLINATION_REASON_DESC as string,",
						"          NOT_WRITTEN_REASON_CODE as string,",
						"          NOT_WRITTEN_REASON_DESC as string,",
						"          POLICY_STATE_CODE as string,",
						"          PROGRAM_ID as long,",
						"          PROGRAM_OVID as long,",
						"          BILLING_TYPE_CODE as string,",
						"          UNDERWRITING_COMPANY_ID as long,",
						"          UNDERWRITING_COMPANY_OVID as long,",
						"          SUBMISSION_ID as long,",
						"          PREVIOUS_INSURANCE_YN as string,",
						"          LEGACY_POLICY_NUMBER as string,",
						"          STATE as string,",
						"          POLICY_POLICY as integer,",
						"          PAYMENT_PLAN as string,",
						"          APPLICATION_RECEIVED_DATE as timestamp,",
						"          INCEPTION_DATE as timestamp,",
						"          BILL_TYPE as string,",
						"          FORMS_LANGUAGE as string,",
						"          BASE_CURRENCY as string,",
						"          INVOICE_CURRENCY as string,",
						"          PREVIOUS_POLICY_ID as long,",
						"          PREVIOUS_POLICY_OVID as long,",
						"          REVISED_FROM_POLICY_ID as long,",
						"          REVISED_FROM_POLICY_OVID as long,",
						"          OPERATING_COMPANY_ID as long,",
						"          OPERATING_COMPANY_OVID as long,",
						"          CONVERTED_FROM_ID as long,",
						"          CONVERTED_FROM_OVID as long,",
						"          INSTALLMENT_RENEWAL as string,",
						"          IS_VALID_YN as string,",
						"          VALID_START_DATE as timestamp,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          VALID_END_DATE as timestamp,",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          SOURCE_KEY as string,",
						"          DATA_HASH as binary",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: (\"select * from [dbo].[POL_POLICY] where ENTITY_TYPE ='{$policyPrefix}' \"+iif(size($policies) >0&& size($policies) ==1&&$policies[1] =='','','and policy_number in ('+dropLeft(toString(reduce($policies, \"'\", #acc + \",'\" + #item +\"'\", #result)), 2)+')')),",
						"     format: 'query') ~> polPolicy",
						"source(output(",
						"          maxId as long",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     isolationLevel: 'READ_UNCOMMITTED',",
						"     query: 'SELECT isnull(MAX(TX_ID), 0) as maxId\\nFROM dbo.POL_TX',",
						"     format: 'query') ~> txnStagingMaxId",
						"derivedColumn1 compose(mapParameter(",
						"          FL_batch = 1",
						"     ),",
						"     composition: 'fl_source_addDefaultColumnFlowlet') ~> flowlet1@(output1)",
						"polPolicy select(mapColumn(",
						"          POLICY_ID,",
						"          POLICY_VID,",
						"          POLICY_NUMBER",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> polSelect",
						"surrogateKey1 derive(TX_CODE = concat(Policy_Sequence,'-',LocationNumber,'-',LocationUnitNumber,'-',ARICGroupCode,'-',PrimaryPremiumStateCode,'-', ARICLOB,'-',ARICCoverageCode,'-',toString(ARICCoverageSequence)),",
						"          TX_ID = skey + maxIdCache#outputs()[1].maxId,",
						"          TYPE_OF_CHANGE = case(Policy_Sequence=='01','NBS' , ''),",
						"          POLICY_ID = polSelect@POLICY_ID,",
						"          POLICY_OVID = POLICY_VID) ~> derivedColumn1",
						"join1 keyGenerate(output(skey as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> surrogateKey1",
						"coverages, polSelect join(Policy == POLICY_NUMBER,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"flowlet1@output1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          TX_ID as long,",
						"          POLICY_ID as long,",
						"          POLICY_OVID as long,",
						"          TX_CODE as string,",
						"          SUB_ACTIVITY as string,",
						"          ENDORSEMENT_SEQ_NO as integer,",
						"          IS_SYSTEM_GENERATED_YN as string,",
						"          ENDORSEMENT_CHANGES as string,",
						"          TRANSACTION_EFFECTIVE_DATE as timestamp,",
						"          TRANSACTION_EXPIRY_DATE as timestamp,",
						"          TRANSACTION_BOOK_FLAG_DATE as timestamp,",
						"          PARENT_TRANSACTION_ID as integer,",
						"          TRANSACTION_TYPE_CODE as string,",
						"          TYPE_OF_CHANGE as string,",
						"          TRANSACTION_CREATED_DATE as timestamp,",
						"          TRANSACTION_MODIFIED_DATE as timestamp,",
						"          TRANSACTION_DISPLAY_NAME as string,",
						"          TRANSACTION_PERIOD_PRORATION as decimal(19,9),",
						"          BATCH_ID as long,",
						"          UNIQUE_IDENTIFIER as string,",
						"          DELETED_YN as string,",
						"          BPAM_LAST_MODIFIED_DATE as timestamp,",
						"          BPAM_LAST_CREATED_DATE as timestamp,",
						"          DATA_HASH as binary,",
						"          SOURCE_KEY as string",
						"     ),",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> polTxn",
						"txnStagingMaxId sink(validateSchema: false,",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     store: 'cache',",
						"     format: 'inline',",
						"     output: false,",
						"     saveOrder: 1) ~> maxIdCache"
					]
				}
			},
			"dependsOn": []
		}
	]
}